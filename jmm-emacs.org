#+TITLE: Josh Moller-Mara's Emacs configuration
#+OPTIONS: toc:1 h:4

The whole org-babel setup is shamelessly stolen from Sacha Chua.
* Personal information
  Here I set up my name and email, which is used for things like Gnus.
#+begin_src emacs-lisp
  (setq user-full-name "Joshua Moller-Mara"
        user-mail-address "jmm@cns.nyu.edu")
#+end_src

* Emacs initialization and package management
  Here I set up where to find my Elisp files, and the repositories for
  packages.
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/elisp")
  (add-to-list 'load-path "~/.emacs.d/elisp")
  (require 'package)
  (package-initialize)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
  (add-to-list 'package-archives '("ELPA" . "https://elpa.gnu.org/packages/") t)
  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/") t)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+end_src

  Install packages if they aren't already.

#+BEGIN_SRC emacs-lisp
  (package-initialize)
  (when (not package-archive-contents)
    (package-refresh-contents))
  (defvar my-packages '(ess
                        magit
                        helm
                        auctex
                        zenburn-theme
                        multiple-cursors
                        phi-search
                        expand-region
                        async
                        auto-complete
                        projectile
                        ledger-mode
                        helm-projectile
                        helm-swoop
                        js2-mode
                        flycheck
                        use-package
                        ))

  (dolist (p my-packages)
    (when (not(package-installed-p p))
      (package-install p)))
  (setq use-package-verbose t)
  (require 'use-package)
  (use-package auto-compile
    :ensure t
    :config (auto-compile-on-load-mode))
  (setq load-prefer-newer t)
#+END_SRC


  If I make any changes using Custom, I want them to be in a separate file.
#+begin_src emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (if (file-exists-p custom-file)
      (load custom-file))
#+end_src

  Secret info. (Authentication info)
#+begin_src emacs-lisp
  (let ((secrets "~/.emacs.d/secrets.el"))
    (if (file-exists-p secrets) (load-file secrets)))
#+end_src

** Byte compile stuff?

#+begin_src emacs-lisp
(defun emacs/byte-recompile ()
  (interactive)
  (byte-recompile-directory "~/.emacs.d" 0)
  (byte-recompile-directory "~/elisp" 0))
#+end_src

* Basic configuration

Enable all the disabled commands
#+begin_src emacs-lisp
  (setq disabled-command-function nil)
#+end_src

#+begin_src emacs-lisp
  ;; I don't like having to type "yes"
  (fset 'yes-or-no-p 'y-or-n-p)

  (transient-mark-mode 1)
  (column-number-mode 1)
  (show-paren-mode 1)
  (menu-bar-mode -1)
  (tool-bar-mode 0)
  (ignore-errors (horizontal-scroll-bar-mode 0)) ;Doesn't exist on some earlier emacs
  (blink-cursor-mode 0)

  (set-register ?e '(file . "~/.emacs.d/jmm-emacs.org"))
  (set-register ?d '(file . "~/Downloads/"))
  (set-register ?l '(file . "~/org/josh-ledger.dat"))
  (set-register ?n '(file . "~/org/neuroecon.org"))
  (set-register ?o '(file . "~/org/gtd-test.org"))

  (server-start)

  (setq visible-bell 0)                   ;Set visible bell on.
  (setq ring-bell-function 'ignore)       ;Visible bell.

  (setq frame-title-format "Emacs - %b")
  (setq set-mark-command-repeat-pop t)
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
  (winner-mode 1)
  (setq focus-follows-mouse t)
  (setq mouse-autoselect-window t) ;Sloppy focus
  (setq inhibit-splash-screen t)
  (setq Man-notify-method 'pushy)
  (set-default-font "-misc-fixed-medium-r-normal-*-13-*-*-*-*-*-*-*")
  (setq visual-line-fringe-indicators '(nil right-curly-arrow))

  (setq history-length 1000)
  (setq history-delete-duplicates t)

  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "chromium")
  (setq shr-external-browser 'browse-url-generic) ;For eww
  (setq epg-gpg-program "gpg2")
#+end_src

Make scripts executable
#+begin_src emacs-lisp
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+end_src

** Prompt before exiting Emacs

#+begin_src emacs-lisp
(setq kill-emacs-query-functions
      (cons (lambda () (yes-or-no-p "Really kill Emacs?"))
     kill-emacs-query-functions))
#+end_src

** Dealing with the clipboard
#+begin_src emacs-lisp
(setq x-select-enable-clipboard t) ; as above
(setq interprogram-paste-function 'x-cut-buffer-or-selection-value)
(setq select-enable-primary t)
#+end_src
** Windmove
#+begin_src emacs-lisp
(windmove-default-keybindings 'control)
#+end_src

* Theme/Appearance
#+begin_src emacs-lisp
(add-to-list 'custom-theme-load-path "~/elisp/zenburn-emacs/")
(load-theme 'zenburn)
#+end_src
** Font
Set my font
#+BEGIN_SRC emacs-lisp
  (defun josh/set-my-font (myfont)
    (when (and window-system (x-list-fonts myfont))
      (set-frame-font myfont)
      (add-to-list 'default-frame-alist
                   (cons 'font myfont))))

  (josh/set-my-font "-unknown-DejaVu Sans Mono-normal-normal-normal-*-10-*-*-*-m-0-iso10646-1")
#+END_SRC
* Keybindings

#+begin_src emacs-lisp
  ;; (global-set-key (kbd "C-x g") 'gnus)
  ;; (global-set-key (kbd "C-x C-a") 'artist-mode)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (global-set-key (kbd "<f9> m") 'magit-status)
  (define-key (current-global-map) [remap imenu] 'helm-imenu)
  ;; Replaced with helm
#+end_src

* Autosaves and backups

Autosaves
#+begin_src emacs-lisp
;; Put autosave files (ie #foo#) in one place, *not*
;; scattered all over the file system!
(defvar autosave-dir
 "~/emacs_autosaves/")

(make-directory autosave-dir t)

(defun auto-save-file-name-p (filename)
  (string-match "^#.*#$" (file-name-nondirectory filename)))

(defun make-auto-save-file-name ()
  (concat autosave-dir
   (if buffer-file-name
      (concat "#" (file-name-nondirectory buffer-file-name) "#")
    (expand-file-name
     (concat "#%" (buffer-name) "#")))))
#+end_src

Backups
Put backup files (ie foo~) in one place too. (The backup-directory-alist
list contains regexp=>directory mappings; filenames matching a regexp are
backed up in the corresponding directory. Emacs will mkdir it if necessary.)
#+begin_src emacs-lisp
  (defvar backup-dir "~/emacs_backups/")
  (make-directory backup-dir t)
  (setq backup-directory-alist (list (cons ".dreams." ".") (cons "." backup-dir)))
#+end_src

* Autocompletion, Hippie expand

#+begin_src emacs-lisp
(global-set-key (kbd "M-<return>") 'complete-tag) ;;bind complete-tag.
(global-set-key (kbd "M-?") 'hippie-expand)
#+end_src

** Hippie Expand stuff:

#+begin_src emacs-lisp
(setq hippie-expand-try-functions-list (quote (try-complete-file-name-partially try-complete-file-name try-expand-all-abbrevs try-expand-list try-expand-line try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill try-complete-lisp-symbol-partially try-complete-lisp-symbol try-expand-dict-command)))
#+end_src

#+begin_src emacs-lisp
(defun he-dict-command-beg ()
  (let ((p))
    (save-excursion
      (backward-word 1)
      (setq p (point)))
    p))

(defun try-expand-dict-command (old)
  (unless old
    (he-init-string (he-dict-command-beg) (point))
    (setq he-expand-list (sort
			  (all-completions he-search-string (mapcar 'list (lookup-words (concat old "*") ispell-complete-word-dict)))
			  'string-lessp)))
  (while (and he-expand-list
              (he-string-member (car he-expand-list) he-tried-table))
    (setq he-expand-list (cdr he-expand-list)))
  (if (null he-expand-list)
      (progn
	(when old (he-reset-string))
	())
    (he-substitute-string (car he-expand-list))
    (setq he-tried-table (cons (car he-expand-list) (cdr he-tried-table)))
    (setq he-expand-list (cdr he-expand-list))
    t))
#+end_src

* Compiling conveniences

#+begin_src emacs-lisp
(require 'compile)
(add-hook 'c++-mode-hook
	  (lambda ()
	    (unless (file-exists-p "Makefile")
	      (set (make-local-variable 'compile-command)
		   ;; emulate make's .c.o implicit pattern rule, but with
		   ;; different defaults for the CC, CPPFLAGS, and CFLAGS
		   ;; variables:
		   ;; $(CC) -c -o $@ $(CPPFLAGS) $(CFLAGS) $<
		   (let ((file (file-name-nondirectory buffer-file-name)))
		     (format "%s %s %s -o %s"
			     (or (getenv "CPP") "g++")
			     (or (getenv "CFLAGS") "-g -Os")
			     file
			     (file-name-sans-extension file)
			     ))))))
#+end_src

#+begin_src emacs-lisp
(global-set-key (kbd "<f9> <f9>") 'recompile)
#+end_src

#+begin_src emacs-lisp
(setq compilation-scroll-output 1)
#+end_src

* Spelling

#+begin_src emacs-lisp
  (setq-default ispell-program-name "hunspell")
  (setq-default ispell-grep-command "grep")
  (setq-default ispell-grep-options "-iE")
  (setq-default ispell-complete-word-dict "/usr/share/dict/american-english")
  (setq-default ispell-silently-savep t)
  (use-package rw-hunspell)
#+end_src

#+begin_src emacs-lisp
(add-hook `text-mode-hook `flyspell-mode)
(add-hook `latex-mode-hook `flyspell-mode)
(add-hook `tex-mode-hook `flyspell-mode)
(add-hook `bibtex-mode-hook `flyspell-mode)
#+end_src

** Accepting previous misspelled words

#+begin_src emacs-lisp
(defun flyspell-accept-prev (position &optional savetype)
  "Accept the previously mispelled word onscreen. Defaults saving to session, but optional savetype can save to personal dict"
  (interactive "d")
  (or savetype (setq savetype 'session))
  (let ((top (window-start))
	(bot (window-end))
	correctpos)
    (save-excursion
      (save-restriction
	(narrow-to-region top bot)
	(overlay-recenter (point))

	  (let ((overlay-list (overlays-in (point-min) position))
		(new-overlay 'dummy-value))

	    ;; search for previous (new) flyspell overlay
	    (while (and new-overlay
			(or (not (flyspell-overlay-p new-overlay))
			    ;; check if its face has changed
			    (not (eq (get-char-property
				      (overlay-start new-overlay) 'face)
				     'flyspell-incorrect))))
	      (setq new-overlay (car-safe overlay-list))
	      (setq overlay-list (cdr-safe overlay-list)))

	    ;; if nothing new exits new-overlay should be nil
	    (if new-overlay ;; the length of the word may change so go to the start
		(setq correctpos
		      (overlay-start new-overlay))))

	(when correctpos
	  (save-excursion
	    (goto-char correctpos)
	    (let ((cursor-location (point))
		  (opoint (point))
		  (word (flyspell-get-word)))
	      (if (consp word)
		  (let ((start (car (cdr word)))
			(end (car (cdr (cdr word))))
			(word (car word))
			poss ispell-filter)
		    (flyspell-do-correct savetype poss word cursor-location start end opoint)
		    (ispell-pdict-save t))))))))))

(defun flyspell-accept-prev-save (position)
  "Save the previously mispelled word. See flyspell-accept-prev"
  (interactive "d")
  (flyspell-accept-prev position 'save))

(add-hook 'flyspell-mode-hook
 (lambda ()
   (define-key flyspell-mode-map (kbd "C-M-;") 'flyspell-accept-prev)
   (define-key flyspell-mode-map (kbd "C-:") 'flyspell-accept-prev-save)
   ))
#+end_src

* LaTeX

#+begin_src emacs-lisp
(setq latex-run-command "pdflatex")
(setq tex-output-extension ".pdf")
#+end_src

#+begin_src emacs-lisp
(add-hook `latex-mode-hook (lambda () (defun tex-view ()
  (interactive)
  (tex-send-command "evince" (tex-append tex-print-file ".pdf") t))))
#+end_src

Make it easier to insert Greek symbols
#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
#+end_src

** Bibtex stuff (no longer needed?)
#+begin_src emacs-lisp
(add-hook 'latex-mode-hook
	  (lambda ()
	    (defun tex-bibtex-file ()
	      "Run BibTeX on the current buffer's file."
	      (interactive)
	      (if (tex-shell-running)
		  (tex-kill-job)
		(tex-start-shell))
	      (let* (shell-dirtrack-verbose
		     (source-file (tex-main-file))
		     (tex-out-file
		      (tex-append (file-name-nondirectory source-file) ""))
		     (file-dir (file-name-directory (expand-file-name source-file))))
		(tex-send-command tex-shell-cd-command file-dir)
		(tex-send-command tex-bibtex-command tex-out-file))
	      (tex-display-shell))))
#+end_src

** AUCTeX and skeletons
#+begin_src emacs-lisp
  ;; AUCTeX
  ;; (setq load-path (append load-path "~/.emacs.d/elpa/auctex-11.87.2/"))
  ;; (load "auctex.el" nil t t)
  ;; (load "preview-latex.el" nil t t)
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq-default TeX-master nil)
  (add-hook 'LaTeX-mode-hook 'TeX-PDF-mode) ;use pdflatex by default

  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
  (setq reftex-plug-into-AUCTeX t)

  (setq skeleton-end-newline nil)
  (add-hook 'LaTeX-mode-hook
   (lambda ()
     (define-key LaTeX-mode-map (kbd "` v (") 'latex-skeleton-left-paren)
     (define-key LaTeX-mode-map (kbd "` v [") 'latex-skeleton-left-bracket)
     (define-key LaTeX-mode-map (kbd "` v {") 'latex-skeleton-left-brace)
     (define-key LaTeX-mode-map (kbd "` v t") 'latex-math-text)
     (define-key LaTeX-mode-map (kbd "` v $") 'quoted-parens)
     (define-key LaTeX-mode-map (kbd "` v %") 'quoted-brackets)
     ))

  (define-skeleton latex-skeleton-left-paren
    "Insert \\left( ... \\right)."
    nil "\\left(" _ "\\right)")

  (define-skeleton latex-skeleton-left-bracket
    "Insert \\left[ ... \\right]."
    nil "\\left[" _ "\\right]")

  (define-skeleton latex-skeleton-left-brace
    "Insert \\left\\{ ... \\right\\}."
    nil "\\left\\{" _ "\\right\\}")

  (define-skeleton latex-math-text
    "Insert \\text{ ... }."
    nil "\\text{" _ "}")

  (define-skeleton quoted-parens
    "Insert \\( ... \\)."
    nil "\\(" _ "\\)")

  (define-skeleton quoted-brackets
    "Insert \\[ ... \\]."
    nil "\\[" _ "\\]")
#+end_src
** AUCTeX handling errors
Sometimes AUCTex can't parse errors correctly, prompting you to create a directory
#+begin_src emacs-lisp
(setq LaTeX-command-style '(("" "%(PDF)%(latex) -file-line-error %S%(PDFout)")))
#+end_src
* R/ESS
  This seems to be necessary when installing ESS from MELPA.
#+begin_src emacs-lisp
  (require 'ess-site)
#+end_src

#+begin_src emacs-lisp
  (setq comint-scroll-to-bottom-on-input t)
  (setq comint-scroll-to-bottom-on-output t)
  (setq comint-move-point-for-output t)

  (add-hook 'ess-mode-hook
            (lambda ()
              (flyspell-prog-mode)
              (auto-complete-mode 1)
              (ac-flyspell-workaround)))

  (add-hook 'inferior-ess-mode-hook
            (lambda ()
              (auto-complete-mode 1)))

  (autoload 'ess-rdired "ess-rdired"
    "View *R* objects in a dired-like buffer." t)
#+end_src
** JAGS
#+begin_src emacs-lisp
(require 'ess-jags-d)
#+end_src

** View an object
#+begin_src emacs-lisp
  (defun ess-dump-object-into-view-buffer (object)
    "Edit an ESS object in its view buffer."
    (interactive
     (progn
       (ess-force-buffer-current "Process to dump from: ")
       (if (ess-ddeclient-p)
           (list (read-string "Object to edit: "))
         (ess-read-object-name "Object to edit"))))
    (ess-execute (ess-rdired-get object)
               nil "R view" ))

  (eval-after-load "ess-mode"
    '(define-key ess-mode-map (kbd "C-c v") 'ess-dump-object-into-view-buffer))
#+end_src

** Clear the shell
#+begin_src emacs-lisp
(defun clear-shell ()
   (interactive)
   (let ((old-max comint-buffer-maximum-size))
     (setq comint-buffer-maximum-size 0)
     (comint-truncate-buffer)
     (setq comint-buffer-maximum-size old-max)))
#+end_src

** Truncate automatically
#+begin_src emacs-lisp
  (setq comint-buffer-maximum-size 2000)
  (add-hook 'comint-output-filter-functions
            'comint-truncate-buffer)
#+end_src
** Continuation indentation
   I like how ESS previously indented continuations as it makes ggplot
   code easier to read.
#+begin_src emacs-lisp
  (add-to-list 'ess-style-alist
               '(MY-STYLE
                 (ess-indent-level . 4)
                 (ess-first-continued-statement-offset . 4)
                 (ess-continued-statement-offset . 0)
                 (ess-brace-offset . 0)
                 (ess-arg-function-offset . 4)
                 (ess-arg-function-offset-new-line . '(4))
                 (ess-expression-offset . 4)
                 (ess-else-offset . 0)
                 (ess-close-brace-offset . 0)))
  (setq ess-default-style 'MY-STYLE)
#+end_src
** Polymode/Rmarkdown
   I'm experimenting with writing code in Rmarkdown, mostly because
   I'll write a bunch of R code, and then totally forget what it does
   or why I wrote it. Also, also, I want to generate nice reports. :D

  The way polymode renders Rmarkdown right now is a big weird. I think
  it just uses knitr. So here's some code from kwstat in uses
  https://github.com/vspinu/polymode/issues/30 that uses rmarkdown.
#+BEGIN_SRC emacs-lisp
  (use-package polymode
    :init
    (add-to-list 'auto-mode-alist '("\\.Rmd" . poly-markdown+r-mode))
    :config
    (define-key polymode-mode-map (kbd "M-n r") 'ess-render-rmarkdown))

  (defun ess-render-rmarkdown ()
    "Compile R markdown (.Rmd). Should work for any output type."
    (interactive)
    ;; Check if attached R-session
    (condition-case nil
        (ess-get-process)
      (error
       (ess-switch-process)))
    (let* ((rmd-buf (current-buffer)))
      (save-excursion
        (let* ((sprocess (ess-get-process ess-current-process-name))
               (sbuffer (process-buffer sprocess))
               (buf-coding (symbol-name buffer-file-coding-system))
               (buffer-file-name-html (concat (file-name-sans-extension buffer-file-name) ".html"))
               (R-cmd
                (format "library(rmarkdown); rmarkdown::render(\"%s\"); print(\"%s\")"
                        buffer-file-name buffer-file-name-html)))
          (message "Running rmarkdown on %s" buffer-file-name)
          (ess-execute R-cmd 'buffer nil nil)
          (switch-to-buffer rmd-buf)
          (ess-show-buffer (buffer-name sbuffer) nil)))))
#+END_SRC
* ERC
#+begin_src emacs-lisp
  (require 'erc-services)
  (erc-services-mode 1)
  (setq erc-nick "emdash"
        erc-server "localhost"
        erc-port "1799")
  (setq erc-auto-query 'bury)
#+end_src
** Notify
#+begin_src emacs-lisp
;;list of regexpes ignored by tray icon
(defun erc-tray-change-state (arg)
  "Enables or disable blinking, depending on arg"
  (if arg
      (shell-command-to-string
       "echo B > /tmp/tray_daemon_control")
    (shell-command-to-string
     "echo b > /tmp/tray_daemon_control")))
(defun erc-tray-update-state ()
  "Updates the state of the tray icon according to the contents
of erc-modified-channels-alist"
  (interactive)
  (let ((blinkify nil))
    (mapcar (lambda (el)
	      (when (string-match "erc-current-nick-face" (face-name (nthcdr 2 el)))
		(setq blinkify t)))
	    erc-modified-channels-alist)
    (erc-tray-change-state blinkify)))
(when window-system
  (add-hook 'erc-track-list-changed-hook 'erc-tray-update-state))
(setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT"))
#+end_src

** More notify stuff
#+begin_src emacs-lisp
  ;; Notify my when someone mentions my nick.
  (defun erc-global-notify (matched-type nick msg)
    (interactive)
    (when (eq matched-type 'current-nick)
      (shell-command
       (concat "notify-send -t 4000 -c \"im.received\" \""
               (car (split-string nick "!"))
               " mentioned your nick\" \""
               msg
               "\""))))
  (add-hook 'erc-text-matched-hook 'erc-global-notify)
#+end_src
** Timestamp
#+begin_src emacs-lisp
(make-variable-buffer-local
 (defvar erc-last-datestamp nil))

(defun ks-timestamp (string)
  (erc-insert-timestamp-left string)
  (let ((datestamp (erc-format-timestamp (current-time) erc-datestamp-format)))
    (unless (string= datestamp erc-last-datestamp)
      (erc-insert-timestamp-left datestamp)
      (setq erc-last-datestamp datestamp))))


(setq erc-timestamp-only-if-changed-flag t
      erc-timestamp-format "%H:%M "
      erc-datestamp-format " === [%Y-%m-%d %a] ===\n" ; mandatory ascii art
      erc-fill-prefix "      "
      erc-insert-timestamp-function 'ks-timestamp)
#+end_src

* rcirc
#+begin_src emacs-lisp
(require 'rcirc)
#+end_src
** Spelling
#+begin_src emacs-lisp
(add-hook 'rcirc-mode-hook (lambda ()
			     (flyspell-mode 1)))
#+end_src
** Other
#+begin_src emacs-lisp
  (setq rcirc-debug-flag t)

  ;; Adjust the colours of one of the faces.
  (set-face-foreground 'rcirc-my-nick "red" nil)

  (setq rcirc-default-nick "emdash")
  (setq rcirc-default-user-name "joshm")
  (setq rcirc-default-full-name "Josh Moller-Mara")

  (setq rcirc-buffer-maximum-lines 2000)
  ;; rcirc-server-alist moved to secrets file, as it contains passwords.

  (add-hook 'rcirc-mode-hook
            (lambda ()
              (rcirc-track-minor-mode 1)))

  (add-hook 'rcirc-mode-hook (lambda ()
                               (flyspell-mode 1)))

#+end_src

** Reconnect after disconnect

#+begin_src emacs-lisp
  (eval-after-load 'rcirc
    '(defun-rcirc-command reconnect (arg)
       "Reconnect the server process."
       (interactive "i")
       (unless process
         (error "There's no process for this target"))
       (let* ((server (car (process-contact process)))
              (port (process-contact process :service))
              (nick (rcirc-nick process))
              channels query-buffers)
         (dolist (buf (buffer-list))
           (with-current-buffer buf
             (when (eq process (rcirc-buffer-process))
               (remove-hook 'change-major-mode-hook
                            'rcirc-change-major-mode-hook)
               (if (rcirc-channel-p rcirc-target)
                   (setq channels (cons rcirc-target channels))
                 (setq query-buffers (cons buf query-buffers))))))
         (delete-process process)
         (rcirc-connect server port nick
                        rcirc-default-user-name
                        rcirc-default-full-name
                        channels))))
#+end_src

** Load rcirc-notify
#+begin_src emacs-lisp
  (eval-after-load 'rcirc '(use-package rcirc-notify))
#+end_src

** Load rcirc color
#+begin_src emacs-lisp
  (eval-after-load 'rcirc '(use-package rcirc-color))
#+end_src

** Display IRC activity in window manager
   I have a toolbar in my window manager that lets me see things like
   CPU usage, memory, etc. So I thought it'd be useful to also display
   IRC activity. This just passes rcirc's activity string to a script
   that updates the toolbar.
#+BEGIN_SRC emacs-lisp
  (defun josh/rcirc-activity-report ()
    "Report rcirc activity to the window manager, which displays it"
    (start-process "LogTime"
                     (get-buffer-create " *josh-rcirc-buffer*")
                     "~/.sawfish/scripts/rcirc-update.sh"
                     rcirc-activity-string))

  (add-hook 'rcirc-update-activity-string-hook 'josh/rcirc-activity-report)
#+END_SRC
* Scheme
#+begin_src emacs-lisp
(setq scheme-program-name "csi")

(defun run-half-scheme () "
   Run Scheme in half a window."
   (interactive)
   (split-window-vertically nil)
   (other-window 1)
   (call-interactively 'run-scheme))

(add-hook 'scheme-mode-hook
 (lambda ()
   (define-key scheme-mode-map (kbd "C-c C-s") 'run-half-scheme)
   ))
#+end_src
* C
#+begin_src emacs-lisp
(setq-default c-basic-offset 8)
(setq c-default-style "gnu")
#+end_src
* Shells
#+begin_src emacs-lisp
(defun run-half-shell ()
   "Run a shell in half a window."
   (interactive)
   (split-window-vertically nil)
   ;; (other-window 1)
   (shell (concat (buffer-name) " shell")))

(global-set-key (kbd "C-x 4 s") 'run-half-shell)
#+end_src
* Encryption
#+begin_src emacs-lisp
(require 'epa-file)			;So we can encrypt authinfo
(setq epa-file-cache-passphrase-for-symmetric-encryption t) ;So it doesn't ask for password multiple times
#+end_src
  Put the following on the top of files to encrypt them to myself.
  May need to run "normal-mode" to set the file local variables.
  Also, remember that just because files are encrypted to you does not
  mean they're signed by you. So when encrypting stuff for yourself,
  you may want to sign it.
#+begin_src emacs-lisp
  (set-register ?G "-*- epa-file-encrypt-to: (\"j.moller-mara@berkeley.edu\") -*-\n")
#+end_src
* BBDB
#+begin_src emacs-lisp
  (use-package bbdb
               :config (progn
                         (bbdb-initialize 'gnus 'message)
                         (setq bbdb-use-pop-up nil)              ;Don't pop up
                         (setq bbdb-quiet-about-name-mismatches nil)))
#+end_src
* GNUS
  I don't really use GNUS much anymore. I used to use it for email,
  news groups (when CS classes at Berkeley had them before Piazza),
  and reading RSS feeds.
#+begin_src emacs-lisp
(setq mail-user-agent 'gnus-user-agent)	;Uses Message mode instead of mail mode
#+end_src
** Spoofing dates
#+begin_src emacs-lisp
(defun gnus-date-spoof ()
  (interactive)
  (message-generate-headers '(Date))
  (setq message-deletable-headers (delq 'Date message-deletable-headers))
  (message "Deletable headers are %s %s" message-deletable-headers "(DONT FORGET SMTPMAIL-FQDN)"))

(defun gnus-date-unspoof ()
  (interactive)
  (add-to-list 'message-deletable-headers 'Date)
  (message "Deletable headers are %s" message-deletable-headers))
#+end_src

** Kill IMAP
Sometimes IMAP freezes, so I like to be able to kill it.
#+begin_src emacs-lisp
(defun kill-imap ()
  "Kill openssl imap"
  (interactive)
  ;; (delete-process "imap")
  (mapc (lambda (x) (if (string-match "imap" (process-name x)) (delete-process x))) (process-list)))
#+end_src

** Espeak article
   Read an article out loud
#+begin_src emacs-lisp
(defun josh/espeak-article (&optional arg)
  "Select the gnus article and read it"
  (interactive "P")
  (with-current-buffer gnus-article-buffer
    (save-excursion
      (save-restriction
        (widen)
        (when (article-goto-body)
          (let* ((wpm (number-to-string (* (if arg arg 5) 100)))
                 (process (start-process "espeak-process" " *espeak-gnus*" "espeak" "-a" "200" "-v" "english-us" "-s" wpm)))
            (process-send-region process (point) (point-max))
            (process-send-string process "\n")
            (process-send-eof process)))))))

;; (global-set-key (kbd "<f9> e") 'josh/espeak-article)
#+end_src

** Go to RSS link in browser
   This code basically gives me a hotkey ("v") that allows me to
   quickly open the link titled "link" in an external browser. This is
   pretty useful for RSS feeds when I'm interested in an article and
   want to read more.
#+BEGIN_SRC emacs-lisp
  (defun josh/get-link-info-at-point ()
    "Return a cons of the link's text and url"
    (let* ((widget (widget-at (point)))
           (start (widget-get widget :from))
           (end (widget-get widget :to)))
      (cons (if start
                (buffer-substring-no-properties start end))
            (widget-get widget :value))))

  (defun josh/get-all-links ()
    "Return a list of links in the buffer"
    (let (links)
      (save-excursion
        (goto-char (point-min))
        (while (progn
                 (let ((skip (text-property-any (point) (point-max) 'help-echo nil)))
                   (if (or (eobp)
                           (not (setq skip (text-property-not-all skip (point-max)
                                                                  'help-echo nil))))
                       nil
                     (progn
                       (goto-char skip)
                       (setq links (cons (josh/get-link-info-at-point) links)))))))
      links)))

  (defun josh/gnus-follow-link ()
    "Find the link named \"link\" and follow it in the browser"
    (interactive)
    (save-excursion
      (set-buffer gnus-article-buffer)
      (let ((link
             (-filter (lambda (x) (and (stringp (car x)) (string-match "link" (car x))))
                      (josh/get-all-links))))
        (if link
            (funcall shr-external-browser (cdar link))))))

  (add-hook 'gnus-summary-mode-hook
            (lambda ()
              (local-set-key (kbd "v") 'josh/gnus-follow-link)))
#+END_SRC
* Dired
** Listing switches
#+begin_src emacs-lisp
(setq dired-listing-switches "-alhv")
#+end_src
** Other settings
   I usually want to copy recursively. Don't ask me each time.
#+BEGIN_SRC emacs-lisp
  (setq dired-recursive-copies 'always)
#+END_SRC

  Apparently you can change permissions in ~wdired~
#+BEGIN_SRC emacs-lisp
(setq wdired-allow-to-change-permissions t)
#+END_SRC
** Dired-X
Because dired-jump is pretty useful
#+begin_src emacs-lisp
(add-hook 'dired-load-hook
	  (function (lambda () (load "dired-x"))))
#+end_src

** Copying remote file paths
   Sometimes I want to get the remote file path name, in order to make it easier to rsync and scp.
#+BEGIN_SRC emacs-lisp
  (defun josh/dired-copy-remote-filename ()
    "Copy the file names of marked files in a way that's easy to
  paste into a terminal. Hopefully understandable by rsync or scp."
    (interactive)
    ;; Get the default directory's host name
    (concat default-directory)
    (let ((string 
           (mapconcat 'identity
                      (mapcar (lambda (path)
                                (if (tramp-tramp-file-p path)
                                    (let* ((dissect (tramp-dissect-file-name path))
                                           (user (elt dissect 1))
                                           (host (elt dissect 2))
                                           (loc (elt dissect 3)))
                                      (concat (if user (concat user "@")) host ":" "\"" (shell-quote-argument loc) "\"")
                                      )
                                  (concat "\"" (shell-quote-argument path) "\"")))
                              (dired-get-marked-files))
                      " ")))
      (kill-new string)
      (x-set-selection 'PRIMARY string)   ;So I can middle click paste it into xterm
      (message "%s" string)))

  (eval-after-load 'dired
                       '(define-key dired-mode-map (kbd "W") 'josh/dired-copy-remote-filename))
#+END_SRC

** Opening files with xdg-open

#+BEGIN_SRC emacs-lisp
    (defun xah-open-in-external-app ()
    "Open the current file or dired marked files in external app.
  The app is chosen from your OS's preference.

  URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'
  Version 2015-01-26"
    (interactive)
    (let* (
           (xah-file-list
            (if (string-equal major-mode "dired-mode")
                (dired-get-marked-files)
              (list (buffer-file-name))))
           (xah-do-it-p (if (<= (length xah-file-list) 5)
                         t
                       (y-or-n-p "Open more than 5 files? "))))

      (when xah-do-it-p
        (cond
         ((string-equal system-type "windows-nt")
          (mapc
           (lambda (fPath)
             (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t))) xah-file-list))
         ((string-equal system-type "darwin")
          (mapc
           (lambda (fPath) (shell-command (format "open \"%s\"" fPath)))  xah-file-list))
         ((string-equal system-type "gnu/linux")
          (mapc
           (lambda (fPath) (let ((process-connection-type nil)) (start-process "" nil "xdg-open" fPath))) xah-file-list))))))

    (add-hook 'dired-mode-hook '(lambda () 
                                  (local-set-key (kbd "E") 'xah-open-in-external-app)))
#+END_SRC

** Playing files with mpv
#+BEGIN_SRC emacs-lisp
  (defun josh/open-with-mpv ()
    (interactive)
    (let ((thefiles (dired-get-marked-files))
          (process-connection-type nil))
      (apply 'start-process "" nil "mpvappendscrobble" thefiles)
      (message (format "Played %i files" (length thefiles)))))

  (add-hook 'dired-mode-hook '(lambda ()
                                (local-set-key (kbd "J") 'josh/open-with-mpv)))
#+END_SRC
** git-annex
   I'm messing around with git-annex, and it's nice to be able to view
   locked files by their name and not as a giant symlink in dired.
#+BEGIN_SRC emacs-lisp
  (use-package git-annex
    :config
    (git-annex-dired-do-to-files "lock" "Annex: locked %d file(s)")
    (git-annex-dired-do-to-files "unlock" "Annex: unlocked %d file(s)")
    (define-key git-annex-dired-map "l" 'git-annex-dired-lock-files)
    (define-key git-annex-dired-map "u" 'git-annex-dired-unlock-files))
#+END_SRC
** Dired ranger
   dired-ranger (see [[https://github.com/Fuco1/dired-hacks][dired-hacks]]) adds some really convenient ways to
   copy and paste files between buffers. It's a lot easier than
   hitting ~C~ and scrolling through your find-file history looking
   for the right path to copy to.

#+BEGIN_SRC emacs-lisp
  (use-package dired-ranger
    :ensure t
    :bind (:map dired-mode-map
		("[" . dired-ranger-copy)
		("]" . dired-ranger-paste)
		("}" . dired-ranger-move)
		))
#+END_SRC

* Tramp
#+begin_src emacs-lisp
(require 'tramp)
#+end_src
** Proxies. Allow sudo
#+begin_src emacs-lisp
(set-default 'tramp-default-proxies-alist nil)
(add-to-list 'tramp-default-proxies-alist '((and (string-match system-name (tramp-file-name-host (car target-alist))) "DONTMATCHMEPLEASE") "\\`root\\'" "/ssh:%h:"))
#+end_src

** Prompt for Yubikeys
#+begin_src emacs-lisp
  (setq tramp-password-prompt-regexp "^.*\\(Yubikey\\|[pP]assword\\|[pP]assphrase\\).*: ? *")
#+end_src

** Kill Tramp buffers
   Sometimes, having Tramp buffers open will weirdly cause other Emacs
   functions to fail or load slowly. For example, if you've got a
   bunch of remote Tramp buffers open, using helm sometimes slows
   down, or sometimes using magit fails. I'm not sure why. Often I'd
   just like to kill all remote buffers so I don't have to wait for
   connections to be brought back up again. This function does that.
#+BEGIN_SRC emacs-lisp
  (defun josh/kill-tramp-buffers ()
    "Kill TRAMP buffers. This is useful if, for whatever reason, remote buffers are either slowing down emacs or making some commands act strangely."
    (interactive)
    (let ((i 0))
      (mapc (lambda (buff)
              (with-current-buffer buff
                (when (tramp-tramp-file-p default-directory)
                  (kill-buffer buff)
                  (setq i (1+ i)))))
            (buffer-list))
      (message (format "Killed %d buffer%s" i (if (eq i 1) "" "s")))))

  (global-set-key (kbd "<f9> t") 'josh/kill-tramp-buffers)
#+END_SRC
* Org Mode
  I make heavy use of [[http://orgmode.org/][Org-mode]], for organizing my TODOs, keeping track
  of ideas, references, and links, as well as for literate programming.

  Since I use a lot of the contributed modules, we make sure we've
  loaded ~org-plus-contrib~

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure org-plus-contrib
  :bind (("C-c c" . org-capture)
	 ("C-c a" . org-agenda)
	 ("C-c l" . org-store-link)
	 ("C-c L" . org-insert-link-global)
	 ("C-c o" . org-open-at-point-global))
  :init
  (setq org-indirect-buffer-display 'current-window)
  (setq org-catch-invisible-edits 'smart)
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
  (setq org-highest-priority ?A
	org-lowest-priority ?F
	org-default-priority ?D)
  (unbind-key "C-'" org-mode-map)
  :config
  (use-package org-screenshot)
  (use-package org-depend))
#+END_SRC
** Setup my agenda file
   Read from "org-agendas" where the agenda files are.
   Set the default span to a day view.
   I also have a script periodically export agendas. So to keep from
   destroying an agenda I'm currently viewing, I turn on sticky agendas.

   I find that time grids can get in my way if there are too many of
   them, so we'll just show a few times instead of the default of every two hours.
#+begin_src emacs-lisp
  (setq org-agenda-files (concat (file-name-as-directory org-directory) "org-agendas.txt"))
  (setq org-agenda-span 3)
  (setq org-agenda-sticky t)
  (setcar (nthcdr 2 org-agenda-time-grid) '(900 1200 1700))
#+end_src
** Default notes file?
   Note to self, figure out what the difference between this and agenda is.

#+begin_src emacs-lisp
  (setq org-default-notes-file (concat (file-name-as-directory org-directory) "gtd-test.org"))
#+end_src
** Capture templates
   Need to make this more portable across different systems. I think it defaults to org-directory.
#+begin_src emacs-lisp
(setq org-capture-templates
      '(("t" "Todo" entry (file+headline "gtd-test.org" "Tasks")
         "* TODO %i%?\n  Added: %U")
        ("r" "Refile" entry (file "refile.org")
         "* %i%?\n  Added: %U")
        ("a" "Today" entry (file+headline "gtd-test.org" "Tasks")
         "* TODO %?\n  SCHEDULED: <%<%Y-%m-%d %a>>\n  Added: %U")
        ("d" "Date" entry (file+datetree+prompt "~/org/journal.org")
         "* %?\n%t\n")
	("w" "Calendar" entry (file+headline "gtd-test.org" "Calendar")
         "* %?\n%^t\n")
	("E" "Event (from email)" entry (file+headline "gtd-test.org" "Calendar")
	 "* %:subject%?\n%^T\n%i\n%a%^{LOCATION}p")
        ("l" "Lookup stuff")
        ("ll" "Lookup" entry (file+headline "lookup.org" "Lookup")
         "* %?\n  Added: %U")
        ("lp" "Lookup paper" entry (file+headline "lookup.org" "Paper lookup")
         "* TODO %?")
	("lP" "Lookup paper (link)" entry (file+headline "lookup.org" "Paper lookup")
	 "* [[%c][%(www-get-page-title (current-kill 0))]]\n  Added: %U\n  - %c")
        ("L" "Lookup link" entry (file+headline "lookup.org" "Lookup")
         "* [[%c][%(www-get-page-title (current-kill 0))]]\n  Added: %U\n  - %c")
        ("s" "Shopping" entry (file+headline "gtd-test.org" "Shopping")
         "* %?\n  Added: %U")
        ("N" "Neuroecon" entry (file+headline "neuroecon.org" "Neuroecon")
         "* %?\n%i\n  Added: %U")
	("n" "NYU")
	("ne" "NYU Events" entry (file+headline "nyu.org" "NYU Events Calendar") "* %?\n%^t\n")
	("nc" "CNS Events" entry (file+headline "nyu.org" "CNS Events") "* %?\n%^t\n")
	("nd" "Service disruption" entry (file+headline "nyu.org" "Service disruption") "* %?\n%^t\n")
        ("M" "Someday/Maybe" entry (file+headline "someday-maybe.org" "Someday/Maybe")
         "* %?\n  Added: %U")
        ("m" "Someday/Maybe lists")
        ("mm" "Someday/Maybe" entry (file+headline "someday-maybe.org" "Someday/Maybe")
         "* %?\n  Added: %U")
        ("mc" "Computer maybe" entry (file+headline "someday-maybe.org" "Computer Maybe")
         "* %?\n  Added: %U")
        ("ml" "Learn" entry (file+headline "someday-maybe.org" "Learn")
         "* %?\n  Added: %U")
        ("mb" "Books/Reading" entry (file+headline "movies-books-media.org" "Books/Reading")
         "* %?\n  Added: %U")
        ("mv" "Movies" entry (file+headline "movies-books-media.org" "Movies")
         "* %?\n  Added: %U")
        ("ma" "Audio/Music" entry (file+headline "movies-books-media.org" "Music/Audio")
         "* %?\n  Added: %U")
        ("ms" "Shanghai goals" entry (file+headline "someday-maybe.org" "Shanghai Goals")
         "* %?\n  Added: %U")
        ("o" "thoughts" plain (file "thoughts-misc.txt")
         "\n\n%U -\n\n %?\n" :empty-lines 1)
        ("e" "Erlich stuff")
        ("et" "Erlich tasks" entry (file+headline "erlich.org" "Erlich tasks")
         "* TODO %i%?\n  Added: %U")
        ("ea" "Erlich today" entry (file+headline "erlich.org" "Erlich tasks")
         "* TODO %?\n  SCHEDULED: <%<%Y-%m-%d %a>>\n  Added: %U")
        ("eo" "Erlich thoughts" entry (file+headline "erlich.org" "Erlich thoughts")
         "* %i%?\n  Added: %U")
        ("em" "Erlich maybe" entry (file+headline "erlich.org" "Erlich maybe")
         "* %?\n  Added: %U")
        ("j" "Journal Stuff")
        ("jr" "Journal Resume" entry (file+datetree "~/org/journal.org")
         "* %?\n%U\n" :clock-in t :clock-resume t)
        ("jc" "Journal Clock-In" entry (file+datetree "~/org/journal.org")
         "* %?\n%U\n" :clock-in t :clock-keep t)
        ("ji" "Journal Clock-In Immediate" entry (file+datetree "~/org/journal.org")
         "* %c %u\n%U\n" :clock-in t :clock-keep t :immediate-finish t)
        ("J" "Jokes" plain (file "jokes.txt")
         "\n\n%U -\n\n %?\n" :empty-lines 1)
        ("v" "Vocabulary" entry
         (file+headline "~/reading/words-i-learned.org" "Vocabulary")
         "* %^{The word} :drill:\n Added: %U\n %^{Extended word (may be empty)|%\\1}\n** Answer \n%^{The definition}")
        ("V" "Two-sided Vocabulary" entry
         (file+headline "~/reading/words-i-learned.org" "Vocabulary")
         "* <[%^{The word}]> :drill:\n Added: %U\n    :PROPERTIES:\n    :DRILL_CARD_TYPE: twosided\n    :END:\n** Word\n%^{Extended word (may be empty)|%\\1}\n** Definition\n%^{Definition}\n** Examples\n%^{Examples}\n")
        ("c" "Chinese Word" entry
         (file+headline "~/reading/skip/chinese.org" "Words")
         "* <[%(josh/chinese-prompt)]> :drill:\n Added: %U\nDefinition:\n%(josh/chinese-get-definition (josh/chinese-dict-find josh/chinese-word))\n** Characters\n%(josh/chinese-get-word josh/chinese-word-dict)\n** Pronunciation\n%(josh/chinese-get-pronunciation josh/chinese-word-dict)\n** Cangjie\n%(josh/chinese-cangjie-codes josh/chinese-words)\n")
        ("C" "Chinese Word (Read)" entry
         (file+headline "~/reading/skip/chinese.org" "Words")
         "* <[%(josh/chinese-prompt)]> :drill:\n Added: %U\n%(josh/chinese-get-word (josh/chinese-dict-find josh/chinese-word))\n** Pronunciation\n%(josh/chinese-get-pronunciation josh/chinese-word-dict)\n** Cangjie\n%(josh/chinese-cangjie-codes josh/chinese-words)\n** Definition\n%(josh/chinese-get-definition josh/chinese-word-dict)\n")
        ("R" "reading" plain
         (file "~/org/data/reading.csv")
         "%(format-time-string \"%s\"),\"%(format-time-string \"%Y-%m-%d\")\",\"%(josh/prompt-book)\",%^{Start},%^{End}")
	("x" "Miscellaneous")
	("xt" "Tweet" entry (file+headline "ideas.org" "Tweets")
         "* %i%?\n  Added: %U")))
#+end_src
   Fix a bug causing org-capture to mess up line numbers. This can
   make loading things with long lines slow, though.
#+begin_src emacs-lisp
  (setq-default cache-long-scans nil)
  (setq org-element-use-cache nil)
#+end_src

   A a function to make testing capture templates easier.
#+BEGIN_SRC emacs-lisp
(defun josh/add-to-capture (template)
  (let ((key (car template)))
    (setq org-capture-templates
	  (delete-if (lambda (x) (equal (car x) key)) org-capture-templates))
    (add-to-list 'org-capture-templates
		 template)))
#+END_SRC
*** Get the title of a URL
    Used for a capture template. I want my links to also have a sort of description
#+BEGIN_SRC emacs-lisp
(defun www-get-page-title (url)
  "Modified from https://lists.gnu.org/archive/html/help-gnu-emacs/2010-07/msg00291.html"
  (let ((title))
    (with-current-buffer (url-retrieve-synchronously url)
      (let* ((title (progn (goto-char (point-min))
			   (when (re-search-forward "<title>\\([^<]*\\)</title>" nil t 1)
			     (match-string 1))))
	     (coding (progn (goto-char (point-min))
			    (when (re-search-forward "charset=\"?\\([-0-9a-zA-Z]*\\)\"?" nil t 1)
			      (match-string 1)))))
	(if (and coding (not (string= "" coding)))
	    (decode-coding-string title (intern (downcase coding)))
	  title)))))
#+END_SRC
** Org agenda listings
#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        (quote
         (("w" todo "WAITING")
          ("W" todo-tree "WAITING")
          ("H" "Office and Home Lists"
           ((agenda)
            (tags-todo "OFFICE")
            (tags-todo "HOME")
            (tags-todo "COMPUTER")
            (tags-todo "DVD")
            (tags-todo "READING")))
          ("b" "Things to do if bored"
           tags "IFBORED"
           ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done)))
           ("~/org/blockreddit/ifbored.html"))
          ("D" "Daily Action List"
           ((agenda "" ((org-agenda-ndays 1)
                        (org-agenda-sorting-strategy
                         (quote ((agenda time-up priority-down tag-up) )))
                        (org-deadline-warning-days 0)))))
          ("z" "ZPM (hipster PDA)"
           ((agenda "" ((org-agenda-span 33)
                        (org-habit-show-habits nil)
                        (org-agenda-show-log nil)
                        (org-agenda-start-with-clockreport-mode nil)
                        (org-agenda-sorting-strategy
                         (quote ((agenda time-up priority-down tag-up) )))
                        ))))
          ("U" "Unscheduled NoDeadline" alltodo ""
           ((org-agenda-skip-function
             '(org-agenda-skip-entry-if 'scheduled 'deadline))))
          ("d" agenda "" ((org-agenda-span 1)) ("~/agendas-org/day-agenda.html"))
          ("k" agenda "" ((org-agenda-span 7)) ("~/agendas-org/week-agenda.html"))
          ("X" agenda "" ((org-agenda-span 3)
                          ;; (org-agenda-start-with-log-mode t)
                          (org-agenda-start-with-clockreport-mode t)) ("~/org/newtab/agenda.html"))
          )))
#+end_src

Agenda of tasks that are labeled "TODO" but don't have any schedule or deadline.
#+BEGIN_SRC emacs-lisp
  (require 'org-agenda)
  (org-add-agenda-custom-command
   '("u" "Unscheduled" todo "TODO"
     ((org-agenda-skip-function (lambda () (or (zin/org-agenda-skip-tag "task" t)
                                               (org-agenda-skip-entry-if 'scheduled 'deadline))))
      (org-agenda-overriding-header "Unscheduled tasks: "))))
#+END_SRC

An agenda which shows which papers I should read.
#+BEGIN_SRC emacs-lisp
;; Note: josh/plist-get is defined elsewhere in this file
(defun jmm/org-get-raw-scheduled ()
  "Raw scheduled date for element at point."
  (concat				;If it's nil, don't display anything
   (josh/plist-get (org-element-at-point) 'headline :scheduled 'timestamp :raw-value)))

(defun jmm/org-get-raw-created ()
  "Raw created date for element at point."
  (concat				;If it's nil, don't display anything
   (org-entry-get (point) org-expiry-created-property-name)))

(defun jmm/org-get-created-set-property (agendastr)
  "Takes in a line AGENDASTR.
   If it has \"created-time\" set, return it.
   Otherwise looks for the `org-expiry-created-property-name' and sets \"created-time\""
  (let* ((has-ct-prop (plist-member (text-properties-at 0 agendastr) 'created-time))
	 (createdtime (cadr has-ct-prop)))
    (if has-ct-prop
	createdtime
      (let* ((createdprop (org-entry-get (get-text-property 0 'org-hd-marker agendastr) org-expiry-created-property-name))
	     (createts (if createdprop (org-time-string-to-absolute createdprop))))
	(org-add-props agendastr nil
	  'created-time createts)
	createts))))

(defun jmm/org-agenda-sort-created-time (a b)
  "To be set as `org-agenda-cmp-user-defined'.
   Very similar to `org-cmp-ts'"
  (let* ((def (if org-sort-agenda-notime-is-late most-positive-fixnum -1))
	 (ta (or (jmm/org-get-created-set-property a) def))
	 (tb (or (jmm/org-get-created-set-property b) def)))
    (cond ((< ta tb) -1)
	  ((< tb ta) +1))))

(org-add-agenda-custom-command
 '("j" "Journal articles"
   ((tags-todo "+paper"
	      ((org-agenda-overriding-header "Scheduled articles")
	       (org-agenda-skip-function '(org-agenda-skip-entry-if 'notscheduled 'todo 'done))
	       (org-agenda-prefix-format " %i %-5:c %-17(jmm/org-get-raw-scheduled) ")
	       (org-agenda-sorting-strategy '(scheduled-up))))
    (tags-todo "+paper"
	      ((org-agenda-overriding-header "Unscheduled articles")
	       (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled 'todo 'done))
	       (org-agenda-prefix-format " %i %-5:c %-22(jmm/org-get-raw-created) ")
	       (org-agenda-cmp-user-defined 'jmm/org-agenda-sort-created-time)
	       (org-sort-agenda-notime-is-late nil)
	       (org-agenda-sorting-strategy '(priority-down user-defined-down))))
    )
   ((org-agenda-hide-tags-regexp "paper"))))
#+END_SRC

A projects-related agenda. View next tasks, waiting, and stuck projects.
#+BEGIN_SRC emacs-lisp
  (org-add-agenda-custom-command
   '("P" "Projects and Next Tasks"
     ((tags-todo "-CANCELLED/!NEXT"
                 ((org-agenda-overriding-header "Next tasks")
                  (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)))
      (tags-todo "-CANCELLED+WAITING|HOLD/!"
                 ((org-agenda-overriding-header "Waiting tasks")
                  (org-agenda-skip-function 'bh/skip-non-tasks)))
      (tags-todo "-CANCELLED/!"
                 ((org-agenda-overriding-header "Stuck Projects")
                  (org-agenda-skip-function 'bh/skip-non-stuck-projects))))))
#+END_SRC

Same thing as above, but also include the next three days agenda.
#+BEGIN_SRC emacs-lisp
(org-add-agenda-custom-command
 '(" " "Default agenda"
   ((agenda "" ((org-agenda-prefix-format " %i %-12:c%?-12t% s%(josh/org-show-effort-and-clocked) ")
                (org-agenda-skip-scheduled-if-done t)
                (org-agenda-span 2)))
    (todo "NEXT"
          ((org-agenda-overriding-header "Unscheduled next tasks")
           (org-agenda-prefix-format " %i %-12:c%?-12t% s%(josh/org-format-next-time) ")
           (org-agenda-skip-function
            (lambda () (or (org-agenda-skip-entry-if 'scheduled 'deadline)
                           (bh/skip-projects-and-habits-and-single-tasks))))))
    (tags-todo "-CANCELLED+WAITING|HOLD/!"
               ((org-agenda-overriding-header "Unscheduled waiting tasks")
                (org-agenda-skip-function
                 (lambda () (org-agenda-skip-entry-if 'scheduled 'deadline)))
                (org-agenda-prefix-format " %i %-12:c%?-12t% s%(josh/org-format-waiting-time) ")))
    (tags-todo "-CANCELLED/!"
               ((org-agenda-overriding-header "Stuck Projects")
                (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                (org-agenda-prefix-format " %i %-12:c%?-12t% s%(josh/org-format-max-clock-time) ")))
    (tags "REFILE"
          ((org-agenda-hide-tags-regexp "REFILE")
	   (org-agenda-overriding-header "Refile:")))
    (todo "TODO"
          ((org-agenda-skip-function (lambda () (or (zin/org-agenda-skip-tag "task" t)
                                                    ;; (bh/skip-projects-and-habits)
                                                    (josh/skip-project-to-next-heading)
                                                    (org-agenda-skip-entry-if 'scheduled 'deadline))))
           (org-agenda-overriding-header "Unscheduled tasks: ")
           (org-agenda-prefix-format " %i %-12:c%?-12t% s%(josh/org-format-age-from-added) "))))))
(global-set-key (kbd "<f12>")
                (lambda ()
                  (interactive)
                  (org-agenda nil " ")))
#+END_SRC

Other agendas. Like movies to see, things I need to buy, and so on.
#+BEGIN_SRC emacs-lisp
(org-add-agenda-custom-command
   '("1" "Shopping" tags "+SHOPPING-TODO=\"DONE\"-TODO=\"CANCELLED\""
     ((org-agenda-hide-tags-regexp "SHOPPING")
      (org-agenda-overriding-header "Shopping stuff: "))))

(org-add-agenda-custom-command
   '("v" "Movies" tags "+movie-TODO=\"DONE\"-TODO=\"CANCELLED\""
     ((org-agenda-hide-tags-regexp "movie")
      (org-agenda-overriding-header "Movies to see: "))))
#+END_SRC

An agenda for unscheduled tasks where we've set a deadline, but never scheduled it.
Show earlier due entries first.

#+BEGIN_SRC emacs-lisp
(defun josh/plist-get (plist prop &rest rest-props)
  "Recursively apply `plist-get' to plist"
  (let ((got (plist-get plist prop)))
    (if (and got rest-props)
	(apply 'josh/plist-get got rest-props)
      got)))

(defun josh/org-get-raw-deadline ()
  "Raw raw deadline for element at point."
  (josh/plist-get (org-element-at-point) 'headline :deadline 'timestamp :raw-value))

(org-add-agenda-custom-command
   '("u" "Unscheduled Deadline" alltodo ""
     ((org-agenda-overriding-header "Unscheduled TODOs with deadlines")
      (org-agenda-prefix-format " %i %-12:c%?-12t% s%-22(josh/org-get-raw-deadline) ")
      (org-agenda-sorting-strategy '(deadline-up))
      (org-agenda-skip-function
       '(or (org-agenda-skip-entry-if 'scheduled 'notdeadline)
	    (and (bh/is-project-p) (bh/skip-non-stuck-projects)))))))
#+END_SRC

A basic agenda for goals.
In the future I should make this more nuanced.
- Which goals have I started?
- Which goals are deferred?
- What are the different categories of goals, and in what time range
  do I plan to have them done?
  - Do they have deadlines, or are they just lofty ideas?
- Some of these can have ~org-agenda-overriding-columns-format~ set to view it automatically
- Sort by deadlines or importance?

#+BEGIN_SRC emacs-lisp
;; TODO: Eventually just make this more like Sacha Chua's evil plans
(org-add-agenda-custom-command
   `("g" "Goals"
     ((tags "goal"
	    ((org-agenda-overriding-header "Goals")
	     (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))
      (tags "LIFEGOAL"
	    ((org-agenda-overriding-header "Life Goals")
	     )))
     ((org-agenda-overriding-columns-format "%50ITEM(Goal) %5Effort(Time){:} %6CLOCKSUM{Total}")
      (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
      ;; (org-agenda-view-columns-initially t)
      (org-agenda-hide-tags-regexp ,(rx (or "LIFEGOAL" "goal"))))))
#+END_SRC

** Org persistent tags
   Some tags that I might use a lot. (Or maybe I don't, but I just
   don't want to have the hotkeys for each of these tags repeatedly in
   each file.)
#+BEGIN_SRC emacs-lisp
(setq org-tag-persistent-alist '(("task" . ?t) ("drill" . ?d)
				 ("IGNORE" . ?i)
                                 ("IFBORED" . ?b)
				 ("CANCELLED" . ?C)
                                 ("work" . ?w) ("home" . ?h)
                                 ("REWARD" . ?R) ("SHOPPING" . ?s)
                                 ("PESARAN" . ?p) ("erlich" . ?e) ("NEURO" . ?n) ("nyu" . ?y)
                                 ("vague" . ?v) ("lookup" . ?l)
                                 ("CODING" . ?c)
                                 ("SHORTTERM" . ?S) ("LONGTERM" . ?L) ("goal" . ?g) ("LIFEGOAL" . ?G)))

(add-to-list 'org-tags-exclude-from-inheritance "IGNORE")
#+END_SRC
** Define a stuck project
   Stuck projects are projects that don't have a next action or a TODO.
   Also, make sure the "PROJECT" tag isn't inherited.
#+begin_src emacs-lisp
  (setq org-stuck-projects
             '("+PROJECT/-MAYBE-DONE" ("NEXT" "TODO") ("@SHOP")
               "\\<IGNORE\\>"))

  (add-to-list 'org-tags-exclude-from-inheritance "PROJECT")
#+end_src
** If I didn't want it to interfere with windmove
#+begin_src emacs-lisp
  ;; (setq org-replace-disputed-keys t)
#+end_src

** Writing my current task to a file
   I have a conky script that displays my current task. That way, even
   when I'm not in Emacs, I can see what task I'm supposed to be
   working on, and how long I've been clocked into it.
#+begin_src emacs-lisp
  (setq josh/clock-current-task-file "~/.currenttask")

  (defun josh/org-clock-in-conky ()
    (interactive)
    "Creates a file `josh/clock-current-task-file' with the current task and the time started.
  To be used with a script in conky to display what I'm working on."
    (if org-clock-current-task
        (with-temp-file josh/clock-current-task-file
            (progn
              (insert org-clock-current-task)
              (newline)
              (insert (format-time-string "%s" org-clock-start-time))
              (newline)))))

  (defun josh/org-clock-out-conky ()
    (interactive)
    "When I clock out, remove `josh/clock-current-task-file'"
    (if (file-exists-p josh/clock-current-task-file)
            (delete-file josh/clock-current-task-file)))

  ;; (add-hook 'org-clock-in-hook 'josh/org-clock-in-conky)
  ;; (add-hook 'org-clock-out-hook 'josh/org-clock-out-conky)
#+end_src

   Here's another hook that works with my "ceftoolbar" in sawfish.

   The ceftoolbar is a Chromium embedded framework toolbar that
   displays CPU usage, network usage, as well as my current task

#+begin_src emacs-lisp
  (defun josh/org-clock-2 ()
    (interactive)
    "When I clock in or out, call a script that updates the ceftoolbar"
    (start-process "LogTime"
                   (get-buffer-create " *josh-clock-buffer*")
                   "~/.sawfish/scripts/clock-in.sh"))

  (defun josh/org-clock-in-conky2 ()
    (josh/org-clock-in-conky)
    (josh/org-clock-2))

  (defun josh/org-clock-out-conky2 ()
    (josh/org-clock-out-conky)
    (josh/org-clock-2))

  (add-hook 'org-clock-in-hook 'josh/org-clock-in-conky2)
  (add-hook 'org-clock-out-hook 'josh/org-clock-out-conky2)

#+end_src

** Org-drill
Require org-drill.
Add random noise to the due dates of cards, so they're not always clumped together.
Also, change the default cloze delimiters, as the defaults weren't working well for me.
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/elisp/org-mode/contrib/lisp/")
  (use-package org-drill
               :config (progn
                         (add-to-list 'org-modules 'org-drill)
                         (setq org-drill-add-random-noise-to-intervals-p t)
                         (setq org-drill-hint-separator "||")
                         (setq org-drill-left-cloze-delimiter "<[")
                         (setq org-drill-right-cloze-delimiter "]>")
                         (setq org-drill-learn-fraction 0.25)))
#+end_src

*** org-preview-latex-fragment
    The function "org-preview-latex-fragment" was deprecated a while
    back, but org-drill still depends on it. So here's a quick hack
    that will display the LaTeX in org-drill.
#+BEGIN_SRC emacs-lisp
(defun org-preview-latex-fragment ()
  (interactive)
  (org-remove-latex-fragment-image-overlays)
  (org-toggle-latex-fragment '(4)))
#+END_SRC

** Org-habit
#+begin_src emacs-lisp
  (add-to-list 'org-modules 'org-habit)
  (require 'org-habit)
#+end_src

** Exporting
   Org-mode has a bunch of great tools for exporting into HTML, pdf,
   icalendar, and so forth.
*** Twitter bootstrap HTML
    The base HTML can look a little plain. This package uses bootstrap to theme HTML exports.
#+BEGIN_SRC emacs-lisp
(use-package ox-twbs
  :defer t)
#+END_SRC

*** For exporting latex
 http://blog.karssen.org/2013/08/22/using-bibtex-from-org-mode/
 #+begin_src emacs-lisp
   (setq org-latex-pdf-process '("latexmk -pdf -bibtex %f"))
 #+end_src
*** Exporting calendar files

Instead of always using org-agenda, I like viewing my events and
to-dos in a calendar format. Org-mode has a pretty decent icalendar
exporter, but I find I frequently need to export updated ~.ics~ files.

To not block emacs, I'd like a function to export my calendar files
asynchronously. And so we don't constantly perform redundant exports,
let's only export org-mode agenda files that are newer than their
~.ics~ counterparts.

#+BEGIN_SRC emacs-lisp

(defun jmm/org-should-export-new-ics ()
  "Should we export a new icalendar .ics file for the current buffer?
We do this if either
- The export file doesn't exist
- The export file is older than the current buffer file.

This function needs to be run in the context of the org file
we're considering exporting."
  (let ((file (buffer-file-name (buffer-base-buffer)))
	(export-file (org-export-output-file-name ".ics")))
    (or (not (file-exists-p export-file))
	(file-newer-than-file-p file export-file))))

(defun jmm/org-export-ical-stuff ()
  "Export icalendar stuff asynchronously. Only export newly modified files."
  (interactive)
  (let ((files (cl-remove-if-not #'file-exists-p (org-agenda-files t)))
	files-to-export)
    (dolist (file files files-to-export)
      (with-current-buffer (org-get-agenda-file-buffer file)
	(when (jmm/org-should-export-new-ics)
	  (push file files-to-export))))
    (setq the-files-to-export files-to-export)
    ;; TODO: Export all files, not just files that were changed?
    (if files-to-export
	(org-export-async-start
	    (lambda (results)
	      (message "Updated %d calendar files" (seq-length results))
	      (setq blah2 results)
	      (apply 'start-process "upload-ics-process" " *upload-ics-process*" "~/code/sh/upload-ical.sh" results)
	      (dolist (f results) (org-export-add-to-stack f 'icalendar)))
	  `(let (output-files)
	     (dolist (file ',files-to-export output-files)
	       (with-current-buffer (org-get-agenda-file-buffer file)
		 (push (expand-file-name (org-icalendar-export-to-ics))
		       output-files)))))
      (message "All icalendar files are already up to date"))))

(bind-key "<f9> i" 'jmm/org-export-ical-stuff)
#+END_SRC

** Clocking
*** Easier method to clock into some frequent habits
Some habits occur quite frequently, and it's kind of a pain to have to
find them in my GTD org file before clocking in. This simplifies
clocking into frequent tasks. (Mostly helps me track bad habits.)
#+begin_src emacs-lisp
  (require 'helm-adaptive)
  (defun josh/org-helm-candidates ()
    (interactive)
    (org-map-entries
     (lambda () (let* ((title (nth 4 (org-heading-components))))
                  (cons title (cons title (current-buffer)))))
     nil
     'agenda))

  (setq josh/helm-source-org-clock
    '((name . "Clock in to what")
      (candidates . josh/org-helm-candidates)
      (case-fold-search . t)
      (filtered-candidate-transformer
       helm-adaptive-sort)
      (action . (("Clock in"
                  . josh/org-clock-in)))))

  (defun josh/org-clock-in (candidate)
    "Clock into taskname in gtd-test"
    (interactive)
    (save-excursion
      (let* ((taskname (car candidate))
             (taskbuffer (cdr candidate))
             (place (org-find-exact-headline-in-buffer taskname taskbuffer)))
        (with-current-buffer (marker-buffer place)
          (goto-char place)
          (org-clock-in)))))

  (defun josh/helm-org-clock-in ()
    "Use helm to clock into a task"
    (interactive)
    (helm-other-buffer 'josh/helm-source-org-clock
                       "*Helm Clock-in*"))

  (defun josh/helm-org-jump-candidate (candidate)
    "Jump to a candidate with org"
    (interactive)
    (let* ((taskname (car candidate))
           (taskbuffer (cdr candidate))
           (place (org-find-exact-headline-in-buffer taskname taskbuffer)))
      (switch-to-buffer (marker-buffer place))
      (goto-char place)
      (org-show-context)))

  (setq josh/helm-jump-org
    '((name . "Jump to org")
      (candidates . josh/org-helm-candidates)
      (case-fold-search . t)
      (filtered-candidate-transformer
       helm-adaptive-sort)
      (action . (("Jump to"
                  . josh/helm-org-jump-candidate)))))

  (defun josh/helm-org-jump ()
    "Use helm to clock into a task"
    (interactive)
    (helm-other-buffer 'josh/helm-jump-org
                       "*Org Jump*"))

  (global-set-key (kbd "<f9> j") 'josh/helm-org-jump)
#+end_src

These functions clock into a task if it exists and creates it using
~org-capture~ if it doesn't.
#+BEGIN_SRC emacs-lisp
  (defun josh/org-clock-in2 (candidate)
    "Clock into taskname, creating it if it doesn't exist."
    (interactive)
    (if (stringp candidate)
        (progn
          (kill-new candidate)
          (org-capture nil "ji"))         ;Creates a task in datetree from kill ring
      (save-excursion
        (let* ((taskname (car candidate))
               (taskbuffer (cdr candidate))
               (place (org-find-exact-headline-in-buffer taskname taskbuffer)))
          (with-current-buffer (marker-buffer place)
            (goto-char place)
            (org-clock-in))))))

  (defun josh/helm-org-clock-in2 ()
    "Use helm to clock into a task, creating it if it doesn't exist."
    (interactive)
    (josh/org-clock-in2 (helm-comp-read "Clock in to: " (josh/org-helm-candidates))))

  (global-set-key (kbd "<f9> z") 'josh/helm-org-clock-in2)
#+END_SRC

*** Setting a timer on the current task
   I use =<f9> z= to set the current task. When I want to set a timer,
   for instance in a pomodoro-type fashion, I'll use this function
   which I have bound to =<f9> p=. It's the same thing as
   =org-timer-set-timer=, but I don't have to switch buffers to find
   the task I'm already clocked into.
#+begin_src emacs-lisp
  (defun josh/org-current-task-timer (&optional opt)
    "Find the current clocking task and set a timer on it."
    (interactive "P")
    (when (org-clocking-p)
      (save-excursion
        (org-no-warnings (set-buffer (org-clocking-buffer)))
        (save-restriction
          (widen)
          (goto-char org-clock-marker)
          (beginning-of-line 1)
          (org-timer-set-timer opt)))))

  (global-set-key (kbd "<f9> p") 'josh/org-current-task-timer)
#+end_src
*** Quick key for clocking into current task

    As well as clocking into previous tasks.

#+begin_src emacs-lisp
  (bind-key "<f11>" 'org-clock-jump-to-current-clock)
  (bind-key "C-<f11>" 'org-clock-in-last)
#+end_src

** Refiling to other places
   This is so we're able to refile to other files
#+begin_src emacs-lisp
  (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                   (org-agenda-files :maxlevel . 9)
                                   (("~/org/lookup.org") :maxlevel . 1))))
#+end_src
** Better task states
   From http://doc.norang.ca/org-mode.html
#+begin_src emacs-lisp
  (setq org-todo-keywords
         (quote ((sequence "TODO(t)" "NEXT(n!)" "|" "DONE(d)")
                 (sequence "WAITING(w@/!)" "HOLD(h@/!)" "MAYBE(m!)" "|" "CANCELLED(c@/!)" "DEFERRED(f@/!)"))))

  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "red" :weight bold)
                ("NEXT" :foreground "blue" :weight bold)
                ("DONE" :foreground "forest green" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
		("MAYBE" :foreground "yellow" :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold)
                ("DEFERRED" :foreground "tomato" :weight bold))))

  (setq org-todo-state-tags-triggers
        (quote (("CANCELLED" ("CANCELLED" . t))
                ("WAITING" ("WAITING" . t))
                ("HOLD" ("WAITING") ("HOLD" . t))
                (done ("WAITING") ("HOLD"))
                ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                ("DONE" ("WAITING") ("CANCELLED") ("HOLD") ("IFBORED")))))
#+end_src
** Babel
*** Babel languages and settings
#+begin_src emacs-lisp
(org-babel-do-load-languages
 (quote org-babel-load-languages)
 (quote ((emacs-lisp . t)
	 (ditaa . t)
	 (R . t)
	 (python . t)
	 (ipython .t)
	 (ledger . t)
	 (org . t)
	 (latex . t)
	 (sh . t)
	 (dot . t)
	 (sql . t))))

(setq org-edit-src-content-indentation 0
      org-src-tab-acts-natively t
      org-src-window-setup 'current-window)
#+end_src
*** Ditaa
#+begin_src emacs-lisp
  (setq org-ditaa-jar-path "/usr/bin/ditaa")
#+end_src
** Org Mobile Setup
   In order to sync to MobileOrg, you need to set org-mobile-directory
#+begin_src emacs-lisp
  (setq org-mobile-directory "~/org-mobile/")
#+end_src
** Tracking reading
   I'm trying to use a CSV file to track how much I read on a
   day-to-day basis. I add entries with a capture template, and these
   functions make it easier for me to enter in the book name without
   having to type it all out every time.
#+BEGIN_SRC emacs-lisp
(defun josh/prompt-book ()
  "Prompt for a book when tracking pages."
  (let ((book-out (helm-comp-read "Book: "
                                  josh/prompt-book-list
                                  :nomark t)))
    (add-to-list 'josh/prompt-book-list book-out)
    book-out))

(require 'cl)
(defun josh/prompt-book-build-list ()
  "Build a list of books I'm reading for completion in `josh/prompt-book'."
  (with-temp-buffer
    (insert-file-contents "~/org/data/reading.csv")
    (remove-duplicates
     (mapcar
      (lambda (x)
        (replace-regexp-in-string "\"" "" (nth 2 (split-string x "," t))))
      (cdr (split-string (buffer-string) "\n" t)))
     :test 'string=)))

(defvar josh/book-csv "~/org/data/reading.csv")
(defvar josh/prompt-book-list
  (if (file-exists-p josh/book-csv)
      (josh/prompt-book-build-list)))
#+END_SRC
** Org agenda filtering functions
   Here are a few org-agenda filtering functions for creating custom agendas. These do things like skip entries by tag, etc.
#+BEGIN_SRC emacs-lisp
  (defun zin/org-agenda-skip-tag (tag &optional others)
    "Skip all entries that correspond to TAG.

  If OTHERS is true, skip all entries that do not correspond to TAG."
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
          (current-headline (or (and (org-at-heading-p)
                                     (point))
                                (save-excursion (org-back-to-heading)))))
      (if others
          (if (not (member tag (org-get-tags-at current-headline)))
              next-headline
            nil)
        (if (member tag (org-get-tags-at current-headline))
            next-headline
          nil))))
#+END_SRC
*** Bernt Hansen's org functions
    [[http://doc.norang.ca/org-mode.html][This page]] has a really great org mode setup. Here I steal a few of his functions for filtering agenda views.
#+BEGIN_SRC emacs-lisp
  (defun bh/is-project-p ()
    "Any task with a todo keyword subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task has-subtask))))

  (defun bh/is-project-subtree-p ()
    "Any task with a todo keyword that is in a project subtree.
  Callers of this function already widen the buffer view."
    (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                (point))))
      (save-excursion
        (bh/find-project-task)
        (if (equal (point) task)
            nil
          t))))

  (defun bh/is-task-p ()
    "Any task with a todo keyword and no subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task (not has-subtask)))))

  (defun bh/is-subproject-p ()
    "Any task which is a subtask of another project"
    (let ((is-subproject)
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (while (and (not is-subproject) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq is-subproject t))))
      (and is-a-task is-subproject)))

  (defun bh/list-sublevels-for-projects-indented ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
    This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels 'indented)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defun bh/list-sublevels-for-projects ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
    This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels t)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defvar bh/hide-scheduled-and-waiting-next-tasks t)

  (defun bh/toggle-next-task-display ()
    (interactive)
    (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
    (when  (equal major-mode 'org-agenda-mode)
      (org-agenda-redo))
    (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

  (defun bh/skip-stuck-projects ()
    "Skip trees that are not stuck projects"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (bh/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  nil
                next-headline)) ; a stuck project, has subtasks but no next task
          nil))))

  (defun bh/skip-non-stuck-projects ()
    "Skip trees that are not stuck projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (bh/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  next-headline
                nil)) ; a stuck project, has subtasks but no next task
          next-headline))))

  (defun bh/skip-non-projects ()
    "Skip trees that are not projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (if (save-excursion (bh/skip-non-stuck-projects))
        (save-restriction
          (widen)
          (let ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
             ((bh/is-project-p)
              nil)
             ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
              nil)
             (t
              subtree-end))))
      (save-excursion (org-end-of-subtree t))))

  (defun bh/skip-project-trees-and-habits ()
    "Skip trees that are projects"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-projects-and-habits-and-single-tasks ()
    "Skip trees that are projects, tasks that are habits, single non-project tasks"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((org-is-habit-p)
          next-headline)
         ((and bh/hide-scheduled-and-waiting-next-tasks
               (member "WAITING" (org-get-tags-at)))
          next-headline)
         ((bh/is-project-p)
          next-headline)
         ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
          next-headline)
         (t
          nil)))))

  (defun bh/skip-project-tasks-maybe ()
    "Show tasks related to the current restriction.
  When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
  When not restricted, skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max))))
             (limit-to-project (marker-buffer org-agenda-restrict-begin)))
        (cond
         ((bh/is-project-p)
          next-headline)
         ((org-is-habit-p)
          subtree-end)
         ((and (not limit-to-project)
               (bh/is-project-subtree-p))
          subtree-end)
         ((and limit-to-project
               (bh/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-project-tasks ()
    "Show non-project tasks.
  Skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         ((bh/is-project-subtree-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-non-project-tasks ()
    "Show project tasks.
  Skip project and sub-project tasks, habits, and loose non-project tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((bh/is-project-p)
          next-headline)
         ((org-is-habit-p)
          subtree-end)
         ((and (bh/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         ((not (bh/is-project-subtree-p))
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-projects-and-habits ()
    "Skip trees that are projects and tasks that are habits"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-non-subprojects ()
    "Skip trees that are not projects"
    (let ((next-headline (save-excursion (outline-next-heading))))
      (if (bh/is-subproject-p)
          nil
        next-headline)))

  (defun bh/find-project-task ()
    "Move point to the parent (project) task if any"
    (save-restriction
      (widen)
      (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
        (while (org-up-heading-safe)
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (goto-char parent-task)
        parent-task)))

  (defun josh/skip-project-to-next-heading ()
    "Skip project tasks, but instead of going to the end of the
  subtree, just go to the next headline"
    (save-restriction
      (widen)
      (let* ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((bh/is-project-p)
          next-headline)
         (t
          nil)))))
#+END_SRC
** Find old closed entries
   My org files seem to now be accumulating a bunch of "DONE" entries
   that have been closed a long time ago. These functions and agenda
   help me find these old entries so I can archive them
#+BEGIN_SRC emacs-lisp
  (defun josh/org-closed-days-old ()
    "Get how many days ago this entry was closed."
    (josh/org-timestamp-days-old
     (org-element-property :closed (org-element-at-point))))

  (defun josh/org-timestamp-days-old (timestamp)
    (- (calendar-absolute-from-gregorian (calendar-current-date))
       (josh/org-timestamp-to-absolute-date timestamp)))

  (defun josh/org-timestamp-to-absolute-date (timestamp)
    "Get an integer date from timestamp. Used for date differences"
    (calendar-absolute-from-gregorian
     (if timestamp
         (mapcar (lambda (x) (plist-get (cadr timestamp) x)) '(:month-start :day-start :year-start))
       (calendar-current-date))))

  (defun josh/org-skip-old (age)
    "Skip all entries that were closed more than AGE days ago."
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (> (josh/org-closed-days-old) age)
          nil
        next-headline)))

  (org-add-agenda-custom-command
   '("o" "Old done tasks" todo "DONE|CANCELLED"
     ((org-agenda-skip-function (lambda () (josh/org-skip-old 14)))
      (org-agenda-overriding-header "Old DONE tasks: "))))
#+END_SRC
** Show effort and clocked time
   If you modify ~org-agenda-prefix-format~, you can get some extra
   details in your agenda view. Here's how I view effort and clocked time.
#+BEGIN_SRC emacs-lisp
  (require 'org-clock)
  (defun josh/minutes-to-hhmm (min)
      (let* ((h (floor (/ min 60)))
             (m (- min (* 60 h))))
        (format "%01d:%02d" h m)))

  (defun josh/org-show-effort-and-clocked (&optional noparens)
    "Show how much effort or clocked time there is.
    If no effort is set, show \"+\" clocked
    If there's no effort and no clocked time, show nothing
    If there's effort but no clocked time, show effort
    If there effort and clocked time, show \"-\" remaining effort
    If done, show clocked time.

    With optional parameter NOPARENS, don't include square brackets in output"
    (if (not (outline-on-heading-p t))
        ""
      (format (if noparens "%s" "[%s]")
              (let ((effort (org-get-at-eol 'effort-minutes 1))
                    (clocked (org-clock-sum-current-item (org-clock-get-sum-start))))
                (if (org-entry-is-todo-p)
                    (if effort
                        (if (> clocked 0)
                            (format "-% 3d" (- effort clocked))
                          (josh/minutes-to-hhmm effort))
                      (if (> clocked 0)
                          (format "+% 3d" clocked)
                        "    "))
                  (format "+% 3d" clocked))))))
#+END_SRC
** Helm Org Buffer
   This command makes it easy to quickly switch to an org-mode buffer.
#+BEGIN_SRC emacs-lisp
(require 'helm-types)
(require 'helm-buffers)
(defvar helm-org-buffers-list-cache nil)

(defclass helm-source-org-buffer (helm-source-sync helm-type-buffer)
  ((init :initform (lambda ()
                     (setq helm-org-buffers-list-cache
                           (mapcar (lambda (b)
                                     (with-current-buffer b (buffer-name)))
                                   (-filter (lambda (b)
                                              (with-current-buffer b
                                                (and (eq major-mode 'org-mode)
                                                     (buffer-name))))
                                            (buffer-list))))
                     (let ((result (cl-loop for b in helm-org-buffers-list-cache
                                            maximize (length b) into len-buf
                                            maximize (length (with-current-buffer b
                                                               (symbol-name major-mode)))
                                            into len-mode
                                            finally return (cons len-buf len-mode))))
                       (unless helm-buffer-max-length
                         (setq helm-buffer-max-length (car result)))
                       (unless helm-buffer-max-len-mode
                         (setq helm-buffer-max-len-mode (cdr result))))))
   (candidates :initform helm-org-buffers-list-cache)
   (matchplugin :initform nil)
   (match :initform 'helm-buffers-match-function)
   (persistent-action :initform 'helm-buffers-list-persistent-action)
   (keymap :initform helm-buffer-map)
   (volatile :initform t)
   (persistent-help
    :initform
    "Show this buffer / C-u \\[helm-execute-persistent-action]: Kill this buffer")))

(defvar helm-source-org-buffers-list (helm-make-source "Org-mode buffers" 'helm-source-org-buffer))

(defun helm-org-buffer ()
  (interactive)
  (helm :sources helm-source-org-buffers-list
        :buffer "*helm projectile*"
        :prompt "Switch to Org buffer:"))

;; (global-set-key (kbd "C-c o") 'helm-org-buffer)
;; This is also a good key just for swooping
(global-set-key (kbd "C-c O") 'helm-multi-swoop-org)
#+END_SRC
** Show how old an entry is
   I usually have "Added: [inactive timestamp]" added to most of my
   entries when captured with org-capture. Sometimes, I have
   unscheduled tasks around for a while, so these functions let me see
   how old they are. You could also use something like ~org-expiry~
   for something this.

   (Lately I've moved to using the "CREATED" property from ~org-expiry~)
#+BEGIN_SRC emacs-lisp
(defun josh/org-get-added-time ()
  "Get the time an entry was added"
  (or
   (cdr (assoc "CREATED" (org-entry-properties))) ;The "CREATED" property
   (save-excursion
     (org-back-to-heading t)
     (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
       (if (re-search-forward "Added: \\(\\[.*\\]\\)" subtree-end t)
	   (match-string 1))))))


(defun josh/org-format-age-from-added ()
  "Get age from the added date"
  (format "[%s|%s]"
          (let ((josh-added-time (josh/org-get-added-time)))
            (if josh-added-time
                (format "%3dd" (- (calendar-absolute-from-gregorian (calendar-current-date))
                                  (org-time-string-to-absolute josh-added-time)))
              "????"))
          (josh/org-show-effort-and-clocked t)))
#+END_SRC
** Show how long I've been waiting for something
   I have a section for "Waiting" tasks in my org agenda. I'd also
   like to see how long I've been waiting for them, to remind me if I
   should follow up.
#+BEGIN_SRC emacs-lisp
  (defun josh/org-get-waiting-time ()
    "Get the time we started waiting for a task"
    (save-excursion
      (org-back-to-heading t)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
        (if (re-search-forward "State \"WAITING\".*\\(\\[.*\\]\\)" subtree-end t)
            (match-string 1)))))

  (defun josh/org-format-waiting-time ()
    "Get age from the added date"
    (format "[%s]"
            (let ((josh-waiting-time (josh/org-get-waiting-time)))
              (if josh-waiting-time
                  (format "%3dd" (- (calendar-absolute-from-gregorian (calendar-current-date))
                                    (org-time-string-to-absolute josh-waiting-time)))
                "??"))))
#+END_SRC
** Show how long a task has been in the "Next" state
   How old is this task from when it was changed to a "next" task? Or
   when was it added? Take the more recent of the two.
#+BEGIN_SRC emacs-lisp
  (defun josh/org-get-next-time ()
    "Get the time we turned this task into a 'next' task"
    (save-excursion
      (org-back-to-heading t)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
        (if (re-search-forward "State \"NEXT\".*\\(\\[.*\\]\\)" subtree-end t)
            (match-string 1)))))

  (defun josh/absolute-time-or-0 (x)
    (if x (org-time-string-to-absolute x) 0))

  (defun josh/org-format-next-time ()
    "How long has an unscheduled 'next' task been waiting? Take the more recent of the added or changed-to-next date."
    (format "[%s]"
            (let* ((josh-added-time (josh/org-get-added-time))
                   (josh-next-time  (josh/org-get-next-time))
                   (josh-waiting-time (when (or josh-added-time josh-next-time)
                                        (max (josh/absolute-time-or-0 josh-added-time)
                                             (josh/absolute-time-or-0 josh-next-time)))))
              (if josh-waiting-time
                  (format "%3dd" (- (calendar-absolute-from-gregorian (calendar-current-date))
                                    josh-waiting-time))
                "??"))))

#+END_SRC

** Show when the last time I've made progress on a project
   I've got a list of stuck projects on my agenda. I'd like to know
   how long they've been stuck for. These functions show how many days
   it's been since I've clocked into a task in the project.
#+BEGIN_SRC emacs-lisp
  (defun josh/org-get-end-clock-times ()
    "Get the last times we clocked out of a task. Return as a list."
    (save-excursion
      (org-back-to-heading t)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (matches nil))
        (while (re-search-forward "CLOCK: .*--\\(\\[.*\\]\\)" subtree-end t)
          (setq matches (cons (match-string-no-properties 1) matches)))
        matches)))

  (defun josh/org-get-closed-times ()
    "Get the times we closed a task. Return as a list."
    (save-excursion
      (org-back-to-heading t)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (matches nil))
        (while (re-search-forward "CLOSED: \\(\\[.*\\]\\)" subtree-end t)
          (setq matches (cons (match-string-no-properties 1) matches)))
        matches)))

  (defun josh/org-get-max-time (mytimes)
    "Get the largest day of a list of times.."
    (let ((times (mapcar #'org-time-string-to-absolute mytimes)))
      (when times
        (apply 'max times))))

  (defun josh/org-format-max-clock-time ()
    "Format how many days ago we clocked out of a task. Used for projects."
    (format "[%s/%s]"
            (let ((josh-last-clock-time (josh/org-get-max-time (josh/org-get-end-clock-times))))
              (if josh-last-clock-time
                  (format "%3dd" (- (calendar-absolute-from-gregorian (calendar-current-date))
                                    josh-last-clock-time))
                "  ??"))
            (let ((josh-last-closed-time (josh/org-get-max-time (josh/org-get-closed-times))))
              (if josh-last-closed-time
                  (format "%3dd" (- (calendar-absolute-from-gregorian (calendar-current-date))
                                    josh-last-closed-time))
                "  ??"))))
#+END_SRC
** Use speed keys
   [[http://orgmode.org/manual/Speed-keys.html][Speed keys]] make it really quick to do things like sorting headlines.
#+BEGIN_SRC emacs-lisp
  (setq org-use-speed-commands t)
#+END_SRC
** Org expiry
   Use org-expiry to make a "created" property.
#+BEGIN_SRC emacs-lisp
(use-package org-expiry
  :init
  (setq org-expiry-created-property-name "CREATED")
  (setq org-expiry-inactive-timestamps t))

;; (use-package org
;;   :bind (:map org-mode-map
;; 	      ("M-N" . org-expiry-insert-created)))
#+END_SRC

  Actually I'm gonna shadow that with a function that will either
  convert the "Added: " field I usually have, or insert a timestamp
#+BEGIN_SRC emacs-lisp
(defun josh/org-convert-added-to-created-property ()
  "Convert the \"Added: [timestamp]\" I've used in the past to using
  the CREATED property set by org-expiry.

  Return t if we found and deleted it."
  (interactive)
  (save-excursion
    (org-back-to-heading t)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
      (when (re-search-forward "Added: \\(\\[.*\\]\\)" subtree-end t)
	(org-entry-put (point) org-expiry-created-property-name (match-string 1))
	(delete-region (progn (forward-line 0) (point)) ;Delete the line
		       (progn (forward-line 1) (point)))
	t))))

(defun josh/org-convert-added-or-add-created ()
  "Convert the \"Added:\" style lines I have in capture
  templates, otherwise add the CREATED property (or whichever
  property is defined by `org-expiry-created-property-name') to
  the heading using `org-expiry-insert-created'"
  (interactive)
  (unless (josh/org-convert-added-to-created-property)
    (org-expiry-insert-created)))

(use-package org
  :bind (:map org-mode-map
	      ("M-T" . josh/org-convert-added-to-created-property)
	      ("M-N" . josh/org-convert-added-or-add-created)))
#+END_SRC
*** Add ~CREATED~ property to captured headlines
    I'd like to know when I captured headlines. Here I'll add a hook
    to ~org-capture-mode~ that adds the ~CREATED~ property if we're
    capturing an org-mode heading.
#+BEGIN_SRC emacs-lisp
(defun jmm/org-capture-add-created-time ()
  "Add the CREATED property among when capturing a headline"
  (when (eq major-mode 'org-mode)
    (josh/org-convert-added-or-add-created)))

(add-hook 'org-capture-mode-hook 'jmm/org-capture-add-created-time)
#+END_SRC
** Marking headings with a tag
   Sometimes I want to perform an action in bulk on a bunch of
   entries. For example, I might want to refile a bunch of headings or
   add a lot of tags for similar headings. This can be pretty tedious
   to do manually, especially since there's a ~org-agenda-bulk-action~
   command (usually bound to ~B~ in ~org-agenda~) that helps us out.

   In order to get a bunch of "marked" entries in an agenda, though,
   we want a quick way to add something like a "MARKED" tag. The code
   below does that.
#+BEGIN_SRC emacs-lisp
(use-package org
  :bind (:map org-mode-map
	      ("M-M" . josh/org-toggle-marked-tag))
  :init
  (add-to-list 'org-tags-exclude-from-inheritance "MARKED")
  (add-to-list 'org-tag-faces '("MARKED" :foreground "MediumPurple1" :weight bold))
  :config
  (require 'ox))

(defun josh/org-toggle-marked-tag ()
  "Add a \"MARKED\" tag to a headline"
  (interactive)
  (org-toggle-tag "MARKED"))
#+END_SRC

** Org-ref
   I'm starting to learn to use [[https://github.com/jkitchin/org-ref][org-ref]].
#+BEGIN_SRC emacs-lisp
(use-package org-ref
  :defer t
  :init
  (setq org-ref-bibtex-hydra-key-binding (kbd "C-c C-j"))
  (setq reftex-default-bibliography '("~/org-ref/references.bib"))
  ;; see org-ref for use of these variables
  (setq org-ref-bibliography-notes "~/org-ref/notes.org"
	org-ref-default-bibliography (file-expand-wildcards "~/org-ref/*.bib")
	org-ref-pdf-directory "~/org-ref/bibtex-pdfs/")
  (setq bibtex-completion-bibliography org-ref-default-bibliography
	bibtex-completion-library-path '("~/org-ref/bibtex-pdfs" "~/org-ref/zotfile")
	bibtex-completion-pdf-field "file"
	bibtex-completion-additional-search-fields '(keywords journal)
	bibtex-completion-notes-path "~/org-ref/helm-bibtex-notes")
  (setq bibtex-completion-display-formats
	'((t . "${author:36} ${title:*} ${year:4} ${journal:7} ${=has-pdf=:1}${=has-note=:1} ${keywords:12}")))
  (bind-key "C-c z" 'helm-bibtex)
  ;; Use helm-bibtex-notes file for notes
  (setq org-ref-notes-function
	(lambda (thekey)
	  (let ((bibtex-completion-bibliography (org-ref-find-bibliography)))
	    (bibtex-completion-edit-notes
	     (list (car (org-ref-get-bibtex-key-and-file thekey))))))))

(use-package org-ref-bibtex
  :defer t
  :init
  (setq org-ref-bibtex-hydra-key-binding (kbd "C-c C-j")))
#+END_SRC
*** Associate most recent PDF with bibtex entry

Here's a function for associating the most recently downloaded PDF with a bibtex entry
#+BEGIN_SRC emacs-lisp
(defun josh/org-ref-bibtex-assoc-most-recent-pdf-with-entry (&optional prefix)
  "Associate the most recent PDF file in ~/Downloads with the current bibtex entry.
This is basically a copy of `org-ref-bibtex-assoc-pdf-with-entry'. Optional PREFIX argument
toggles between `rename-file' and `copy-file'"
  (interactive "P")
  (save-excursion
    (bibtex-beginning-of-entry)
    (let* ((file (josh/latest-file "~/Downloads" ".*\.[pP][dD][fF]$"))
	   (bibtex-expand-strings t)
           (entry (bibtex-parse-entry t))
           (key (reftex-get-bib-field "=key=" entry))
           (pdf (concat org-ref-pdf-directory (concat key ".pdf")))
	   (file-move-func (org-ref-bibtex-get-file-move-func prefix)))
      (if (file-exists-p pdf)
	  (message (format "A file named %s already exists" pdf))
	(progn
	  (funcall file-move-func file pdf)
	  (message (format "Created file %s from %s" pdf file)))))))
#+END_SRC
*** Find zotero files

I use [[http://zotfile.com/][Zotfile]] to move PDFs from a bunch of disparate folders in Zotero
to one shared folder. Zotfile moves PDFs and stores them as links in
entries. When [[https://github.com/retorquere/zotero-better-bibtex][Better BibTeX]] exports ~.bib~ files, these files show up
as being a ~/zotfile/~ folder. Helm-bibtex interprets this as an
absolute path (which it kind of should), and isn't able to find my PDF
files. This tries to fix that.

I assume that files are stored in a "zotfile" directory.

Also, this advice removes HTML snapshots, since I generally don't want
to look at them anyway.

#+BEGIN_SRC emacs-lisp
(defun jmm/helm-bibtex-replace-zotfile-with-relative-path (orig-fun &rest args)
  "Replace \"/zotfile/\" with \"zotfile\". Also remove any snapshots."
  (let ((res (apply orig-fun args)))
    (if (stringp res)
	(replace-regexp-in-string "\\(;[a-zA-Z0-9 ]*?Snapshot:.*?text/html\\|/zotfile/\\)" "" res)
      res)))

(advice-add 'bibtex-completion-get-value :around #'jmm/helm-bibtex-replace-zotfile-with-relative-path)
#+END_SRC

* Notmuch
  Notmuch is an email interface I started using to replace Gnus. It's
  got a couple of main selling points. First is that things are
  organized into tags instead of folders, so messages can have more
  than one category. The second is that it uses Xapian for searching,
  making full text search really, really fast.

#+BEGIN_SRC emacs-lisp
(use-package notmuch
    :bind (("C-c n" . notmuch-hello)
	   ("C-c N" . notmuch-search)
	   :map notmuch-common-keymap
	   ("g" . notmuch-refresh-this-buffer)
	   :map notmuch-show-mode-map
	   ("b" . josh/notmuch-send-html-to-browser)
	   ("B" . notmuch-show-resend-message)
	   ("o" . jmm/notmuch-show-open-in-gmail)
	   ))
(use-package org-notmuch)
#+END_SRC

  Here's some stuff related to sending email (although not directly related to notmuch).
#+BEGIN_SRC emacs-lisp
(require 'smtpmail)
(setq message-send-mail-function 'message-smtpmail-send-it)

(require 'starttls)
;; use org structures and tables in message mode
;; Thanks, pragmaticemacs!
(add-hook 'message-mode-hook 'turn-on-orgtbl)
(add-hook 'message-mode-hook 'turn-on-orgstruct++)
#+END_SRC

When using ~shr~ to render HTML, sometimes the colors come out weird. This makes it more readable.
#+BEGIN_SRC emacs-lisp
(setq shr-color-visible-luminance-min 70)
#+END_SRC

Function to send HTML part to the browser
#+BEGIN_SRC emacs-lisp
(defun josh/notmuch-send-html-to-browser ()
  "Search for \"text/html\" in the buffer and open it with `notmuch-show-view-part'"
  (interactive)
  (save-excursion
    (when (search-forward "text/html" nil t)
      (notmuch-show-view-part))))
#+END_SRC

** Open an email with gmail

Gmail does some nice stuff occasionally. One of the things I like is
that it caches loading of external images, so senders can't track when
you've opened some mail. Of course, /Gmail/ can still track you, so
it's up to you who you want tracking you (or, you can decide not to
see images in emails).

This function opens an email in Gmail. For most HTML files I should
use ~josh/notmuch-send-html-to-browser~ though.

#+BEGIN_SRC emacs-lisp
(defvar jmm/gmail-to-user-id-alist '(("tag0" . 0)
				     ("tag1" . 1))
  "This should be an alist of tags and their associated user number in gmail.
For example, if mail to your school account is user 0,
  specify (\"school\" . 0) as an item in the alist")

(defun jmm/notmuch-show-open-in-gmail ()
  "Open the displayed message in gmail"
  (interactive)
  (let ((msgid (notmuch-show-get-message-id t))
	(userid (or (cdr (assoc (car (-intersection (mapcar 'car jmm/gmail-to-user-id-alist)
						(notmuch-show-get-tags)))
				jmm/gmail-to-user-id-alist))
		    0)))
    (browse-url (concat (format "https://mail.google.com/mail/u/%d/?ibxr=0#search/" userid)
			(url-hexify-string (format "rfc822msgid:%s" msgid))))))
#+END_SRC

* Elfeed
  [[https://github.com/skeeto/elfeed][elfeed]] is an RSS reader with a similar interface to [[https://notmuchmail.org/][notmuch]]. I used
  to use Gnus to read RSS, but elfeed is nice in that it doesn't block
  emacs when loading feeds. Also, after learning how to use notmuch,
  the elfeed interface started making a lot of sense.

  Pro tip: Use bookmarks (especially Helm bookmarks) to save elfeed
  searches. This gives you similar functionality to notmuch saved searches.

#+BEGIN_SRC emacs-lisp
(defun elfeed-toggle-images ()
  "Toggle the display of images"
  (interactive)
  (setq shr-inhibit-images (not shr-inhibit-images))
  (elfeed-show-refresh))

(defun elfeed-temporarily-inhibit-images ()
    "Inhibit the display of images, but don't set `shr-inhibit-images'"
    (interactive)
    (let ((shr-inhibit-images t))
      (elfeed-show-refresh)))

(defun josh/save-elfeed ()
    "Just call `elfeed-db-save'. We just need an interactive function to bind to a key"
    (interactive)
    (if (elfeed-db-save)
	(message "Saved")))

(use-package elfeed
	       :bind (("C-x w" . elfeed))
	       :config
	       (define-key elfeed-search-mode-map (kbd "C-x C-s") 'josh/save-elfeed)
	       (define-key elfeed-show-mode-map "I" 'elfeed-toggle-images)
	       (define-key elfeed-show-mode-map "i" 'elfeed-temporarily-inhibit-images))
#+END_SRC

* Sawfish
  Automatically load .jl files as sawfish (not Julia)
#+begin_src emacs-lisp
  (when (require 'sawfish nil 'noerror)
    (setq auto-mode-alist (cons '("\\.sawfishrc$"  . sawfish-mode) auto-mode-alist)
          auto-mode-alist (cons '("\\.jl$"         . sawfish-mode) auto-mode-alist)
          auto-mode-alist (cons '("\\.sawfish/rc$" . sawfish-mode) auto-mode-alist)))

#+end_src
* Helm
#+begin_src emacs-lisp
  (require 'helm-config)
  (global-set-key (kbd "C-c h") 'helm-mini)
  (use-package helm-mode
    :init
    (setq helm-ff-newfile-prompt-p nil)
    :config
    (progn (mapc (lambda (x) (add-to-list 'helm-completing-read-handlers-alist
                                 (list x)))
        (list 'dired-do-rename
              'dired-do-copy
              'dired-do-delete
              'dired-do-symlink
              'dired-create-directory
              'find-file))
           (helm-mode 1)))
  (global-set-key (kbd "C-x b") 'helm-buffers-list)
  ;; (global-set-key (kbd "C-x C-f") 'helm-find-files)
  (global-set-key (kbd "C-x f") 'helm-for-files)
  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (global-set-key (kbd "M-s o") 'helm-occur)
  (global-set-key (kbd "M-g s") 'helm-do-grep)
  (global-set-key (kbd "M-g b") 'helm-resume)
  (global-set-key (kbd "C-c SPC") 'helm-all-mark-rings)
  (global-set-key (kbd "C-c b") 'helm-bookmarks)
#+end_src
** Other Helm actions I find useful
   I like being able to open an xterm or quickly jump to dired with helm.
#+begin_src emacs-lisp
  (defun helm-ff-dired ()
    "Run open file externally command action from `helm-source-find-files'."
    (interactive)
    (when helm-alive-p
      (helm-quit-and-execute-action 'helm-point-file-in-dired)))

  (define-key helm-map (kbd "C-c j") 'helm-ff-dired)

  (defun helm-xterm-directory (file)
    "Open an xterm starting in FILE's directory."
    (start-xterm (if (file-directory-p file)
                     file
                   (file-name-directory file))))

  (defun helm-ff-xterm-directory ()
    "Open xterm on file's directory"
    (interactive)
    (when helm-alive-p
      (helm-quit-and-execute-action 'helm-xterm-directory)))

  (define-key helm-map (kbd "C-c J") 'helm-ff-xterm-directory)
#+end_src
** Helm locate
   I like spaces to narrow locate results, instead of having to type
   in ".*" to search for separate strings.
#+BEGIN_SRC emacs-lisp
  (setq helm-locate-command "locate %s -e -A --regex %s")
#+END_SRC
** Helm MPV
   I like being able to play a bunch of files with mpv, and sometimes
   I like to scrobble them to last.fm. I have a script called
   "scrobblempv2" in my path that enables scrobbling of tracks.
#+BEGIN_SRC emacs-lisp
  (defun helm-mpv (_ignore)
      "Play some files with mpv. Given a prefix, run scrobblempv2, a
    script made to enable plugins for mpv scrobbling.
  Given two prefixes, append file to the current playlist."
      (let* ((files (helm-marked-candidates :with-wildcard t))
             (len (length files))
             (mpv (cond
                   ((equal helm-current-prefix-arg '(16)) "scrobblempv2")
                   ((equal helm-current-prefix-arg '(4)) "mpvappendscrobble")
                   (t "mpv"))))
        (with-helm-display-marked-candidates
          helm-marked-buffer-name
          (mapcar #'(lambda (f)
                      (if (file-directory-p f)
                          (concat (helm-basename f) "/")
                        (helm-basename f)))
                  files)
          (apply 'start-process "scrobblempv2" " mpv process" mpv files))))

  (defun helm-ff-mpv ()
    "Open a file with mpv."
    (interactive)
    (when helm-alive-p
      (helm-quit-and-execute-action 'helm-mpv)))

  (define-key helm-map (kbd "C-c C-m") 'helm-ff-mpv)
#+END_SRC
** helm-swoop
Set up hotkeys and stuff for helm-swoop
#+BEGIN_SRC emacs-lisp
  (use-package helm-swoop
               :bind (("M-i" . helm-swoop)
                      ("M-I" . helm-swoop-back-to-last-point)
                      ("C-c M-i" . helm-multi-swoop)
		      ("C-c d" . helm-multi-swoop-dired)
                      ("C-x M-i" . helm-multi-swoop-all))
               :config (progn
                         ;; When doing isearch, hand the word over to helm-swoop
                         (define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)
                         ;; From helm-swoop to helm-multi-swoop-all
                         (define-key helm-swoop-map (kbd "M-i") 'helm-multi-swoop-all-from-helm-swoop)))
#+END_SRC

Make an easy way to find files in open dired buffers

#+BEGIN_SRC emacs-lisp
(require 'helm-swoop)
(defun helm-multi-swoop-dired (&optional $query)
  "Applies all dired-mode buffers to helm-multi-swoop"
  (interactive)
  (helm-multi-swoop-by-mode 'dired-mode $query))
#+END_SRC

** helm-descbinds
   Describe bindings.
#+BEGIN_SRC emacs-lisp
  (use-package helm-descbinds
    :defer t
    :bind (("C-h b" . helm-descbinds)
           ("C-h w" . helm-descbinds)))
#+END_SRC
** helm-org-rifle
   Helm-org-rifle is a really nice way to swoop through org-mode
#+BEGIN_SRC emacs-lisp
  (use-package helm-org-rifle
                 :bind (("C-c R" . helm-org-rifle-org-directory)
                        ("C-c r" . helm-org-rifle)))
#+END_SRC
* Magit
  [[https://magit.vc/][Magit]] is probably the best [[http://stackoverflow.com/a/6976506][git porcelain]] out there. I've been using it for a while.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind (("C-x g" . magit-status)
	   ("C-x M-g" . magit-dispatch-popup)))
#+END_SRC

* Processing
  Define the location of processing.
  Will be different for you.
#+begin_src emacs-lisp
  (setq processing-location "~/Downloads/processing-2.1.2/processing-java")
#+end_src
* Maxima
  Here's a setup for Maxima, from EmacsWiki.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "/usr/share/emacs/site-lisp/maxima/")
  (autoload 'maxima-mode "maxima" "Maxima mode" t)
  (autoload 'imaxima "imaxima" "Frontend for maxima with Image support" t)
  (autoload 'maxima "maxima" "Maxima interaction" t)
  (autoload 'imath-mode "imath" "Imath mode for math formula input" t)
  (setq imaxima-use-maxima-mode-flag t)
  (add-to-list 'auto-mode-alist '("\\.ma[cx]" . maxima-mode))
#+END_SRC
* Useful, but unnecessary, functions
** Word counting
#+begin_src emacs-lisp
(defun word-count nil "Count words in buffer" (interactive)
  (shell-command-on-region (point-min) (point-max) "wc -w"))
#+end_src

** Aliases
#+begin_src emacs-lisp
(defun afm ()				;Shorter than typing auto-fill-mode
  (interactive)
  (auto-fill-mode))

(defun ttl ()
  (interactive)
  (toggle-truncate-lines))
#+end_src

** Killing buffers
#+begin_src emacs-lisp
;; Display buffers and kill them
(defun kill-some-buffers2 (&optional list)
  "Kill some buffers.  Asks the user whether to kill each one of them.
Non-interactively, if optional argument LIST is non-nil, it
specifies the list of buffers to kill, asking for approval for each one."
  (interactive)
  (if (null list)
      (setq list (buffer-list)))
  (while list
    (let* ((buffer (car list))
	   (name (buffer-name buffer)))
      (and name				; Can be nil for an indirect buffer
					; if we killed the base buffer.
	   (not (string-equal name ""))
	   (/= (aref name 0) ?\s)
	   (switch-to-buffer name)
	   (kill-buffer-ask buffer)))
    (setq list (cdr list))))
(global-set-key (kbd "C-x M-k") 'kill-some-buffers2)
#+end_src


#+begin_src emacs-lisp
(add-hook 'artist-mode-hook
 (lambda ()
   (define-key artist-mode-map [remap artist-next-line] 'picture-move-down)
   ))
#+end_src
** Viewing and killing buffers
#+begin_src emacs-lisp
(defun view-and-kill-some-buffers (&optional list)
  "View and kill buffers"
  (interactive)
  (if (null list)
      (setq list (buffer-list)))
  (while list
    (let* ((buffer (car list))
	   (name (buffer-name buffer)))
      (switch-to-buffer buffer)
      (and name				; Can be nil for an indirect buffer
					; if we killed the base buffer.
	   (not (string-equal name ""))
	   (/= (aref name 0) ?\s)
	   (kill-buffer-ask buffer)))
    (setq list (cdr list))))
#+end_src

** What I do when editing some text files
#+begin_src emacs-lisp
(defun txt-stuff ()
  "A lot of stuff you do when writing in text files"
  (interactive)
  (auto-fill-mode 1)
  (use-hard-newlines 1 'always))
#+end_src

#+BEGIN_SRC emacs-lisp
  (defun journal-stuff ()
    "A bunch of commands used when writing a daily journal."
    (interactive)
    (insert (replace-regexp-in-string "\.txt" "" (buffer-name))
            "\n"
            "(Written ")
    (org-time-stamp '(16))
    (insert ")\n\n")
    (text-scale-set -2)
    (txt-stuff))
#+END_SRC

** Starting an Xterm in current directory
#+begin_src emacs-lisp
  (defun start-xterm (&optional dirpath)
      "Start a new xterm in the current directory. SSH if necessary"
      (interactive)
      (let ((path (if dirpath dirpath (expand-file-name (or (and (eq major-mode 'dired-mode)
                                                                 (dired-current-directory))
                                                            default-directory)))))
        "Return the local portion of a path.

    If PATH is local, return it unaltered.
    If PATH is remote, return the remote diretory portion of the path."
        (if (tramp-tramp-file-p path)
            (let ((loc (elt (tramp-dissect-file-name path) 3))
                  (host (elt (tramp-dissect-file-name path) 2)))
              (start-process "xterm" " xterm-processes" "xterm" "-T" (format "%s: %s" host loc) "-e" (format "ssh -t %s 'cd %s; bash'" host loc)))
          (start-process "xterm" " xterm-processes" "xterm" "-T" path "-e" (format "cd \"%s\"; zsh" path)))))
  (global-set-key (kbd "<f9> x") 'start-xterm)
#+end_src

** Copy the path
#+begin_src emacs-lisp
(defun file-name-copy-path ()
  "Copy the path the of the of the current buffer"
  (interactive)
  (kill-new (message "%s" (buffer-file-name))))
(global-set-key (kbd "<f9> c") 'file-name-copy-path)
#+end_src

** Word wrapping
#+begin_src emacs-lisp
 (defun ww ()
  "Set word wrapping"
  (interactive)
  (setq word-wrap (if word-wrap nil t)))
#+end_src
** Half Term
#+begin_src emacs-lisp
(defun run-half-term ()
   "Run a shell in half a window."
   (interactive)
   (split-window-vertically nil)
   (other-window 1)
   (term "/bin/bash")
   (rename-uniquely)
   (other-window -1))

(global-set-key (kbd "C-x 4 t") 'run-half-term)
#+end_src
** Search Gregg Shorthand Dictionary
#+begin_src emacs-lisp
  (defun gsd ()
    (interactive)
      (find-file-read-only "~/Downloads/gregg/gsd.txt")
      (helm-occur)
      (start-process "evince-gsd" " gsd-processes" "evince"
                     (concat "--page-label="
                             (number-to-string (- (string-to-number
                                                   (substring (what-page) 5 8))
                                                  12)))
                     "/home/jm3/Downloads/gregg/gsd.pdf"))

  (when (and (require 'pdf-tools nil 'noerror)
	     (require 'pdf-isearch nil 'noerror))
    (defun gsd ()
      (interactive)
      (find-file-read-only "~/Downloads/gregg/gsd.txt")
      (helm-occur)
      (setq gsd-word (word-at-point))
      (setq gsd-page (string-to-number (substring (what-page) 5 8)))
      (find-file-read-only "~/Downloads/gregg/gsd.pdf")
      (pdf-view-goto-page gsd-page)
      (setq gsd-matches (pdf-isearch-search-page gsd-word))
      (pdf-isearch-hl-matches (car gsd-matches) gsd-matches t)))

  (global-set-key (kbd "<f9> g") 'gsd)
#+end_src
** Window Dedication
#+begin_src emacs-lisp
;; http://dfan.org/blog/2009/02/19/emacs-dedicated-windows/
(defun toggle-current-window-dedication ()
 (interactive)
 (let* ((window    (selected-window))
        (dedicated (window-dedicated-p window)))
   (set-window-dedicated-p window (not dedicated))
   (message "Window %sdedicated to %s"
            (if dedicated "no longer " "")
            (buffer-name))))

(global-set-key [pause] 'toggle-current-window-dedication)
#+end_src
** Chinese Cangjie 5 input
   I created a quail package for Cangjie version 5 using libcangjie's
   dictionary.  The main advantage to using it over the built-in
   =chinese-cns-tsangchi= or =chinese-b5-tsangchi= is that this method
   allows you to type simplified Chinese characters.

#+begin_src emacs-lisp
  (register-input-method
   "Cangjie5" "Chinese-BIG5" 'quail-use-package
   "C5" "Cangjie version 5"
   "cangjie5.el")
#+end_src

   A quick key to help look up Cangjie codes for characters I don't know.
#+begin_src emacs-lisp
  (global-set-key (kbd "<f9> s") 'quail-show-key)
#+end_src
** Chinese word definition library
   Require the library that gets Chinese word definitions. I use this
   to make ~org-drill~ flashcards fairly quickly with a capture template.
#+BEGIN_SRC emacs-lisp
  (require 'josh-chinese)
#+END_SRC
** Auto fill line
   Sometimes I want to wrap a line, but pressing =M-q= will treat
   everything as one huge paragraph, messing up the structure.
   This simple function acts like we temporarily turn on
   auto-fill-mode, wrap the line, and then turn it off.

#+begin_src emacs-lisp
  (defun josh/fill-line ()
    "Wrap the line"
    (interactive)
    (save-excursion
      (end-of-line)
      (funcall normal-auto-fill-function)))

  (global-set-key (kbd "M-Q") 'josh/fill-line)
#+end_src
** Switch to scratch buffer
   A quick hotkey for switching to the scratch buffer.
#+begin_src emacs-lisp
  (defun switch-to-scratch ()
    "Switch to scratch"
    (interactive)
    (switch-to-buffer "*scratch*"))
  
  (global-set-key (kbd "C-h C-s") 'switch-to-scratch)
#+end_src
** Comment a copy
   Sometimes when I'm debugging something, I'll want to make
   modifications to the line I'm working on, but keep a copy of it
   right above. This function allows me to automate that.
#+BEGIN_SRC emacs-lisp
  (defun jmm/comment-a-copy ()
      "Add a commented-out line above the current one.

  If the region is active, add a commented-out version of the region above the region"
      (interactive)
      (save-excursion
          (let* ((beg (if (use-region-p) (min (mark) (point)) (line-beginning-position)))
                 (end (if (use-region-p) (max (mark) (point)) (line-end-position)))
                 (selection (buffer-substring beg end)))
            (goto-char beg)
            (push-mark)
            (insert selection)
            (comment-region (mark) (point)))))

  (global-set-key (kbd "C-c C") 'jmm/comment-a-copy)
#+END_SRC
** Find the latest file in a directory
   Decent function for finding the most recent file in a
   directory. For example, if I wanted to get the most recently
   downloaded PDF in "~/Downloads"
#+BEGIN_SRC emacs-lisp
(defun josh/latest-file (path glob)
  "Get the latest file in PATH matching the regex GLOB"
  (caar
   (sort (mapcar (lambda (file)
		  (cons (car file) (float-time (file-attribute-modification-time file))))
		(directory-files-and-attributes path 'full glob 'nosort))
	(lambda (file1 file2) (> (cdr file1) (cdr file2))))))
#+END_SRC
** Unfill Paragraph
   From https://www.emacswiki.org/emacs/UnfillParagraph
#+BEGIN_SRC emacs-lisp
;;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph
(defun unfill-paragraph (&optional region)
  "Takes a multi-line paragraph and makes it into a single line of text."
  (interactive (progn (barf-if-buffer-read-only) '(t)))
  (let ((fill-column (point-max))
        ;; This would override `fill-column' if it's an integer.
        (emacs-lisp-docstring-fill-column t))
    ;; Unhyphenate --Josh
    (when region
      (save-excursion
	(while (re-search-forward "-\n" (region-end) t)
	  (replace-match ""))))
    (fill-paragraph nil region)))
(define-key global-map (kbd "C-M-q") 'unfill-paragraph)
#+END_SRC

* Emacs Rocks
  Things I got from watching "Emacs Rocks"
** Multiple Cursors
#+begin_src emacs-lisp
  (require 'multiple-cursors)
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-M-<") 'mc/mark-all-like-this-dwim)
  (global-unset-key (kbd "C-<down-mouse-1>"))
  (global-set-key (kbd "C-<mouse-1>") 'mc/add-cursor-on-click)
#+end_src
*** Inserting letters for each cursor
    Basically exactly like ~mc/insert-numbers~ but for letters.
#+BEGIN_SRC emacs-lisp
  (require 'multiple-cursors-core)

  (defun mc/insert-letters (arg)
    "Insert increasing letters for each cursor, starting at 0 or ARG."
    (interactive "cStart at character: ")
    (setq mc--insert-letters-letter (or arg ?a))
    (mc/for-each-cursor-ordered
     (mc/execute-command-for-fake-cursor 'mc--insert-letter-and-increase cursor)))

  (defvar mc--insert-letters-letter 0)

  (defun mc--insert-letter-and-increase ()
    (interactive)
    (insert (char-to-string mc--insert-letters-letter))
    (setq mc--insert-letters-letter (1+ mc--insert-letters-letter)))
#+END_SRC
*** Keymap for multiple-cursor commands
    Taken from http://endlessparentheses.com/multiple-cursors-keybinds.html
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'endless/mc-map)
  ;; C-x m is usually `compose-mail'. Bind it to something
  ;; else if you use this command.
  (define-key ctl-x-map "m" 'endless/mc-map)

  ;;; Really really nice!
  (define-key endless/mc-map "i" #'mc/insert-numbers)
  (define-key endless/mc-map "h" #'mc-hide-unmatched-lines-mode)
  (define-key endless/mc-map "a" #'mc/mark-all-like-this)

  ;;; Occasionally useful
  (define-key endless/mc-map "d"
    #'mc/mark-all-symbols-like-this-in-defun)
  (define-key endless/mc-map "r" #'mc/reverse-regions)
  (define-key endless/mc-map "s" #'mc/sort-regions)
  (define-key endless/mc-map "l" #'mc/edit-lines)
  (define-key endless/mc-map "\C-a"
    #'mc/edit-beginnings-of-lines)
  (define-key endless/mc-map "\C-e"
    #'mc/edit-ends-of-lines)
#+END_SRC
*** Disable primary selection for multiple cursors
    Setting ~x-select-enable-primary~ allows me to paste into emacs from an xterm selection using "~C-y~" (yank)
    A problem, though, is that it breaks ~kill-ring-save~ yanking with multiple-cursors
    You can still paste from the X primary selection using middle click

    But since I want to copy from dired using ~w~ and paste into
    xterm, I'll only disable ~x-select-enable-primary~ while using multiple cursors.

#+BEGIN_SRC emacs-lisp
(add-hook 'multiple-cursors-mode-enabled-hook (lambda () (setq select-enable-primary nil)))
(add-hook 'multiple-cursors-mode-disabled-hook (lambda () (setq select-enable-primary t)))
#+END_SRC

** Expand Region
#+begin_src emacs-lisp
  (use-package expand-region
               :bind ("C-=" . er/expand-region))
#+end_src
** Ace Jump Mode
#+begin_src emacs-lisp
  (use-package ace-jump-mode
               :ensure t
               :bind (("C-0" . ace-jump-mode)
                      ("C-x C-SPC" . ace-jump-mode-pop-mark))
               :init (progn
                       ;; To set to only use lowercase
                       (setq ace-jump-mode-case-fold t)
                       (setq ace-jump-mode-scope 'frame)))
  ;; (setq ace-jump-mode-move-keys (loop for i from ?a to ?z collect i))
#+end_src
*** Ace Jump Zap
#+BEGIN_SRC emacs-lisp
(use-package ace-jump-zap
  :ensure t :defer t
  :bind
  (("M-z" . ace-jump-zap-up-to-char-dwim)
   ("M-Z" . ace-jump-zap-to-char-dwim)))
#+END_SRC
*** ace-mc
    My own package! Check it out [[https://github.com/mm--/ace-mc][here]].
    It basically makes adding multiple cursors easier.
#+BEGIN_SRC emacs-lisp
(use-package ace-mc
  :ensure t
  :bind
  (("C-)" . ace-mc-add-multiple-cursors)
   ("C-M-)" . ace-mc-add-single-cursor)))
#+END_SRC
** Avy
   [[https://github.com/abo-abo/avy/][Avy]] is like ace-jump-mode, but apparently better updated and with
   some newer features. I haven't really gotten around to using it
   instead of ace-jump-mode yet, but I'm trying to see what it has to offer.
#+BEGIN_SRC emacs-lisp
  (use-package avy
    :bind (("C-'" . avy-goto-char-timer)
	   ("C-:" . avy-goto-char-2)
	   ("M-g w" . avy-goto-word-1)
	   :map isearch-mode-map
	   ("C-'" . avy-isearch))
    :init (setq avy-keys (number-sequence ?a ?z)
		avy-style 'at-full
		avy-background t
		avy-timeout-seconds 0.3))
#+END_SRC

* Other modes
** Enriched Mode
#+begin_src emacs-lisp
(add-hook 'enriched-mode-hook
 (lambda ()
   (define-key enriched-mode-map [remap newline-and-indent] nil)
   (define-key enriched-mode-map "\C-m" nil)
   (define-key enriched-mode-map [remap move-beginning-of-line] nil)
   ))
#+end_src
** Java Mode
#+begin_src emacs-lisp
(add-hook 'java-mode-hook
	  (lambda ()
	    (c-set-style "java")))
#+end_src
** Ledger
#+begin_src emacs-lisp
  (use-package ledger
               :ensure ledger-mode)
#+end_src
** Swank-js
#+begin_src emacs-lisp
  (add-hook 'css-mode-hook
             (lambda ()
               (define-key css-mode-map "\M-\C-x" 'slime-js-refresh-css)
               (define-key css-mode-map "\C-c\C-r" 'slime-js-embed-css)))
#+end_src
#+begin_src emacs-lisp
  (global-set-key [f5] 'slime-js-reload)
  ;; (add-hook 'js-mode-hook
  ;;           (lambda ()
  ;;             (js2-minor-mode 1)
  ;;             (auto-complete-mode 1)))
#+end_src
** js2-mode
   Use js2-mode by default
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+end_src
   I prefer less indentation.
#+begin_src emacs-lisp
  (setq-default js2-basic-offset 4)
#+end_src
   I'm checking style/semicolons/whatever with eslint, so I don't want js2-mode to tell me about it.
#+BEGIN_SRC emacs-lisp
(setq-default js2-strict-missing-semi-warning nil)
(setq-default js2-mode-show-parse-errors nil)
(setq-default js2-mode-show-strict-warnings nil)
#+END_SRC
** Tern.js for Javascript
   [[http://ternjs.net/][Tern]] seems to be a pretty cool tool much like ctags.

   It's able to find the definitions of functions and variables in
   your javascript files as well as tell you the type of variable.

#+begin_src emacs-lisp
  (add-to-list 'load-path "~/Downloads/tern/emacs")
  (use-package tern
               :config (add-hook 'js2-mode-hook (lambda () (tern-mode t))))
#+end_src
** Projectile
   Projectile is a neat library that makes it easy to deal with
   various tasks in a project. For example, it makes it easy to switch
   to project-related buffers or to search all buffers.

   This configuration also turns on ~helm-projectile~ bindings by default.
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :diminish projectile-mode
    :config
    (progn
      (projectile-global-mode)
      (setq projectile-svn-command "find . -type f -not -iwholename '*.svn/*' -print0")
      (setq projectile-completion-system 'helm-comp-read)))

  (use-package helm-projectile
    :ensure t
    :config
    (helm-projectile-toggle 1))
#+end_src
*** Switching between web stuff
    Easily switch between .html, .js, and .css
#+BEGIN_SRC emacs-lisp
  (add-to-list 'projectile-other-file-alist '("html" "css" "js"))
  (add-to-list 'projectile-other-file-alist '("js" "css" "html"))
#+END_SRC

** Yasnippet
   So I can have recursive snippets.
#+begin_src emacs-lisp
  (use-package yasnippet
               :ensure t
               :init (progn (setq yas-triggers-in-field t)))
#+end_src
** Switch window
   A visual way to switch windows. Kind of like ace-jump, but for windows.
#+BEGIN_SRC emacs-lisp
  (use-package switch-window
    :disabled t
    :bind ("C-x o" . switch-window))
#+END_SRC
** Smartparens
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
               :ensure t
               :config
               :disabled t
               (progn (require 'smartparens-config)
                      (smartparens-global-mode t)

                      (show-smartparens-global-mode t)

                      (define-key sp-keymap (kbd "C-M-f") 'sp-forward-sexp)
                      (define-key sp-keymap (kbd "C-M-b") 'sp-backward-sexp)

                      (define-key sp-keymap (kbd "C-M-d") 'sp-down-sexp)
                      (define-key sp-keymap (kbd "C-M-a") 'sp-backward-down-sexp)
                      (define-key sp-keymap (kbd "C-S-a") 'sp-beginning-of-sexp)
                      (define-key sp-keymap (kbd "C-S-d") 'sp-end-of-sexp)

                      (define-key sp-keymap (kbd "C-M-e") 'sp-up-sexp)
                      (define-key emacs-lisp-mode-map (kbd ")") 'sp-up-sexp)
                      (define-key sp-keymap (kbd "C-M-u") 'sp-backward-up-sexp)
                      (define-key sp-keymap (kbd "C-M-t") 'sp-transpose-sexp)

                      (define-key sp-keymap (kbd "C-M-n") 'sp-next-sexp)
                      (define-key sp-keymap (kbd "C-M-p") 'sp-previous-sexp)

                      (define-key sp-keymap (kbd "C-M-k") 'sp-kill-sexp)
                      (define-key sp-keymap (kbd "C-M-w") 'sp-copy-sexp)

                      (define-key sp-keymap (kbd "M-<delete>") 'sp-unwrap-sexp)
                      (define-key sp-keymap (kbd "M-<backspace>") 'sp-backward-unwrap-sexp)

                      (define-key sp-keymap (kbd "C-<right>") 'sp-forward-slurp-sexp)
                      (define-key sp-keymap (kbd "C-<left>") 'sp-forward-barf-sexp)
                      (define-key sp-keymap (kbd "C-M-<left>") 'sp-backward-slurp-sexp)
                      (define-key sp-keymap (kbd "C-M-<right>") 'sp-backward-barf-sexp)

                      (define-key sp-keymap (kbd "M-D") 'sp-splice-sexp)
                      (define-key sp-keymap (kbd "C-M-<delete>") 'sp-splice-sexp-killing-forward)
                      (define-key sp-keymap (kbd "C-M-<backspace>") 'sp-splice-sexp-killing-backward)
                      (define-key sp-keymap (kbd "C-S-<backspace>") 'sp-splice-sexp-killing-around)

                      (define-key sp-keymap (kbd "C-]") 'sp-select-next-thing-exchange)
                      (define-key sp-keymap (kbd "C-<left_bracket>") 'sp-select-previous-thing)
                      (define-key sp-keymap (kbd "C-M-]") 'sp-select-next-thing)

                      (define-key sp-keymap (kbd "M-F") 'sp-forward-symbol)
                      (define-key sp-keymap (kbd "M-B") 'sp-backward-symbol)))
#+END_SRC
** Ag
#+BEGIN_SRC emacs-lisp
  (use-package helm-ag
    :bind ("<f9> a" . helm-ag))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (use-package ag
    :bind ("<f9> A" . ag-project-at-point)
    :init
    (progn
      (setq ag-highlight-search t)))
#+END_SRC
** Wgrep
   Wgrep is pretty cool. It's like wdired, but for grep (duh),
   allowing you to make changes directly in a \*grep\* buffer.
#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    :init
    (progn
      (setq wgrep-auto-save-buffer t)
      (setq wgrep-enable-key "r")))
#+END_SRC
** nxml mode
   Turn off flyspell mode with nxml, as for whatever reason it hangs.
#+BEGIN_SRC emacs-lisp
  (add-hook 'nxml-mode-hook  (lambda () (flyspell-mode -1)))
#+END_SRC
** skewer-mode
   Some functions to evaluate either the region (if active) or the last expression.
#+BEGIN_SRC emacs-lisp
  (defun skewer-eval-last-expression-or-region (&optional prefix)
    "Evaluate the JavaScript expression before the point in the
  waiting browser. If invoked with a prefix argument, insert the
  result into the current buffer."
    (interactive "P")
    (if (use-region-p)
        (skewer-eval-region (region-beginning) (region-end))
      (skewer-eval-last-expression prefix)))

  (defun skewer-eval-region (beg end)
    "Execute the region as JavaScript code in the attached browsers."
    (interactive "r")
    (deactivate-mark)
    (skewer-flash-region beg end)
    (skewer-eval (buffer-substring beg end) #'skewer-post-minibuffer))

  (use-package skewer-mode
    :config
    (define-key skewer-mode-map (kbd "C-x C-e") 'skewer-eval-last-expression-or-region))
#+END_SRC
** diff-hl
   Diff-hl seems to be a useful way to visualize uncommitted changes in a file.
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :disabled t
    :config
    (add-hook 'dired-mode-hook 'diff-hl-dired-mode))
#+END_SRC
** Octave mode
   Open ".m" files with ~octave-mode~ by default
#+BEGIN_SRC emacs-lisp
  (autoload 'octave-mode "octave" nil t)
  ;; (setq auto-mode-alist
  ;;       (cons '("\\.m$" . octave-mode) auto-mode-alist))
#+END_SRC
** Matlab mode
   For a lot of neural science stuff, I have to use Matlab instead of Octave.

   I use a remote session, which means I usually set
   ~matlab-shell-command~ to a shell script that runs matlab over ssh.
#+BEGIN_SRC emacs-lisp
  (use-package matlab
    :init
    (setq matlab-shell-echoes nil)
    :config
    (define-key matlab-mode-map (kbd "C-c C-j") 'matlab-shell-run-region-or-line)) 
#+END_SRC

** Pdf-tools
   [[https://github.com/politza/pdf-tools][pdf-tools]] is a great package that makes viewing PDFs in Emacs much
   easier. Basically it's a replacement to DocView, but it allows you
   to do things such as incremental search, highlighting, and clicking
   on links.
#+BEGIN_SRC emacs-lisp
(use-package pdf-tools
  :defer t
  :init
  (setq pdf-view-continuous nil)
  :config
  (pdf-tools-install)
  :bind (:map pdf-view-mode-map
	      ("x" . xah-open-in-external-app)
	      ("M-s o" . pdf-occur)
	      ("e" . jmm/pdf-view-espeak-page)
	      ("E" . jmm/pdf-edit-helm-bibtex-notes)
	      ("a" . jmm/pdf-annotate-hydra/body)))
#+END_SRC

*** Espeak a PDF page

    Have Espeak read a PDF page for you.

#+BEGIN_SRC emacs-lisp
(defvar josh/espeak-speed
  300
  "Default espeak WPM")

(defvar jmm/espeak-script
  "~/code/sh/espeak-emacs.sh"
  "Location of a shell script to run espeak. This script should
  take one argument, the initial words-per-minute (WPM) speed.")

(defun jmm/pdf-view-espeak-page (&optional arg)
  "Espeak current PDF page (or current selection) in PDF view.
   Optional ARG takes an WPM speed (i.e. \"4\" becomes 400 WPM)"
  (interactive "P")
  (let* ((wpm (number-to-string (if arg (* arg 100) josh/espeak-speed)))
	 (pdf-text (car (prog2
			    (unless pdf-view-active-region (pdf-view-mark-whole-page))
			    (pdf-view-active-region-text)
			  (pdf-view-deactivate-region))))
	 (fixed-pdf-text (replace-regexp-in-string "-\n" "" pdf-text))
	 (process (start-process "espeak-process" " *espeak-pdf-view*" jmm/espeak-script wpm)))
    (process-send-string process (concat fixed-pdf-text "\n"))
    (process-send-eof process)))
#+END_SRC

*** Open bibtex notes

Many of the PDFs I open are stored in my ~org-ref~ / ~helm-bibtex~
directory. I'd like a hotkey to open notes I have for a PDF. This
function splits the window slightly and opens the notes file there.

#+BEGIN_SRC emacs-lisp
(defun jmm/pdf-edit-helm-bibtex-notes ()
  "Edit the notes for the PDF, assuming it's in one of our bibtex files"
  (interactive)
  (let ((key (file-name-base)))
    (when (= (length (window-list)) 1)
      (split-window nil -90 'left))
    (other-window 1)
    (bibtex-completion-edit-notes (list key))))
#+END_SRC

*** Keys to highlight with colors

    Pdf-tools makes highlighting fairly straightforward. Here I
    provide a hydra that makes it easy to quickly choose colors and
    annotation types for PDFs. To use it, select some text you want to
    highlight/underline/strike-out and press "~a~".

#+BEGIN_SRC emacs-lisp
(require 'hydra)
(defvar jmm/pdf-annot-type 'highlight)

(defun jmm/pdf-add-annot (color)
  (kill-new (mapconcat 'identity (pdf-view-active-region-text) "\n"))
  (pdf-annot-add-markup-annotation (pdf-view-active-region t) jmm/pdf-annot-type color))

(defhydra jmm/pdf-annotate-color-hydra (:exit t)
  "Color"
  ("y" (jmm/pdf-add-annot "yellow") "yellow")
  ("b" (jmm/pdf-add-annot "blue") "blue")
  ("g" (jmm/pdf-add-annot "green") "green")
  ("o" (jmm/pdf-add-annot "orange") "orange")
  ("r" (jmm/pdf-add-annot "red") "red")
  ("B" (jmm/pdf-add-annot "brown") "brown")
  ("p" (jmm/pdf-add-annot "pink") "pink")
  ("v" (jmm/pdf-add-annot "violet") "violet")
  ("q" nil "cancel"))

(defun jmm/pdf-annotate-run-hydra-with-type (type)
  "See `pdf-annot-add-markup-annotation' for possible TYPEs"
  (setq jmm/pdf-annot-type type)
  (let ((jmm/pdf-annot-type type))
    (jmm/pdf-annotate-color-hydra/body)))

(defhydra jmm/pdf-annotate-hydra (:exit t)
  "Annotate"
  ("h" (jmm/pdf-annotate-run-hydra-with-type 'highlight) "highlight")
  ("s" (jmm/pdf-annotate-run-hydra-with-type 'squiggly) "squiggly")
  ("u" (jmm/pdf-annotate-run-hydra-with-type 'underline) "underline")
  ("o" (jmm/pdf-annotate-run-hydra-with-type 'strike-out) "strike-out")
  ("q" nil "cancel"))
#+END_SRC


** Ace-window
[[https://github.com/abo-abo/ace-window][ace-window]] seems to provide a good way to switch between different windows.
It also provides functions for swapping and moving windows, which is super helpful.
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :bind (("C-9" . ace-window)
	 ("C-(" . ace-swap-window))
  :init
  (setq aw-scope 'visible))
#+END_SRC

** Web-mode
   Web-mode is a pretty good mode for editing HTML and JSX files.
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :init
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode)))
#+END_SRC

** Emojify
   Emoji are very important.
#+BEGIN_SRC emacs-lisp
(use-package emojify
  :ensure t
  :defer t
  :init
  (setq emojify-emoji-styles '(unicode))
  (bind-key "<f9> e" 'emojify-insert-emoji)
  :config
  (global-emojify-mode 1))
#+END_SRC
