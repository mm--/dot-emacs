#+TITLE: Josh Moller-Mara's Emacs configuration
#+OPTIONS: toc:1 h:4

The whole org-babel setup is shamelessly stolen from Sacha Chua.

My org-mode configuration is [[./jmm-org-config.org][here]].
* Emacs initialization and package management
  Here I set up where to find my Elisp files, and the repositories for
  packages.
#+begin_src emacs-lisp
(setq use-package-verbose t)
(add-to-list 'load-path "~/elisp")
(add-to-list 'load-path "~/.emacs.d/elisp")

(require 'package)
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
(add-to-list 'package-archives '("ELPA" . "https://elpa.gnu.org/packages/") t)
;; Marmalade has an insecure cert now
;; (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/") t)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+end_src

  Install packages if they aren't already.

#+BEGIN_SRC emacs-lisp
;; TODO: Move this bootstrapping stuff into its own file
;; (setq package-enable-at-startup nil)
;; Forget the warning in Emacs 27. Initialize it anyway for now.
(package-initialize)

;; TODO: This is being called in weird places, like when emacs is run
;; asynchronously. I either need to (package-initialize) or skip this
;; step completely.
(when (not package-archive-contents)
  (package-refresh-contents))
(defvar my-packages '(ess
                      magit
                      helm
                      auctex
                      zenburn-theme
                      multiple-cursors
                      phi-search
                      expand-region
                      async
                      auto-complete
                      projectile
                      ledger-mode
                      f
		      dash
                      helm-projectile
                      helm-swoop
		      hydra
                      js2-mode
                      flycheck
                      use-package
		      diminish
                      ))
;; TODO move elsewhere.
(setq save-abbrevs 'silently)
(dolist (p my-packages)
  (when (not (package-installed-p p))
    (package-install p)))
(setq use-package-verbose t)
(require 'use-package)
(use-package auto-compile
  :ensure t
  :unless noninteractive
  :config (auto-compile-on-load-mode))
(setq load-prefer-newer t)
#+END_SRC

  If I make any changes using Custom, I want them to be in a separate file.
#+begin_src emacs-lisp
;; TODO: This is slow. Defer this.
;; Also, make a macro/function for:
;; - [ ] Defering stuff
;; - [ ] Byte compiling and loading (with timing) a file
;; It looks like I can't immediately defer this because other things depend on this.
(setq custom-file "~/.emacs.d/custom.el")
   (if (file-exists-p custom-file)
       (load custom-file))
#+end_src

  Secret info. (Authentication info)
#+begin_src emacs-lisp
  (let ((secrets "~/.emacs.d/secrets.el"))
    (if (file-exists-p secrets) (load-file secrets)))
#+end_src

** Byte compile stuff?

#+begin_src emacs-lisp
(defun emacs/byte-recompile ()
  (interactive)
  (byte-recompile-directory "~/.emacs.d" 0)
  (byte-recompile-directory "~/elisp" 0))
#+end_src

* Basic configuration

Enable all the disabled commands
#+begin_src emacs-lisp
  (setq disabled-command-function nil)
#+end_src

#+begin_src emacs-lisp
;; I don't like having to type "yes"
(fset 'yes-or-no-p 'y-or-n-p)

(transient-mark-mode 1)
(column-number-mode 1)
(show-paren-mode 1)
;; I'll set this in customize, so by default it doesn't take it away.
;; (menu-bar-mode -1) ;; Was confusing some people
;; (tool-bar-mode 0)
;; (scroll-bar-mode 0)
(ignore-errors (horizontal-scroll-bar-mode 0)) ;Doesn't exist on some earlier emacs
(blink-cursor-mode 0)

(setq tab-bar-select-tab-modifiers '(control meta))
(setq tab-bar-tab-hints t)

(xterm-mouse-mode 1) ;; Allow people to click around if using the terminal

;; Some performance things for snappier redisplay
(setq redisplay-skip-fontification-on-input t)
(setq fast-but-imprecise-scrolling t)
(setq jit-lock-defer-time 0)
;; TODO: Maybe figure out a better setting for gc-cons-threshold
;; I seem to need this in emacs-pgtkgcc, with some stuttering in helm-mode.
(setq gc-cons-threshold 80000000)

;;(set-register ?e '(file . "~/.emacs.d/jmm-emacs.org"))
;;(set-register ?d '(file . "~/Downloads/"))

(setq launchserver (when (member "--server" command-line-args)
		 t))
(setq command-line-args
      (remove "--server" command-line-args))

(use-package server
  :unless (or noninteractive (not launchserver))
  :defer 1
  :config
  (server-start))

(setq visible-bell 0)                   ;Set visible bell on.
(setq ring-bell-function 'ignore)       ;Visible bell.

(setq frame-title-format "Emacs - %b")
(setq set-mark-command-repeat-pop t)
(use-package uniquify
  :defer 2
  :init
  (setq uniquify-buffer-name-style 'forward))

(use-package winner
  :unless noninteractive
  :defer 1
  :config
  (winner-mode 1))

(setq focus-follows-mouse t)
;; (setq mouse-autoselect-window t) ;Sloppy focus
(setq inhibit-splash-screen t)
(setq Man-notify-method 'pushy)
;;(set-frame-font "-misc-fixed-medium-r-normal-*-11-*-*-*-*-*-*-*")
(setq visual-line-fringe-indicators '(nil right-curly-arrow))
(setq mouse-yank-at-point t)

(setq history-length 1000)
(setq history-delete-duplicates t)

(setq async-shell-command-buffer 'new-buffer)

(setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "firefox")
;; Obsolete variable
;; (setq shr-external-browser 'browse-url-generic) ;For eww
(setq epg-gpg-program "gpg2")

;; The *help* window default behavior is kinda annoying. Always select
;; it so I can quickly close it by pressing "q"
(setq help-window-select t)
#+end_src

Make scripts executable
#+begin_src emacs-lisp
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+end_src

** Prompt before exiting Emacs

#+begin_src emacs-lisp
(setq kill-emacs-query-functions
      (cons (lambda () (yes-or-no-p "Really kill Emacs?"))
     kill-emacs-query-functions))
#+end_src

** Dealing with the clipboard
#+begin_src emacs-lisp
(setq select-enable-clipboard t) ; as above
(setq interprogram-paste-function #'gui-selection-value)
(setq select-enable-primary t)
#+end_src
** Windmove
#+begin_src emacs-lisp
(windmove-default-keybindings 'control)
#+end_src
** Load personal files

   Load some elisp files that aren't tracked in git. Usually this is
   scratchwork that I haven't completed, but it can also be personal
   configuration options like setting ~user-full-name~.

#+BEGIN_SRC emacs-lisp
;; TODO: Should probably move this to a file with an autoload
(require 'f)
(defun jmm/org-maybe-tangle-el (file)
  "Tangle an org file to an .el file only if org file is newer."
  (let ((export-file (concat (f-no-ext file) ".el")))
    (when (or (not (file-exists-p export-file))
	      (file-newer-than-file-p file export-file))
      (require 'org)
      (org-babel-tangle-file file export-file))))

;; This gets called at the end of init.el
(defun jmm/load-personal-files ()
  (let ((personal (concat user-emacs-directory "personal")))
    (when (f-directory-p personal)
      ;; Ignore files starting with things like ".#"
      (mapc 'jmm/org-maybe-tangle-el (-filter #'f-file? (directory-files personal t "^[a-zA-Z0-9].*.*org$")))
      (mapc 'load (directory-files personal t "^[a-zA-Z0-9].*.*el$")))))
#+END_SRC
** Set the PATH variable on a Mac

   I don't use a Mac. But when I use this config on Macs, sometimes
   it's necessary to correctly set the ~PATH~ environment variable,
   for things like CIDER.

#+BEGIN_SRC emacs-lisp
(use-package exec-path-from-shell
  :ensure t
  :if (memq window-system '(mac ns))
  :config
  (exec-path-from-shell-initialize))
#+END_SRC


* Theme/Appearance
#+begin_src emacs-lisp
;; (when window-system
;;   (load-theme 'zenburn))
#+end_src
** Font
Set my font
#+BEGIN_SRC emacs-lisp
;; TODO: Figure out how to undo this
(defun josh/set-my-font (myfont)
  (when (and window-system (x-list-fonts myfont))
    (set-frame-font myfont)
    (add-to-list 'default-frame-alist
                 (cons 'font myfont))))

;; (josh/set-my-font "-unknown-DejaVu Sans Mono-normal-normal-normal-*-10-*-*-*-m-0-iso10646-1")
;; (josh/set-my-font "-PfEd-DejaVu Sans Mono-normal-normal-normal-*-10-*-*-*-m-0-iso10646-1")
#+END_SRC

Set a reasonable font for Chinese, if we have it.

#+BEGIN_SRC emacs-lisp
(when (and window-system (x-family-fonts "Noto Sans Mono CJK SC"))
  (set-fontset-font t 'chinese-gbk (font-spec :family "Noto Sans Mono CJK SC")))
#+END_SRC

Show color emojis.

#+begin_src emacs-lisp
;; TODO: Make a macro out of this
;; TODO: Maybe only if Cairo and Harfbuzz are enabled?
;; TODO: Include ligatures/composition. See https://emacs.stackexchange.com/a/62220
(when (and window-system (x-family-fonts "Noto Color Emoji"))
  (set-fontset-font t 'symbol (font-spec :family "Noto Color Emoji")))
#+end_src


For whatever reason, when trying to view the HELLO file in Emacs 28 in NixOS, Emacs hangs.
Using `csysdig`, I found a lot of accesses to an "Adobe Blank" font
file. A bug report [here](https://debbugs.gnu.org/db/40/40733.html)
shows how to work around this.

#+BEGIN_SRC emacs-lisp
(setq face-ignored-fonts '("Adobe Blank"))
#+END_SRC

** Telephone Line
   My default modeline was making it hard to see my [[https://github.com/wasamasa/eyebrowse][eyebrowse]]
   workspace when I was clocked in to something. [[https://github.com/dbordak/telephone-line][Telephone line]] looks
   decent.

#+BEGIN_SRC emacs-lisp
(use-package telephone-line
  :ensure t
  :if window-system
  :defer 1
  :disabled
  :init
  (setq telephone-line-lhs
	'((accent . (telephone-line-vc-segment
                     telephone-line-process-segment
		     telephone-line-pdf-segment))
          (nil    . (telephone-line-minor-mode-segment
                     telephone-line-buffer-segment))))
  (setq telephone-line-rhs
	'((nil    . (telephone-line-misc-info-segment))
          (accent . (telephone-line-major-mode-segment))
          (evil   . (telephone-line-airline-position-segment))))
  :config
  ;; Adapted from http://tech.toryanderson.com/2018/05/27/display-pdf-pages-with-telephone-line/
  ;; For pdf-tools
  (telephone-line-defsegment telephone-line-pdf-segment ()
    (if (eq major-mode 'pdf-view-mode)
	(propertize (pdf-view-page-number)
                    'face '(:inherit)
                    'display '(raise 0.0)
                    'mouse-face '(:box 1)
                    'local-map (make-mode-line-mouse-map
				'mouse-1 (lambda ()
					   (interactive)
					   (pdf-view-goto-page))))))
  (telephone-line-mode 1))
#+END_SRC
*** PDF Tools segment

#+BEGIN_SRC emacs-lisp
;; Adapted from http://tech.toryanderson.com/2018/05/27/display-pdf-pages-with-telephone-line/
(defun pdf-view-page-number ()
  "Format the page number to be displayed on the modeline.

Shows the current page, total number of pages, and the page
label (which can be different from the number for example if you're on page \"iv\")"
  (interactive)
  (let ((x (format  "[pg %s/%s \"%s\"]"
		    (number-to-string (pdf-view-current-page))
		    (number-to-string (pdf-cache-number-of-pages))
		    (nth (1- (pdf-view-current-page))
		    	 (pdf-info-pagelabels))
		    )))
    (if (called-interactively-p)
	(message x)
      x)))
#+END_SRC
** Change theme depending on GTK theme

   A great post from "noi-gai" [[https://old.reddit.com/r/emacs/comments/o49v2w/automatically_switch_emacs_theme_when_changing/][on Reddit]].
   Allows Emacs to change with the [[https://extensions.gnome.org/extension/2236/night-theme-switcher/][Night Theme Switcher]] extension for GNOME.

#+begin_src emacs-lisp
;; D'oh. I changed "call-process-string" because I didn't see it was defined later.
(defun jmm/is-gtk-theme-dark ()
  "Return t if GTK theme is dark.
Based off of code from noi-gai on Reddit.
https://old.reddit.com/r/emacs/comments/o49v2w/automatically_switch_emacs_theme_when_changing/"
  (let ((gtk-theme (->
		       (with-output-to-string
			 (call-process "gsettings"
				       nil standard-output nil
				       "get"
				       "org.gnome.desktop.interface"
				       "gtk-theme"))
		     (string-trim-right)
		     (downcase))))
    (or (string-match-p "dark"  gtk-theme)
	(string-match-p "black" gtk-theme))))

(defun gtk-theme-changed (path _one _two)
  "DBus handler to detect when the GTK theme has changed."
  (when (string-equal path "/org/gnome/desktop/interface/gtk-theme")
    ;; (message (format "%s %s %s" path _one _two))
    ;; I'm not sure what _one is, but _two looks like the address of
    ;; some D-bus listener
    (set-modus-theme-from-gtk)))

(defun set-modus-theme-from-gtk ()
  "Set modus theme by checking whether GTK theme is dark."
  (if (jmm/is-gtk-theme-dark)
      (progn
	;; Otherwise we can't find modus-themes (it seems to be in a different path)
	(require-theme 'modus-vivendi-theme)
	(modus-themes-load-vivendi))
    (disable-theme 'modus-vivendi)
    ;; (modus-themes-load-operandi)
    ))

;; TODO: Maybe do this on idle.
(run-with-idle-timer
 3 nil
 (lambda ()
   (when (memq window-system '(pgtk))
     (require 'dbus)
     (dbus-register-signal
      :session
      "ca.desrt.dconf"
      "/ca/desrt/dconf/Writer/user"
      "ca.desrt.dconf.Writer"
      "Notify"
      #'gtk-theme-changed)
     (set-modus-theme-from-gtk))))
#+end_src


* Keybindings

#+begin_src emacs-lisp
;; (bind-key "C-x g" 'gnus)
;; (bind-key "C-x C-a" 'artist-mode)
(bind-key "C-x C-b" 'ibuffer)
(bind-key "<f9> m" 'magit-status)
(define-key (current-global-map) [remap imenu] 'helm-imenu)
;; Replaced with helm
(bind-key "C-c q" #'bury-buffer)
#+end_src
** Keybindings to load org
   Again, most of my org-mode configuration is [[./jmm-org-config.org][here]], but for some dumb
   reason I'm trying to get my emacs startup time fast (which is dumb
   because I just keep a daemon running and use ~emacsclient~ 🤷), so
   I don't load my org config until org is actually loaded. These are
   some keybindings I use to load org.

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure org-plus-contrib
  :bind (("C-c c" . org-capture)
	 ("C-c a" . org-agenda)
	 ("C-c l" . org-store-link)
	 ("C-c L" . org-insert-link-global)
	 ("C-c o" . org-open-at-point-global)
	 ("<f12>" . jmm/org-default-agenda)
	 ("<f9> i" .  jmm/org-export-ical-stuff)
	 ("<f9> j" . josh/helm-org-jump)
	 ("<f9> z" . josh/helm-org-clock-in2)
	 ("<f9> J" . jmm/helm-org-jump-project))
  :mode ("\\.org\\'" . org-mode))
#+END_SRC
** Free keys
   
#+begin_src emacs-lisp
(use-package free-keys
  :unless noninteractive
  :bind ("C-h M-k" . free-keys))
#+end_src


* Autosaves and backups

Autosaves
#+begin_src emacs-lisp
;; Put autosave files (ie #foo#) in one place, *not*
;; scattered all over the file system!
(defvar autosave-dir
 "~/emacs_autosaves/")

(make-directory autosave-dir t)

(defun auto-save-file-name-p (filename)
  (string-match "^#.*#$" (file-name-nondirectory filename)))

(defun make-auto-save-file-name ()
  (concat autosave-dir
   (if buffer-file-name
      (concat "#" (file-name-nondirectory buffer-file-name) "#")
    (expand-file-name
     (concat "#%" (buffer-name) "#")))))
#+end_src

Backups
Put backup files (ie foo~) in one place too. (The backup-directory-alist
list contains regexp=>directory mappings; filenames matching a regexp are
backed up in the corresponding directory. Emacs will mkdir it if necessary.)
#+begin_src emacs-lisp
  (defvar backup-dir "~/emacs_backups/")
  (make-directory backup-dir t)
  (setq backup-directory-alist (list (cons ".dreams." ".") (cons "." backup-dir)))
#+end_src

* Autocompletion, Hippie expand

#+begin_src emacs-lisp
(bind-key "M-?" 'hippie-expand)
#+end_src

** Hippie Expand stuff:

#+begin_src emacs-lisp
(setq hippie-expand-try-functions-list (quote (try-complete-file-name-partially try-complete-file-name try-expand-all-abbrevs try-expand-list try-expand-line try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill try-complete-lisp-symbol-partially try-complete-lisp-symbol try-expand-dict-command)))
#+end_src

#+begin_src emacs-lisp
(defun he-dict-command-beg ()
  (let ((p))
    (save-excursion
      (backward-word 1)
      (setq p (point)))
    p))

(defun try-expand-dict-command (old)
  (unless old
    (he-init-string (he-dict-command-beg) (point))
    (setq he-expand-list (sort
			  (all-completions he-search-string (mapcar 'list (ispell-lookup-words (concat old "*") ispell-complete-word-dict)))
			  'string-lessp)))
  (while (and he-expand-list
              (he-string-member (car he-expand-list) he-tried-table))
    (setq he-expand-list (cdr he-expand-list)))
  (if (null he-expand-list)
      (progn
	(when old (he-reset-string))
	())
    (he-substitute-string (car he-expand-list))
    (setq he-tried-table (cons (car he-expand-list) (cdr he-tried-table)))
    (setq he-expand-list (cdr he-expand-list))
    t))
#+end_src

* Compiling conveniences

#+begin_src emacs-lisp
;; TODO: Should probably move this in its own autoload file
(require 'compile)
(add-hook 'c++-mode-hook
	  (lambda ()
	    (unless (file-exists-p "Makefile")
	      (set (make-local-variable 'compile-command)
		   ;; emulate make's .c.o implicit pattern rule, but with
		   ;; different defaults for the CC, CPPFLAGS, and CFLAGS
		   ;; variables:
		   ;; $(CC) -c -o $@ $(CPPFLAGS) $(CFLAGS) $<
		   (let ((file (file-name-nondirectory buffer-file-name)))
		     (format "%s %s %s -o %s"
			     (or (getenv "CPP") "g++")
			     (or (getenv "CFLAGS") "-g -Os")
			     file
			     (file-name-sans-extension file)
			     ))))))
#+end_src

#+begin_src emacs-lisp
(bind-key "<f9> <f9>" 'recompile)
#+end_src

#+begin_src emacs-lisp
(setq compilation-scroll-output 1)
#+end_src

* Spelling

  Spellchecking on Emacs, or just Linux in general, is terrible. Like,
  really terrible. Reasons:
  - Spelling suggestions often don't make sense because "edit
    distance" isn't a good metric for figuring out what word you were
    trying to spell. Edit distance is fast, but that's it. It doesn't
    take into account the frequency of suggested words.
  - Most spell checkers don't take into account context. For example
    "less then" is marked correct even though you meant "less than".

  I was using ~hunspell~, but it [[https://github.com/hunspell/hunspell/issues/504][seems to have a problem with apostrophes]]. ~aspell~ doesn't.

#+begin_src emacs-lisp
;; TODO: Check if the specified ispell program is installed.
;; (setq-default ispell-program-name "hunspell")
(setq-default ispell-program-name "aspell")
(setq-default ispell-grep-command "grep")
(setq-default ispell-grep-options "-iE")
(setq-default ispell-complete-word-dict "/usr/share/dict/american-english")
(setq-default ispell-silently-savep t)
;; (use-package rw-hunspell
;;   :after flyspell)
#+end_src

#+begin_src emacs-lisp
(add-hook `text-mode-hook `flyspell-mode)
(add-hook `latex-mode-hook `flyspell-mode)
(add-hook `tex-mode-hook `flyspell-mode)
(add-hook `bibtex-mode-hook `flyspell-mode)
(add-hook 'prog-mode 'flyspell-prog-mode)
#+end_src

Right click to correct a word (instead of middle click).

#+begin_src emacs-lisp
(setq flyspell-use-mouse-3-for-menu t)
#+end_src

** Accepting previous misspelled words

#+begin_src emacs-lisp
(defun flyspell-accept-prev (position &optional savetype)
  "Accept the previously mispelled word onscreen. Defaults saving to session, but optional savetype can save to personal dict"
  (interactive "d")
  (or savetype (setq savetype 'session))
  (let ((top (window-start))
	(bot (window-end))
	correctpos)
    (save-excursion
      (save-restriction
	(narrow-to-region top bot)
	(overlay-recenter (point))

	  (let ((overlay-list (overlays-in (point-min) position))
		(new-overlay 'dummy-value))

	    ;; search for previous (new) flyspell overlay
	    (while (and new-overlay
			(or (not (flyspell-overlay-p new-overlay))
			    ;; check if its face has changed
			    (not (eq (get-char-property
				      (overlay-start new-overlay) 'face)
				     'flyspell-incorrect))))
	      (setq new-overlay (car-safe overlay-list))
	      (setq overlay-list (cdr-safe overlay-list)))

	    ;; if nothing new exits new-overlay should be nil
	    (if new-overlay ;; the length of the word may change so go to the start
		(setq correctpos
		      (overlay-start new-overlay))))

	(when correctpos
	  (save-excursion
	    (goto-char correctpos)
	    (let ((cursor-location (point))
		  (opoint (point))
		  (word (flyspell-get-word)))
	      (if (consp word)
		  (let ((start (car (cdr word)))
			(end (car (cdr (cdr word))))
			(word (car word))
			poss ispell-filter)
		    (flyspell-do-correct savetype poss word cursor-location start end opoint)
		    (ispell-pdict-save t))))))))))

(defun flyspell-accept-prev-save (position)
  "Save the previously mispelled word. See flyspell-accept-prev"
  (interactive "d")
  (flyspell-accept-prev position 'save))

(add-hook 'flyspell-mode-hook
 (lambda ()
   (define-key flyspell-mode-map (kbd "C-M-;") 'flyspell-accept-prev)
   (define-key flyspell-mode-map (kbd "C-:") 'flyspell-accept-prev-save)
   ))
#+end_src
** Looking up dictionary words

   Not directly related to spelling, but I have ~dictd~
   installed. ~aspell~ still complains about a lot of words that I
   think are valid, like "dimensionality". To make sure it's just an
   issue with ~aspell~ and not actually my spelling (like if I typed
   "dimensoinality"), I'm binding a key for ~dictionary-lookup-definition~.
   
#+begin_src emacs-lisp
(bind-key (kbd "C-c z d") 'dictionary-lookup-definition)
#+end_src

   ~dictd~ can also (indirectly) suggest spelling corrections. It'd be
   cool to use ~dictionary.el~ to suggest ~ispell~/~flyspell~
   corrections in the future.


* LaTeX

#+begin_src emacs-lisp
(setq latex-run-command "pdflatex")
(setq tex-output-extension ".pdf")
#+end_src

#+begin_src emacs-lisp
;; (add-hook `latex-mode-hook (lambda () (defun tex-view ()
;;   (interactive)
;;   (tex-send-command "evince" (tex-append tex-print-file ".pdf") t))))
#+end_src

Make it easier to insert Greek symbols
#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
#+end_src
** Minor modes for LaTeX editing

   Make it easier to visualize colors, for example with TikZ.

#+begin_src emacs-lisp
(add-hook 'LaTeX-mode-hook 'rainbow-mode)
#+end_src

** Bibtex stuff (no longer needed?)
#+begin_src emacs-lisp
(add-hook 'latex-mode-hook
	  (lambda ()
	    (defun tex-bibtex-file ()
	      "Run BibTeX on the current buffer's file."
	      (interactive)
	      (if (tex-shell-running)
		  (tex-kill-job)
		(tex-start-shell))
	      (let* (shell-dirtrack-verbose
		     (source-file (tex-main-file))
		     (tex-out-file
		      (tex-append (file-name-nondirectory source-file) ""))
		     (file-dir (file-name-directory (expand-file-name source-file))))
		(tex-send-command tex-shell-cd-command file-dir)
		(tex-send-command tex-bibtex-command tex-out-file))
	      (tex-display-shell))))
#+end_src

** Biber/BibLaTeX
   
#+begin_src emacs-lisp
(setq bibtex-dialect 'biblatex)
#+end_src

** AUCTeX and skeletons
#+begin_src emacs-lisp
;; AUCTeX
;; (setq load-path (append load-path "~/.emacs.d/elpa/auctex-11.87.2/"))
;; (load "auctex.el" nil t t)
;; (load "preview-latex.el" nil t t)
(setq TeX-auto-save t)
(setq TeX-parse-self t)
;; (setq-default TeX-master nil)		  ; This prompts for a master file each time.
(add-hook 'LaTeX-mode-hook 'TeX-PDF-mode) ;use pdflatex by default

(add-hook 'LaTeX-mode-hook 'turn-on-reftex)
(setq reftex-plug-into-AUCTeX t)

(defun jmm/latex-configuration ()
  ;; View with PDF Tools by default
  ;; (setf (alist-get 'output-pdf TeX-view-program-selection) (list "PDF Tools"))
  ;; Automatically revert PDF buffer. Works better than my old
  ;; solution of turning on auto-revert-mode.
  (add-hook 'TeX-after-compilation-finished-functions
            #'TeX-revert-document-buffer)
  (setq TeX-source-correlate-mode t))

(add-hook 'LaTeX-mode-hook 'jmm/latex-configuration)
#+end_src

** Skeletons

Makes entering some symbols easier.
#+begin_src emacs-lisp
(setq skeleton-end-newline nil)
(add-hook 'LaTeX-mode-hook
 (lambda ()
   (define-key LaTeX-mode-map (kbd "` v (") 'latex-skeleton-left-paren)
   (define-key LaTeX-mode-map (kbd "` v [") 'latex-skeleton-left-bracket)
   (define-key LaTeX-mode-map (kbd "` v {") 'latex-skeleton-left-brace)
   (define-key LaTeX-mode-map (kbd "` v t") 'latex-math-text)
   (define-key LaTeX-mode-map (kbd "` v $") 'quoted-parens)
   (define-key LaTeX-mode-map (kbd "` v %") 'quoted-brackets)
   (define-key LaTeX-mode-map (kbd "` v b") 'jmm/LaTeX-mathbb)
   ))

(define-skeleton latex-skeleton-left-paren
  "Insert \\left( ... \\right)."
  nil "\\left(" _ "\\right)")

(define-skeleton latex-skeleton-left-bracket
  "Insert \\left[ ... \\right]."
  nil "\\left[" _ "\\right]")

(define-skeleton latex-skeleton-left-brace
  "Insert \\left\\{ ... \\right\\}."
  nil "\\left\\{" _ "\\right\\}")

(define-skeleton latex-math-text
  "Insert \\text{ ... }."
  nil "\\text{" _ "}")

(define-skeleton quoted-parens
  "Insert \\( ... \\)."
  nil "\\(" _ "\\)")

(define-skeleton quoted-brackets
  "Insert \\[ ... \\]."
  nil "\\[" _ "\\]")

(defun jmm/LaTeX-mathbb (char dollar)
  "Like `LaTeX-math-cal' but for \\mathbb."
  (interactive "*c\nP")
  (if dollar (insert (or (car TeX-electric-math) "$")))
  (insert "\\mathbb{" (char-to-string char) "}")
  (if dollar (insert (or (cdr TeX-electric-math) "$"))))
#+end_src
** AUCTeX handling errors
Sometimes AUCTex can't parse errors correctly, prompting you to create a directory.

I'm also adding ~--synctex=1~ so I can go to the LaTeX source by control-clicking in pdf-tools.
#+begin_src emacs-lisp
(setq LaTeX-command-style '(("" "%(PDF)%(latex) %(file-line-error) %(extraopts) --synctex=1 %S%(PDFout)")))
#+end_src
** AUCTeX preview-latex scaling

For some reason the default scaling isn't working for me. This tries to calculate scale based on ~text-scale-mode~.

#+BEGIN_SRC emacs-lisp
(setq preview-scale-function #'jmm/get-font-scale)

(defun jmm/get-font-scale ()
  "Try to get the `text-scale-mode' relative scale amount."
  (or (plist-get (car (alist-get 'default face-remapping-alist)) :height) 1))
#+END_SRC

Also, the preview font color initially wasn't working for me (since I use a light on dark color theme). It turns
out my ghostscript version was too old. If this happens, use the
following line.

#+BEGIN_SRC emacs-lisp
;; (setq preview-pdf-color-adjust-method 'compatible)
#+END_SRC
** Custom faces for some custom LaTeX macros.

   I have some custom macros in LaTeX that help me keep track of some
   ~org-mode~ todos. This provides some nicer faces for them.

#+begin_src emacs-lisp
(defface jmm-latex-todo
  '((t
     ( :foreground "tomato"
       ;; :weight bold
       ;; :box (:line-width
       ;; 	     (2 . 2)
       ;; 	     :color "tomato"
       ;; 	     :style nil)
       )))
  "For todos in `font-latex-user-keyword-classes'.")

(defface jmm-latex-done
  '((t
     ( :foreground "sea green"
       ;; :weight bold
       ;; :box (:line-width
       ;; 	     (2 . 2)
       ;; 	     :color "sea green"
       ;; 	     :style nil)
       )))
  "For completed todos in `font-latex-user-keyword-classes'.")

(setq font-latex-user-keyword-classes
      '(("my-reference"
	 (("goalstatus" "{") ("goaldone" "{["))
	 font-lock-constant-face command)
	("my-todo"
	 (("todo" "{") ("todojeff" "{") ("orgtodo" "*[{"))
	 jmm-latex-todo command)
	("my-done"
	 (("orgtodoDONE" "[{"))
	 jmm-latex-done command)))

#+end_src


* R/ESS
  This seems to be necessary when installing ESS from MELPA.
#+begin_src emacs-lisp
(use-package ess
  :ensure t
  :mode (("\\.[rR]\\'" . R-mode)
	 ("\\.[rR]profile\\'" . R-mode)
	 ("NAMESPACE\\'" . R-mode)
	 ("\\.jl\\'" . ess-julia-mode)
	 ("\\.[jJ][aA][gG]\\'" . ess-jags-mode))
  :init
  ;; See https://github.com/emacs-ess/ESS/issues/1074#issuecomment-762529812
  ;; ESS isn't working well with Helm.
  (setq ess-ask-for-ess-directory nil)
  :config 
   ;; I like how ESS previously indented continuations as it makes ggplot
   ;; code easier to read.
  (add-to-list 'ess-style-alist
		       '(MY-STYLE
			 (ess-indent-level . 4)
			 (ess-first-continued-statement-offset . 4)
			 (ess-continued-statement-offset . 0)
			 (ess-brace-offset . 0)
			 (ess-arg-function-offset . 4)
			 (ess-arg-function-offset-new-line . '(4))
			 (ess-expression-offset . 4)
			 (ess-else-offset . 0)
			 (ess-close-brace-offset . 0)))
  ;; (setq ess-default-style 'MY-STYLE)
  )

(use-package ess-r-mode
  :bind (:map ess-r-mode-map
  	      ("C-c C-p" . jmm/ess-eval-pipe-paragraph-and-print)
	      ("C-c C-l" . jmm/ess-show-last-value)
  	      ("C-%" . then_R_operator)
	      ("_" . ess-insert-assign)
	 :map inferior-ess-r-mode-map
	      ("C-%" . then_R_operator)
	      ("_" . ess-insert-assign)))
#+end_src

#+begin_src emacs-lisp
  (setq comint-scroll-to-bottom-on-input t)
  (setq comint-scroll-to-bottom-on-output t)
  (setq comint-move-point-for-output t)

  (add-hook 'ess-mode-hook
            (lambda ()
              (flyspell-prog-mode)
              (smartparens-mode 0)))

  (add-hook 'inferior-ess-mode-hook
            (lambda ()
              (smartparens-mode 0)))

  (autoload 'ess-rdired "ess-rdired"
    "View *R* objects in a dired-like buffer." t)
#+end_src
** JAGS
#+begin_src emacs-lisp
;; (require 'ess-jags-d)
#+end_src

** View an object
#+begin_src emacs-lisp
  (defun ess-dump-object-into-view-buffer (object)
    "Edit an ESS object in its view buffer."
    (interactive
     (progn
       (ess-force-buffer-current "Process to dump from: ")
       (if (ess-ddeclient-p)
           (list (read-string "Object to edit: "))
         (ess-read-object-name "Object to edit"))))
    (ess-execute (ess-rdired-get object)
               nil "R view" ))

  (eval-after-load "ess-mode"
    '(define-key ess-mode-map (kbd "C-c v") 'ess-dump-object-into-view-buffer))
#+end_src

** Clear the shell
#+begin_src emacs-lisp
(defun clear-shell ()
   (interactive)
   (let ((old-max comint-buffer-maximum-size))
     (setq comint-buffer-maximum-size 0)
     (comint-truncate-buffer)
     (setq comint-buffer-maximum-size old-max)))
#+end_src

** Truncate automatically
#+begin_src emacs-lisp
  (setq comint-buffer-maximum-size 2000)
  (add-hook 'comint-output-filter-functions
            'comint-truncate-buffer)
#+end_src
** Magrittr pipes

   When you have a lot of ~magrittr~ pipes, sometimes you want to see
   what's being output at a certain step in the chain. This function
   evaluates the current chain up to the end of the line, and prints
   the result.

#+BEGIN_SRC emacs-lisp
(defun jmm/ess-eval-pipe-paragraph-and-print (vis)
  "Send current paragraph (up to the end of the current line) to the inferior ESS process.
This function will check if the current line ends with a \"%>%\" and also send a \"print\" command if it does.
Useful for seeing that the output is at certain steps of a pipe chain.
Prefix arg VIS toggles visibility of ess-code as for `ess-eval-region'."
  (interactive "P")
  (save-excursion
    (let ((send-print? (prog2
			   (beginning-of-line)
			   (looking-at-p ".*%>%\s*$") ;Looking at a that ends in a pipe.
			 (end-of-line)))
	  (visibly (if vis (not ess-eval-visibly) ess-eval-visibly))
	  (end (point)))
      (backward-paragraph)
      (ess-skip-blanks-forward 'multiline)
      (ess-eval-region (point) end vis "Eval paragraph")
      ;; If we send something that ends in a pipe, it'll wait until we
      ;; give some final output, so here we send a "print"
      (when send-print? (ess-send-string (ess-get-process) "print" visibly)))))
#+END_SRC

And a handy [[https://emacs.stackexchange.com/questions/8041/how-to-implement-the-piping-operator-in-ess-mode][keybinding from StackExchange]] for the pipe.
#+BEGIN_SRC emacs-lisp
;; From https://emacs.stackexchange.com/questions/8041/how-to-implement-the-piping-operator-in-ess-mode
(defun then_R_operator ()
  "R - %>% operator or 'then' pipe operator"
  (interactive)
  (just-one-space 1)
  (insert "%>%")
  (reindent-then-newline-and-indent))
#+END_SRC
** Show the last value

#+begin_src emacs-lisp
(defun jmm/ess-show-last-value ()
  "Send \".Last.value\" to the R process.
Handy when you assign something and don't want to wrap it in parens."
  (interactive)
  (ess-send-string (ess-get-process) ".Last.value" t))
#+end_src


* ERC
I don't really use ERC anymore.
#+begin_src emacs-lisp
(use-package erc
  :commands (erc)
  :init
  (setq erc-nick "emdash"
        erc-server "localhost"
        erc-port "1799")
  (setq erc-auto-query 'bury)
  :config
  (require 'erc-services)
  (erc-services-mode 1))
#+end_src
** Notify
#+begin_src emacs-lisp
;;list of regexpes ignored by tray icon
(defun erc-tray-change-state (arg)
  "Enables or disable blinking, depending on arg"
  (if arg
      (shell-command-to-string
       "echo B > /tmp/tray_daemon_control")
    (shell-command-to-string
     "echo b > /tmp/tray_daemon_control")))
(defun erc-tray-update-state ()
  "Updates the state of the tray icon according to the contents
of erc-modified-channels-alist"
  (interactive)
  (let ((blinkify nil))
    (mapc (lambda (el)
	    (when (string-match "erc-current-nick-face" (face-name (nthcdr 2 el)))
	      (setq blinkify t)))
	  erc-modified-channels-alist)
    (erc-tray-change-state blinkify)))
(when window-system
  (add-hook 'erc-track-list-changed-hook 'erc-tray-update-state))
(setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT"))
#+end_src

** More notify stuff
#+begin_src emacs-lisp
  ;; Notify my when someone mentions my nick.
  (defun erc-global-notify (matched-type nick msg)
    (interactive)
    (when (eq matched-type 'current-nick)
      (shell-command
       (concat "notify-send -t 4000 -c \"im.received\" \""
               (car (split-string nick "!"))
               " mentioned your nick\" \""
               msg
               "\""))))
  (add-hook 'erc-text-matched-hook 'erc-global-notify)
#+end_src
** Timestamp
#+begin_src emacs-lisp
(make-variable-buffer-local
 (defvar erc-last-datestamp nil))

(defun ks-timestamp (string)
  (erc-insert-timestamp-left string)
  (let ((datestamp (erc-format-timestamp (current-time) erc-datestamp-format)))
    (unless (string= datestamp erc-last-datestamp)
      (erc-insert-timestamp-left datestamp)
      (setq erc-last-datestamp datestamp))))


(setq erc-timestamp-only-if-changed-flag t
      erc-timestamp-format "%H:%M "
      erc-datestamp-format " === [%Y-%m-%d %a] ===\n" ; mandatory ascii art
      erc-fill-prefix "      "
      erc-insert-timestamp-function 'ks-timestamp)
#+end_src

* rcirc
#+begin_src emacs-lisp
(use-package rcirc
  :commands (rcirc)
  :init
  (setq rcirc-debug-flag t)
  (setq rcirc-default-nick "emdash")
  (setq rcirc-default-user-name "joshm")
  (setq rcirc-default-full-name "Josh Moller-Mara")
  (setq rcirc-buffer-maximum-lines 2000)
  :config
  ;; Adjust the colours of one of the faces.
  (set-face-foreground 'rcirc-my-nick "red" nil)
  (add-hook 'rcirc-mode-hook (lambda ()
			       (flyspell-mode 1)))
  (add-hook 'rcirc-mode-hook
            (lambda ()
              (rcirc-track-minor-mode 1))))
#+end_src
** Reconnect after disconnect

#+begin_src emacs-lisp
  (eval-after-load 'rcirc
    '(defun-rcirc-command reconnect (arg)
       "Reconnect the server process."
       (interactive "i")
       (unless process
         (error "There's no process for this target"))
       (let* ((server (car (process-contact process)))
              (port (process-contact process :service))
              (nick (rcirc-nick process))
              channels query-buffers)
         (dolist (buf (buffer-list))
           (with-current-buffer buf
             (when (eq process (rcirc-buffer-process))
               (remove-hook 'change-major-mode-hook
                            'rcirc-change-major-mode-hook)
               (if (rcirc-channel-p rcirc-target)
                   (setq channels (cons rcirc-target channels))
                 (setq query-buffers (cons buf query-buffers))))))
         (delete-process process)
         (rcirc-connect server port nick
                        rcirc-default-user-name
                        rcirc-default-full-name
                        channels))))
#+end_src

** Load rcirc-notify
#+begin_src emacs-lisp
(use-package rcirc-notify
  :after rcirc)
#+end_src

** Load rcirc color
#+begin_src emacs-lisp
(use-package rcirc-colo
  :after rcirc)
#+end_src

** Display IRC activity in window manager
   I have a toolbar in my window manager that lets me see things like
   CPU usage, memory, etc. So I thought it'd be useful to also display
   IRC activity. This just passes rcirc's activity string to a script
   that updates the toolbar.
#+BEGIN_SRC emacs-lisp
  (defun josh/rcirc-activity-report ()
    "Report rcirc activity to the window manager, which displays it"
    (start-process "LogTime"
                     (get-buffer-create " *josh-rcirc-buffer*")
                     "~/.sawfish/scripts/rcirc-update.sh"
                     rcirc-activity-string))

  (add-hook 'rcirc-update-activity-string-hook 'josh/rcirc-activity-report)
#+END_SRC
* Scheme
#+begin_src emacs-lisp
(setq scheme-program-name "csi")

(defun run-half-scheme () "
   Run Scheme in half a window."
   (interactive)
   (split-window-vertically nil)
   (other-window 1)
   (call-interactively 'run-scheme))

(add-hook 'scheme-mode-hook
 (lambda ()
   (define-key scheme-mode-map (kbd "C-c C-s") 'run-half-scheme)
   ))
#+end_src
* C
#+begin_src emacs-lisp
(setq-default c-basic-offset 8)
(setq c-default-style "gnu")
#+end_src
* Clojure

  CIDER is one of the best environments I've worked in. Give it (and
  Clojure) a try it you haven't already.

#+BEGIN_SRC emacs-lisp
(use-package cider
  :ensure t
  :mode (("\\.cljs\\'" . clojurescript-mode)
	 ("\\.cljc\\'" . clojurec-mode)
	 ("\\(?:build\\|profile\\)\\.boot\\'" . clojure-mode)
	 ("\\.\\(clj\\|dtm\\|edn\\)\\'" . clojure-mode))
  ;; :init
  ;; ;; Handy stuff for starting up figwheel
  ;; (setq cider-default-cljs-repl
  ;; 	"(do (require 'figwheel-sidecar.repl-api)
  ;;          (figwheel-sidecar.repl-api/start-figwheel!)
  ;;          (figwheel-sidecar.repl-api/cljs-repl))")
  :config
  (define-clojure-indent
    (defroutes 'defun)
    (GET 2)
    (POST 2)
    (PUT 2)
    (DELETE 2)
    (HEAD 2)
    (ANY 2)
    (OPTIONS 2)
    (PATCH 2)
    (rfn 2)
    (let-routes 1)
    (context 2))
  :hook ((clojure-mode . aggressive-indent-mode)))

(use-package aggressive-indent
  :ensure t
  :after cider)
#+END_SRC
** clj-refactor

   Some handy refactoring things for Clojure. A lot of it is already in Clojure-mode
#+BEGIN_SRC emacs-lisp
(defun clojure-refactor-hook-fn ()
  (clj-refactor-mode 1)
  (yas-minor-mode 1)
  (cljr-add-keybindings-with-prefix "C-c C-m"))

(use-package clj-refactor
  :ensure t
  :after cider
  :hook (clojure-mode . clojure-refactor-hook-fn))
#+END_SRC
** Running Clojure under a systemd cgroup
   Sometimes you may wan to run Clojure in a "sandbox" or
   cgroup. Systemd makes it easy to make transient cgroups with
   various resource limits. For example, you can limit memory usage
   and maximum number of processes, as well as preventing privilege
   escalation. This command just copies the command you'd need to run
   inside a sandbox to get an interactive REPL.
#+BEGIN_SRC emacs-lisp
(defun jmm/cider-params-cljs (params)
  "Generate the command needed to jack into a CLJS session.
PARAMS is the same as `cider-jack-in-cljs'."
  (let ((cider-jack-in-dependencies (append cider-jack-in-dependencies cider-jack-in-cljs-dependencies))
        (cider-jack-in-lein-plugins (append cider-jack-in-lein-plugins cider-jack-in-cljs-lein-plugins))
        (cider-jack-in-nrepl-middlewares (append cider-jack-in-nrepl-middlewares cider-jack-in-cljs-nrepl-middlewares))
        (orig-buffer (current-buffer)))
    ;; cider--update-jack-in-cmd relies indirectly on the above dynamic vars
    (thread-first params
      (cider--update-project-dir)
      (cider--update-jack-in-cmd))))

(defun jmm/cider-systemd-transient-service-cmd (params)
  "Make a systemd-run transient service for jacking in to Clojure.
This is mostly used to create an absolute limit on the amount of memory Clojure/Java can use.
PARAMS should be a plist with a :project-dir and :jack-in-cmd."
  (s-join " "
	  (list
	   "sudo systemd-run --uid `whoami` -G"
	   (format "--working-directory=%s"
		   (shell-quote-argument (expand-file-name (plist-get params :project-dir))))
	   ;; TODO: Add an informative description
	   ;; "-p Description=%s"
	   ;; TODO: Make an easier way to kill the service?
	   "--wait -t"
	   "-p NoNewPrivileges=true"
	   ;; Example of some types of hardening one might want to add
	   "-p PrivateDevices=true -p PrivateTmp=true -p RestrictSUIDSGID=true -p ProtectSystem=full"
	   ;; Shouldn't be possible, but set anyway
	   "-p ProtectHostname=true -p ProtectKernelTunables=true -p ProtectKernelModules=true -p ProtectControlGroups=true"
	   "-p PrivateUsers=true"
	   "-p CapabilityBoundingSet="
	   "-p RestrictNamespaces=true"
	   "-p RestrictAddressFamilies=\"AF_UNIX AF_INET AF_INET6\""
	   ;; Probably not necessary, but whatever
	   "-p LockPersonality=true -p RestrictRealtime=true -p SystemCallArchitectures=native"
	   "-p RemoveIPC=true"
	   ;; "-p SystemCallFilter=\"@system-service\"" ;Doesn't work?
	   "-p UMask=0077"
	   "-p InaccessiblePaths=\"$HOME/.ssh\""
	   "-p IPAddressDeny=any -p IPAddressAllow=localhost"
	   ;; TODO: Make the memory limit configurable. This
	   ;; is just an example.
	   "-p MemoryMax=1G -p MemoryHigh=512M"
	   "-p TasksMax=100"
	   ;; TODO: Add more environment variables through EnvironmentFile
	   "-E \"PATH=$PATH\""
	   (plist-get params :jack-in-cmd))))


(defun jmm/cider-systemd-cmd-cljs (params)
  "Like `cider-jack-in-cljs' but copies the command line needed
for a systemd-run transient service.
You'll need to manually connect the REPL afterwards."
  (interactive "P")
  (-> params
      (jmm/cider-params-cljs)
      (jmm/cider-systemd-transient-service-cmd)
      (kill-new)
      (message)))

(defun jmm/cider-systemd-cmd-clj (params)
  "Like `cider-jack-in-clj' but copies the command line needed
for a systemd-run transient service.
You'll need to manually connect the REPL afterwards."
  (interactive "P")
  (-> params
      (cider--update-project-dir)
      (cider--update-jack-in-cmd)
      (jmm/cider-systemd-transient-service-cmd)
      (kill-new)
      (message)))
#+END_SRC

* Shells
#+begin_src emacs-lisp
(defun run-half-shell ()
   "Run a shell in half a window."
   (interactive)
   (split-window-vertically nil)
   ;; (other-window 1)
   (shell (concat (buffer-name) " shell")))

(bind-key "C-x 4 s" 'run-half-shell)
#+end_src
** Shell pop
   [[https://github.com/kyagi/shell-pop-el][Shell pop]] is kinda handy for shells. I still mostly just use xterms
   (see the `start-xterm` function), but maybe I'll switch to `ansi-term` in Emacs.
#+BEGIN_SRC emacs-lisp
(use-package shell-pop
  :if window-system
  :unless noninteractive
  :ensure t
  :bind ("C-c t" . shell-pop)
  :init
  (setq shell-pop-shell-type '("ansi-term" "*ansi-term*"
			       (lambda ()
				 (ansi-term shell-pop-term-shell))))
  (setq shell-pop-universal-key "C-c t"))
#+END_SRC
** Eshell
#+BEGIN_SRC emacs-lisp
(use-package eshell
  :unless noninteractive
  :defer t
  :init
  (setq eshell-error-if-no-glob t
	eshell-hist-ignoredups t
	eshell-input-filter #'eshell-input-filter-initial-space
	eshell-history-size 10000
	eshell-last-dir-ring-size 500
	eshell-destroy-buffer-when-process-dies t)
  ;; TODO: Automatically load eshell-hist-ex
  ;; (add-to-list 'eshell-modules-list 'eshell-hist-ex)
  :config
  ;; Need to wait until eshell-hist-mode-map is defined.
  (bind-keys :package em-hist
	     :map eshell-hist-mode-map
	     ("<up>")
	     ("<down>"))
  (add-hook 'eshell-mode-hook
	    (lambda ()
	      ;; TODO: Don't rewrite aliases that already exist.
	      (jmm/eshell-maybe-add-alias "mpv" "mpv --no-terminal $*")
	      ;; Fast CD switching (although I usually use "M-D")
	      (jmm/eshell-maybe-add-alias "fd" "cd ${fasd -dl1 $*}")
	      ;; Switch to dired in the current directory. Or show files in dired.
	      (jmm/eshell-maybe-add-alias "d" "dired {default-val $* \".\"}")
	      (jmm/eshell-maybe-add-alias "dow" "dired-other-window {default-val $* \".\"}")
	      ;; Make it easy to switch to the project root
	      (jmm/eshell-maybe-add-alias "cdp" "cd ${projectile-project-root}")
	      ;; Easily make a directory and switch to it
	      (jmm/eshell-maybe-add-alias "mcd" "mkdir -p $1 && cd $1")
	      ;; Run "visual" commands without adding them to `eshell-visual-commands'
	      (jmm/eshell-maybe-add-alias "eev" "eshell-exec-visual")
	      ;; We want $PAGER to be "cat" ("less" messes up stuff for us. Especially with nix-env)
	      (make-local-variable 'process-environment)
	      (setenv "PAGER" "cat"))))

(defun jmm/eshell-maybe-add-alias (alias definition)
  "Define an ALIAS with DEFINITION if alias doens't exist.
See `eshell/alias'.
Mostly so we don't repeatedly write aliases."
  (unless (eshell-lookup-alias alias)
    (eshell/alias alias definition)))
#+END_SRC
*** Eshell prompt
    Makes the eshell prompt look nicer
#+BEGIN_SRC emacs-lisp
(use-package eshell-prompt-extras
  :ensure t
  :after (eshell)
  :config
  (with-eval-after-load "esh-opt"
    (autoload 'epe-theme-lambda "eshell-prompt-extras")
    (setq eshell-highlight-prompt nil
	  eshell-prompt-function 'epe-theme-lambda)))
#+END_SRC

*** Eshell facilities for clicking on ls files
    Modified from [[https://www.emacswiki.org/emacs/EshellEnhancedLS]].
    Allows for some nice features like clicking files (or navigating
    with avy) to add files to the input line.

    TODO: Files should have their paths stored, as clicking files
    becomes less useful after changing directories.
#+BEGIN_SRC emacs-lisp
(eval-after-load "em-ls"
  '(progn
     (require 'em-rebind)
     (defun jmm/eshell-ls-filename-at-point (point)
       (interactive "d")
       (get-text-property point 'ls-filename))

     (defun jmm/eshell-ls-filename-at-click (event)
       (interactive "e")
       (jmm/eshell-ls-filename-at-point (posn-point (event-end event))))

     (defun jmm/eshell-insert-text-as-argument (str)
       "Take in some string and add to Eshell prompt.
If the point isn't at the Eshell prompt, append to the end (with a separating space).
If the point is in the eshell prompt, insert at point.
Append it to the eshell prompt (if we're not at it), adding a space if necessary."
       (if (eshell-point-within-input-p (point))
	   (progn
	     (unless (looking-back "[[:space:]]")
	       (insert " "))
	     (insert (eshell-quote-argument str))
	     (unless (or (looking-at-p "[[:space:]]") (eobp))
	       (insert " ")))
	 (save-excursion
	   (goto-char (point-max))
	   (jmm/eshell-insert-text-as-argument str)))) ;; Hopefully this doesn't infinitely loop

     ;; (eshell-point-within-input-p (point))

     (defun jmm/eshell-ls-input-insert-filename-at-click (event)
       (interactive "e")
       (jmm/eshell-insert-text-as-argument
	(jmm/eshell-ls-filename-at-click event)))

     (defun jmm/eshell-ls-input-insert-filename-at-point (point)
       (interactive "d")
       (jmm/eshell-insert-text-as-argument
	(jmm/eshell-ls-filename-at-point point)))

     (defun jmm/eshell-find-filename-at-point (point)
       (interactive "d")
       (find-file (jmm/eshell-ls-filename-at-point point)))

     (defun jmm/eshell-find-filename-at-click (event)
       (interactive "e")
       (find-file (jmm/eshell-ls-filename-at-click event)))

     (defvar jmm/eshell-ls-keymap
       (let ((mymap (make-sparse-keymap)))
	 (define-key mymap (kbd "SPC") 'jmm/eshell-ls-input-insert-filename-at-point)
	 (define-key mymap (kbd "RET") 'jmm/eshell-find-filename-at-point)
	 (define-key mymap (kbd "<return>") 'jmm/eshell-find-filename-at-point)
	 (define-key mymap (kbd "<mouse-1>") 'jmm/eshell-ls-input-insert-filename-at-click)
	 (define-key mymap (kbd "<mouse-3>") 'jmm/eshell-find-filename-at-click)
	 mymap))

     ;; From https://www.emacswiki.org/emacs/EshellEnhancedLS
     ;; Modified from "ted-electrify-ls" slightly (like the help-echo string)
     (defadvice eshell-ls-decorated-name (after jmm-electrify-ls-modified activate)
       "Eshell's `ls' now lets you click or RET on file names to open them."
       (add-text-properties 0 (length ad-return-value)
			    (list 'help-echo "RET, mouse-3: visit this file\nSPC, mouse-1: Insert filename at input"
				  'mouse-face 'highlight
				  'ls-filename ad-return-value
				  'keymap jmm/eshell-ls-keymap)
			    ad-return-value)
       ad-return-value)))
#+END_SRC
*** Prompt history completing read and showing recent files
#+BEGIN_SRC emacs-lisp
(defun jmm/eshell-ls-recent ()
  "Show recent files with human readable file sizes."
  (interactive)
  (eshell-kill-input)
  (insert "ls -lahtr")
  (eshell-send-input))

(defun jmm/eshell-prompt-history ()
  "Prompt for some Eshell history."
  (interactive)
  (insert (ivy-read "History: "
		   (delete-dups (ring-elements eshell-history-ring)))))

;; TODO: Move this somewhere else
;; TODO: This seems to be binding globally
(with-eval-after-load 'esh-mode
  (progn
    (bind-key "M-L" #'jmm/eshell-ls-recent eshell-mode-map)
    (bind-key "C-c C-h" #'jmm/eshell-prompt-history eshell-mode-map)
    (bind-key "M-D" #'jmm/counsel-fasd-directories-eshell eshell-mode-map)
    (bind-key "M-F" #'jmm/counsel-files-in-directory-eshell eshell-mode-map)))
#+END_SRC
*** Ivy prompt for files or directories in the current directory
    This is a handy function that allows you to use Ivy to complete
    file names or directories in the current directory. I bind this to
    ~M-F~.

    Examples:
     - ~C-- M-F~ (negative arguments) only shows non-directory files
       in the current directory.
     - ~C-u M-F~ (positive universal argument) shows all files
       (including directories) in all subdirectories.
     - ~C- C-u M-F~ (negative argument with universal argument) shows
       all non-directory files in all subdirectories.

#+BEGIN_SRC emacs-lisp
;; TODO: Color broken symlinks differently.
;; Also possibly ignore git files.
(defvar jmm/counsel-files-in-directory-eshell nil
  "Holds the file history of `jmm/counsel-files-in-directory-eshell'")

;; TODO: Maybe implement this with `directory-files-recursively'
;; and `directory-files-and-attributes'
;; See https://stackoverflow.com/questions/26514437/emacs-sort-list-of-directories-files-by-modification-date
;; DONE: Eshell should probably also sort by most recent date if possible

(defun jmm/counsel-files-in-directory--candidates (&optional recursive? normal-files? project-root?)
  "Generate a command for `jmm/counsel-files-in-directory-eshell'.
Also for `jmm/counsel-files-in-directory'."
  (let* ((commandstr (->> (list find-program
				(if project-root? (projectile-ensure-project (projectile-project-root)) ".")
				"\\( -name .git \\) -prune -o"
				(when normal-files?
				  "\\( ! -type d \\)")
				(unless recursive?
				  "-maxdepth 1")
				"-printf '%T+\\t%p\\0'")
			  (-remove #'null)
			  (s-join " ")))
	 ;; TODO: Find a better way to get this to work remotely.
	 (shellstr (let ((shell-file-name (if (tramp-tramp-file-p default-directory)
					      (tramp-file-name-localname
					       (tramp-dissect-file-name (eshell-search-path "bash")))
					    shell-file-name)))
		     (shell-command-to-string commandstr)))
	 (cands (-as-> (split-string shellstr "\0" t) x
		       (sort x #'string>)
		       (--map (cadr (s-split-up-to "\t" it 1 t)) x))))
    cands))

(defun jmm/counsel-files-in-directory-eshell (arg &optional initial-input)
  "Prompt for a list of files in directory.
With optional numeric argument ARG, search directories recursively.
With negative argument ARG, exclude directories
INITIAL-INPUT can be given as the initial minibuffer input."
  (interactive "P")
  (ivy-read "Find file: " (jmm/counsel-files-in-directory--candidates (>= (abs (prefix-numeric-value arg)) 4)
								      (< (prefix-numeric-value arg) 0))
	    :initial-input initial-input
	    :history 'jmm/counsel-files-in-directory-history
	    :unwind #'counsel-delete-process
	    :action
	    '(1
	      ("e" jmm/eshell-insert-text-as-argument "insert eshell-escaped filename")
	      ("f" (lambda (file)
		     (with-ivy-window (find-file file))) "find file")
	      ("r" counsel-find-file-as-root "open as root")
	      ("d" counsel-locate-action-dired "dired"))
	    :caller 'jmm/counsel-files-in-directory-eshell))


#+END_SRC

*** Utility commands/functions
#+BEGIN_SRC emacs-lisp
(defun eshell/default-val (var default)
  "Returns VAR if non-nil, otherwise returns default.
I use this for `dired' so if no arguments are passed, it just
gets the dired of the current directory. "
  (eshell-echo (if var
		   (eshell/listify var)
		 (eshell/listify default)))
)
#+END_SRC

It's weird that I don't see an easy way to pipe buffer contents to
other programs. Perhaps this should be included by default. (Or maybe
rewrite "cat" to also allow for buffer arguments.)

#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'eshell
  (defun eshell/buffcat (&rest buffers)
    "Concatenate buffers. Use the flag -n to strip buffer text properties."
    (eshell-eval-using-options
     "buffcat" buffers
     '((?s "strip" nil strip "Remove text properties from buffers when printing.")
       (?n "newlines" nil newlines "Add trailing newlines to buffers without them.")
       (?h "help" nil nil "Output this help screen.")
       :preserve-args
       :usage "[-n] buffer...")
     (progn
       (if (null args)
	   (eshell-show-usage)
	 (mapconcat (lambda (buffer)
		      (with-current-buffer buffer
			(let ((str (if strip
				       (buffer-substring-no-properties (point-min) (point-max))
				     (buffer-string))))
			  (if newlines
			      (concat (s-chomp str) "\n")
			    str))))
		    args
		    ""))))))
#+END_SRC
**** CD to other buffer's default directory
     If you have a split screen, change to the default directory of the other window.
#+BEGIN_SRC emacs-lisp
;; TODO: Actually check that there is another window, otherwise maybe switch to the most recent buffer.
;; TODO: If the other buffer is a dired buffer, switch to whatever directory the point is at.
(with-eval-after-load 'eshell
  (defun eshell/cdo (&rest arguments)
    "Change directories to default directory of other window."
    (eshell-eval-using-options
     "cdo" arguments
     '((?h "help" nil nil "Output this help screen.")
       :preserve-args
       :usage ""
       :post-usage "Changes to the default-directory of the buffer in the other window")
     (progn
       (if (null args)
	   (if-let (other-dir (save-window-excursion
				(other-window 1)
				default-directory))
	       (eshell/cd other-dir)
	     (eshell-show-usage))
	 (eshell-show-usage))))))
#+END_SRC
**** CD to the git project root directory
     CD to a project's root (usually the one that has a "~.git~" file).
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'eshell
  (defun eshell/cdp (&rest arguments)
    "Change directories to project root of the default directory (Seeing if there's a .git file)."
    (eshell-eval-using-options
     "cdp" arguments
     '((?h "help" nil nil "Output this help screen.")
       :preserve-args
       :usage ""
       :post-usage "Change directories to git root of the default directory.")
     (progn
       (if (null args)
	   (if-let (other-dir (locate-dominating-file default-directory ".git"))
	       (eshell/cd other-dir)
	     (eshell-show-usage))
	 (eshell-show-usage))))))
#+END_SRC
**** Recursively CD to parent directory until a string matches
     
     Sometimes I'm in some deeply nested directory, like
     "~/home/jmm/foo/bar/baz/data/1/2/3/~" and I want to go back to
     "~bar~". This eshell command lets me type "~cdup bar~" to go back
     up to it.

#+BEGIN_SRC emacs-lisp
(defun jmm/parent-directory-matching (regexp directory)
  "Return a parent directory of DIRECTORY matching REGEXP."
  (let ((thedir directory))
    (while (progn
	     (let ((updir (file-name-directory
			   (directory-file-name thedir))))
	       (if (string= thedir updir)
		   ;; We can't go up anymore. Setting to nil will also break the loop
		   (setq thedir nil)
		 (setq thedir updir)
		 (not (string-match-p regexp (file-name-nondirectory
					      (directory-file-name thedir))))))))
    thedir))

(defun eshell/cdup (&rest arguments)
  "Recursively change directories up until the directory name matches a string."
  (eshell-eval-using-options
   "cdup" arguments
   '((?h "help" nil nil "Output this help screen.")
     :preserve-args
     :usage "[REGEXP]"
     :post-usage "Recursively change directories up until the directory name matches a string.")
   (progn
     (-if-let (newdir (jmm/parent-directory-matching
		       (if (null args)
			   ""
			 (car args))
		       default-directory))
	 (eshell/cd newdir)
       (error "Can't find a directory matching \"%s\"" (car args))))))
#+END_SRC


*** Git annex utilities
    Functions that make it easier to operate on git annex files
#+BEGIN_SRC emacs-lisp
(defun jmm/git-annex-find-files (&rest args)
  "Generate a list of git annex files that match ARGS.
For example, ARGS could be \"--in=here\""
  (-remove #'s-blank?
	   (s-split "\0"
		    (shell-command-to-string (mapconcat #'identity
							(append '("git annex find --print0") args)
							" ")))))
(defun eshell/dga (&rest args)
  "Show a `dired' buffer of git annex files that match ARGS.
For example, ARGS could be \"--in=here\""
  (dired (cons "." (apply #'jmm/git-annex-find-files args))))

(defun eshell/gaf (&rest args)
  "Return a list of git annex files that match ARGS.
For example, ARGS could be \"--in=here\""
  (apply #'jmm/git-annex-find-files args))
#+END_SRC
*** Dired ranger stuff
    It'd be handy to have quick access to the ~dired-ranger~ ring.
    
    You can use this like ~mpv ${dring}~ or ~ls ${dring}(Lm+20)~
    (lists files from the beginning of the ~dired-ranger-copy-ring~
    that are larger than 20 megabytes).
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'eshell
  (defun eshell/dring (&rest arguments)
    "Get the list of files in `dired-ranger-copy-ring'."
    (eshell-eval-using-options
     "dring" arguments
     '((?p "pop" nil pop "Pop the top of the dired-ranger-copy-ring.")
       (?e "element" t element "Get the specific element in the ring (instead of the default 0 [first] element).")
       (?h "help" nil nil "Output this help screen.")
       :preserve-args
       :usage "[-p] [-e index]")
     (progn
       (if args
	   (eshell-show-usage)
	 (let* ((idx (or element 0))
		(files (cdr (ring-ref dired-ranger-copy-ring idx))))
	   (when pop
	     (ring-remove dired-ranger-copy-ring idx))
	   files))))))

#+END_SRC
*** Add information about IP addresses to command outputs
    Add a hover tooltip to IP addresses so we can see where they're coming from, etc.
#+BEGIN_SRC emacs-lisp
;; There's a way to clean this up with rx, but I haven't gotten it quite right yet.
;; See https://francismurillo.github.io/2017-03-30-Exploring-Emacs-rx-Macro/
(defvar jmm/ip-address-regexp "\\(25[0-5]\\|2[0-4][0-9]\\|1[0-9][0-9]\\|[1-9][0-9]\\|[0-9]\\)\\.\\(25[0-5]\\|2[0-4][0-9]\\|1[0-9][0-9]\\|[1-9][0-9]\\|[0-9]\\)\\.\\(25[0-5]\\|2[0-4][0-9]\\|1[0-9][0-9]\\|[1-9][0-9]\\|[0-9]\\)\\.\\(25[0-5]\\|2[0-4][0-9]\\|1[0-9][0-9]\\|[1-9][0-9]\\|[0-9]\\)")

(defun jmm/get-ip-info (ipaddr)
  "Get info of IPADDR as a string."
  ;; Local default directory
  (let ((default-directory "~"))
    (s-trim-right (shell-command-to-string (format "geoiplookup %s" ipaddr)))))

(defun jmm/get-ip-info-for-tooltip (window object pos)
  "Hopefully OBJECT is a string"
  (if (bufferp object)
      (or (get-pos-property pos 'ipinfo object)
	  (let* ((ip (get-pos-property pos 'ip object))
		 (ipinfo (jmm/get-ip-info ip))
		 (startpos (previous-single-property-change pos 'ip))
		 (endpos (1- (next-single-property-change pos 'ip))))
	    (put-text-property startpos endpos 'ipinfo ipinfo)
	    ipinfo))))

(defun jmm/ip-address-add-props-to-itself (&optional match)
  "Add text properties to a match"
  (let ((match (or match 0)))
    (add-text-properties
     (match-beginning match) (match-end match)
     `(mouse-face highlight
       ip         ,(match-string-no-properties match)
       help-echo  jmm/get-ip-info-for-tooltip
       face ((:underline t))
       ))))

(defun jmm/eshell-handle-ip-addresses ()
  "Add tooltips to IP addresses"
  (save-excursion
    (goto-char eshell-last-output-block-begin)
    (unless (eolp)
      (beginning-of-line))
    (while (re-search-forward jmm/ip-address-regexp eshell-last-output-end t)
      (jmm/ip-address-add-props-to-itself))))

(with-eval-after-load 'esh-mode
  (add-to-list 'eshell-output-filter-functions 'jmm/eshell-handle-ip-addresses))

#+END_SRC

* Encryption and compression
#+begin_src emacs-lisp
(require 'epa-file)			;So we can encrypt authinfo
(setq epa-file-cache-passphrase-for-symmetric-encryption t) ;So it doesn't ask for password multiple times
#+end_src
  Put the following on the top of files to encrypt them to myself.
  May need to run "normal-mode" to set the file local variables.
  Also, remember that just because files are encrypted to you does not
  mean they're signed by you. So when encrypting stuff for yourself,
  you may want to sign it.
#+begin_src emacs-lisp
  (set-register ?G "-*- epa-file-encrypt-to: (\"j.moller-mara@berkeley.edu\") -*-\n")
#+end_src
** Add the ability to read/write Brotli compressed files
   Brotli is a fairly good tool for compressing text. I use it with some frequency.
   This code allows me to open files ending in "~.br~" as Brotli compressed files.
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'jka-cmpr-hook
  (add-to-list
   'jka-compr-compression-info-list
   ["\\.br\\'"
    "brotli compressing"   "brotli" ("-Z" "-c")
    "brotli uncompressing" "brotli" ("-c" "-d")
    nil t nil])

  ;; This is needed for the jka-compr-compression-info-list changes to take effect
  (jka-compr-update))
#+END_SRC

* BBDB
#+begin_src emacs-lisp
(use-package bbdb
  :defer t
  :config (progn
	    (bbdb-initialize 'gnus 'message)
	    (setq bbdb-use-pop-up nil)              ;Don't pop up
	    (setq bbdb-quiet-about-name-mismatches nil)))
#+end_src
* GNUS
  I don't really use GNUS much anymore. I used to use it for email,
  news groups (when CS classes at Berkeley had them before Piazza),
  and reading RSS feeds.
#+begin_src emacs-lisp
(setq mail-user-agent 'gnus-user-agent)	;Uses Message mode instead of mail mode
#+end_src
** Spoofing dates
#+begin_src emacs-lisp
(defun gnus-date-spoof ()
  (interactive)
  (message-generate-headers '(Date))
  (setq message-deletable-headers (delq 'Date message-deletable-headers))
  (message "Deletable headers are %s %s" message-deletable-headers "(DONT FORGET SMTPMAIL-FQDN)"))

(defun gnus-date-unspoof ()
  (interactive)
  (add-to-list 'message-deletable-headers 'Date)
  (message "Deletable headers are %s" message-deletable-headers))
#+end_src

** Kill IMAP
Sometimes IMAP freezes, so I like to be able to kill it.
#+begin_src emacs-lisp
(defun kill-imap ()
  "Kill openssl imap"
  (interactive)
  ;; (delete-process "imap")
  (mapc (lambda (x) (if (string-match "imap" (process-name x)) (delete-process x))) (process-list)))
#+end_src

** Espeak article
   Read an article out loud
#+begin_src emacs-lisp
(defun josh/espeak-article (&optional arg)
  "Select the gnus article and read it"
  (interactive "P")
  (with-current-buffer gnus-article-buffer
    (save-excursion
      (save-restriction
        (widen)
        (when (article-goto-body)
          (let* ((wpm (number-to-string (* (if arg arg 5) 100)))
                 (process (start-process "espeak-process" " *espeak-gnus*" "espeak" "-a" "200" "-v" "english-us" "-s" wpm)))
            (process-send-region process (point) (point-max))
            (process-send-string process "\n")
            (process-send-eof process)))))))

;; (bind-key "<f9> e" 'josh/espeak-article)
#+end_src

** Go to RSS link in browser
   This code basically gives me a hotkey ("v") that allows me to
   quickly open the link titled "link" in an external browser. This is
   pretty useful for RSS feeds when I'm interested in an article and
   want to read more.
#+BEGIN_SRC emacs-lisp
(defun josh/get-link-info-at-point ()
  "Return a cons of the link's text and url"
  (let* ((widget (widget-at (point)))
         (start (widget-get widget :from))
         (end (widget-get widget :to)))
    (cons (if start
              (buffer-substring-no-properties start end))
          (widget-get widget :value))))

(defun josh/get-all-links ()
  "Return a list of links in the buffer"
  (let (links)
    (save-excursion
      (goto-char (point-min))
      (while (progn
               (let ((skip (text-property-any (point) (point-max) 'help-echo nil)))
                 (if (or (eobp)
                         (not (setq skip (text-property-not-all skip (point-max)
                                                                'help-echo nil))))
                     nil
                   (progn
                     (goto-char skip)
                     (setq links (cons (josh/get-link-info-at-point) links)))))))
    links)))

(defun josh/gnus-follow-link ()
  "Find the link named \"link\" and follow it in the browser"
  (interactive)
  (with-current-buffer gnus-article-buffer
    (let ((link
           (-filter (lambda (x) (and (stringp (car x)) (string-match "link" (car x))))
                    (josh/get-all-links))))
      (if link
          (funcall shr-external-browser (cdar link))))))

(add-hook 'gnus-summary-mode-hook
          (lambda ()
            (local-set-key (kbd "v") 'josh/gnus-follow-link)))
#+END_SRC
* Dired
** Listing switches
#+begin_src emacs-lisp
(setq dired-listing-switches "-alhv")
#+end_src
** Other settings
   I usually want to copy recursively. Don't ask me each time.
#+BEGIN_SRC emacs-lisp
(setq dired-recursive-copies 'always)
(setq dired-copy-dereference t)
(setq dired-do-revert-buffer t)
#+END_SRC

  Apparently you can change permissions in ~wdired~
#+BEGIN_SRC emacs-lisp
(setq wdired-allow-to-change-permissions t)
#+END_SRC
** Dired-X
Because dired-jump is pretty useful
#+begin_src emacs-lisp
(use-package dired-x
  :init
  (setq dired-bind-jump nil)
  :defer 2
  :config
  (dolist (item '(".acn" ".acr" ".alg" ".bcf" ".glg" ".gls" ".ilg" ".ind" ".ist" ".run.xml" ".tdo"))
    (add-to-list 'dired-omit-extensions item)))
#+end_src
** Jump to dired buffer
   This is similar to ~dired-jump~, but it'll try to find the file in
   a dired buffer that's already open (most usefully when the file is
   listed in a subdirectory of a dired buffer). Otherwise it just
   calls ~~dired-jump~.
#+BEGIN_SRC emacs-lisp
(autoload 'get-buffers-matching-mode "helm-swoop")
(defun jmm/dired-jump (&optional killbuffer file)
  "Like `dired-jump', but prefer an already open dired that contains the parent directory as a subdir.
With optional argument KILLBUFFER, also kill the current buffer."
  (interactive "P")
  (let* ((old-buffer (current-buffer))
	 (file (or file buffer-file-name
		   (and (eq major-mode 'dired-mode) (directory-file-name (dired-current-directory)))
		   default-directory))
	 (dir (if file (file-name-directory file) default-directory))
	 ;; TODO: Sort this based on specificity or recency
	 (updir (car (-filter (lambda (buf)
				(with-current-buffer buf
				  (member dir (-map 'car dired-subdir-alist))))
			      (get-buffers-matching-mode 'dired-mode)))))
    ;; Make it easier to jump back
    (push-mark)
    (xref-push-marker-stack)
    (if updir
	(progn
	  (switch-to-buffer updir)
	  ;; This part's taken from dired-jump's definition in dired-x
	  (when file
	    (or (dired-goto-file file)
		;; If we didn't succeed (maybe the line was killed?)
		;; refresh and try again
		(progn
		  (dired-insert-subdir (file-name-directory file))
		  (dired-goto-file file))
		;; I've never used omitting, but it's here for completeness
		;; Toggle omitting, if it is on, and try again.
		(when dired-omit-mode
		  (dired-omit-mode)
		  (dired-goto-file file)))))
      (dired-jump nil file))
    (when killbuffer (kill-buffer old-buffer))))
(bind-key "C-x C-j" 'jmm/dired-jump)
#+END_SRC

** Copying remote file paths
   Sometimes I want to get the remote file path name, in order to make it easier to rsync and scp.
#+BEGIN_SRC emacs-lisp
(defun josh/dired-copy-remote-filename ()
  "Copy the file names of marked files in a way that's easy to
paste into a terminal. Hopefully understandable by rsync or scp."
  (interactive)
  (let ((string
         (mapconcat 'identity
                    (mapcar (lambda (path)
                              (if (tramp-tramp-file-p path)
                                  (let* ((dissect (tramp-dissect-file-name path))
                                         (user (tramp-file-name-user dissect))
                                         (host (tramp-file-name-host dissect))
                                         (loc (tramp-file-name-localname dissect)))
                                    (concat (if user (concat user "@")) host ":" "\"" (shell-quote-argument loc) "\"")
                                    )
                                (shell-quote-argument path)))
                            (dired-get-marked-files))
                    " ")))
    (kill-new string)
    (gui-set-selection 'PRIMARY string)   ;So I can middle click paste it into xterm
    (message "%s" string)))

;; (eval-after-load 'dired
;;                      '(define-key dired-mode-map (kbd "W") 'josh/dired-copy-remote-filename))
#+END_SRC

** Opening files with xdg-open

#+BEGIN_SRC emacs-lisp
    (defun xah-open-in-external-app ()
    "Open the current file or dired marked files in external app.
  The app is chosen from your OS's preference.

  URL `http://ergoemacs.org/emacs/emacs_dired_open_file_in_ext_apps.html'
  Version 2015-01-26"
    (interactive)
    (let* (
           (xah-file-list
            (if (string-equal major-mode "dired-mode")
                (dired-get-marked-files)
              (list (buffer-file-name))))
           (xah-do-it-p (if (<= (length xah-file-list) 5)
                         t
                       (y-or-n-p "Open more than 5 files? "))))

      (when xah-do-it-p
        (cond
         ((string-equal system-type "windows-nt")
          (mapc
           (lambda (fPath)
             (w32-shell-execute "open" (replace-regexp-in-string "/" "\\" fPath t t))) xah-file-list))
         ((string-equal system-type "darwin")
          (mapc
           (lambda (fPath) (shell-command (format "open \"%s\"" fPath)))  xah-file-list))
         ((string-equal system-type "gnu/linux")
          (mapc
           (lambda (fPath) (let ((process-connection-type nil)) (start-process "" nil "xdg-open" fPath))) xah-file-list))))))

    (add-hook 'dired-mode-hook '(lambda () 
                                  (local-set-key (kbd "E") 'xah-open-in-external-app)))
#+END_SRC

** Playing files with mpv
#+BEGIN_SRC emacs-lisp
(defvar jmm/mpv-program-alternates
  `(("mpvappendscrobble")
    ("mpv" "--audio-pitch-correction" ,(substitute-in-file-name "--input-ipc-server=$XDG_RUNTIME_DIR/mpvsocket")))
  "Different media players and arguments to pass to them")

(defun josh/open-with-mpv (arg)
  (interactive "P")
  (let* ((thefiles (dired-get-marked-files))
         (process-connection-type nil)
	 (argind (cond ((not arg) 0)
		   ((listp arg) (floor (log (car arg) 4)))
		   ((numberp arg) arg)
		   (t 0)))
	 (mpvprog (nth argind jmm/mpv-program-alternates)))
    (apply 'start-process "" nil (append mpvprog thefiles))
    (message (format "Played %i files" (length thefiles)))))

(add-hook 'dired-mode-hook '(lambda ()
                              (local-set-key (kbd "J") 'josh/open-with-mpv)))
#+END_SRC
** Show files in the File Manager

   Sometimes you want to view a file in a GUI file manager like
   GNOME's Nautilus or KDE's Dolphin. Maybe it's because it makes
   thumbnails easier to see, or it makes some operations (like
   dragging and dropping) easier to do.

#+begin_src emacs-lisp
(defun jmm/show-file-in-file-manager (filename)
  "Use org.freedesktop.FileManager1 to show files."
  (interactive (list (read-file-name "File: " nil nil nil (buffer-file-name))))
  (dbus-call-method :session "org.freedesktop.FileManager1"
		    "/org/freedesktop/FileManager1"
		    "org.freedesktop.FileManager1"
		    "ShowItems"
		    (list (xdg-thumb-uri filename)) ""))

(defun jmm/dired-show-files-in-file-manager ()
  "Show files with org.freedesktop.FileManager1."
  (interactive)
  (dbus-call-method :session "org.freedesktop.FileManager1"
		    "/org/freedesktop/FileManager1"
		    "org.freedesktop.FileManager1"
		    "ShowItems"
		    (mapcar #'xdg-thumb-uri
			    (dired-get-marked-files))
		    ;; I don't really know what StartupID is.
		    ""))

(eval-after-load 'dired
  '(bind-key "M-N" #'jmm/dired-show-files-in-file-manager dired-mode-map))
#+end_src

** Show File Manager in Dired

   Sometimes you want to go the other way around and quickly open
   whatever Nautilus is viewing in Dired.

#+begin_src emacs-lisp
(defun jmm/file-manager-mark-copied-files ()
  "Get a list of copied files in the clipboard. Mark them in dired."
  (interactive)
  (let ((selected-files (->> (pgtk-get-selection-internal 'CLIPBOARD 'STRING)
			  (s-split "\n")
			  ;; This is a weird hack to unescape unicode
			  ;; TODO: Find a better way to unescape unicode
			  (mapcar (lambda (s) (json-read-from-string (format "\"%s\"" s))))
			  )))
    (dired-mark-if
     (-contains? selected-files (dired-get-filename nil t))
     "copied file")))

(defun jmm/file-manager-get-filename ()
  "Get the (first) location the FileManager is currently viewing."
  (->
      (dbus-get-property :session "org.freedesktop.FileManager1"
			 "/org/freedesktop/FileManager1"
			 "org.freedesktop.FileManager1"
			 "OpenLocations")
    ;; TODO: Handle multiple open locations
    (car)
    ;; TODO: Handle other open locations like WebDAV, Google Drive, etc
    (url-generic-parse-url)
    (url-filename)))

(defun jmm/file-manager-to-dired (showcopied)
  "Open the location the FileManager is currently viewing in Dired.
With SHOWCOPIED, mark files that are in the clipboard."
  (interactive "P")
  (dired (jmm/file-manager-get-filename))
  (when showcopied
    (jmm/file-manager-mark-copied-files)))

(bind-key "<f9> n" #'jmm/file-manager-to-dired)
#+end_src


** git-annex
   I'm messing around with git-annex, and it's nice to be able to view
   locked files by their name and not as a giant symlink in dired.
#+BEGIN_SRC emacs-lisp
(use-package git-annex
  :ensure t
  :defer 2
  :config
  (git-annex-dired-do-to-files "lock" "Annex: locked %d file(s)")
  (git-annex-dired-do-to-files "unlock" "Annex: unlocked %d file(s)")
  (bind-keys :map git-annex-dired-map
	     ("l" . git-annex-dired-lock-files)
	     ("u" . git-annex-dired-unlock-files)
	     ("t" . jmm/dired-git-annex-tag)
	     ("s" . jmm/dired-git-annex-print-human-file-size)
	     ("S" . jmm/dired-git-annex-add-real-file-sizes)
	     ("b" . jmm/git-annex-browse-url)
	     ("*")
	     ("* a" . jmm/dired-mark-git-annex-available-files)
	     ("* u" . jmm/dired-mark-git-annex-unavailable-files))
  ;; git-annex.el kinda clobbers dired-marked-face and dired-flagged-face
  ;; This fixes that
  (progn
    (add-to-list 'dired-font-lock-keywords
		 (list "^[*].+ -> .*\\.git/annex/"
		       '("\\(.+\\)\\( -> .+\\)" (dired-move-to-filename) nil
			 (1 dired-marked-face)
			 (2 git-annex-dired-annexed-invisible))))
    (add-to-list 'dired-font-lock-keywords
		 (list "^[D].+ -> .*\\.git/annex/"
		       '("\\(.+\\)\\( -> .+\\)" (dired-move-to-filename) nil
			 (1 dired-flagged-face)
			 (2 git-annex-dired-annexed-invisible)))))
  :after (dired))
#+END_SRC
*** Make it easy to add metadata tags in git-annex

    Git-annex has a pretty cool ability to tag files and filter
    directory views based on metadata. It's kind of a pain to tag
    files, though, so here's a function that adds some autocompletion
    to tagging files.

#+BEGIN_SRC emacs-lisp
(defvar-local jmm/git-annex-directory-tags nil
  "Current git-annex tags set in the directory, as a list.")

(defun jmm/dired-git-annex-current-tags (file-list &optional intersection)
  "Get current git-annex tag for each file in FILE-LIST. With
  optional argument INTERSECTION, only show tags all files share in common."
  (let* ((metadata (with-output-to-string
		    (with-current-buffer
			standard-output
		      (apply #'process-file "git" nil t nil "annex" "metadata" "--json" file-list))))
	 (json-array-type 'list)
	 (jsonout (-map 'json-read-from-string (split-string metadata "\n" t))))
    (-reduce (if intersection '-intersection '-union) (--map (cdr (assoc 'tag (cdr (assoc 'fields it)))) jsonout))))

(defun jmm/dired-git-annex-tag (file-list tags &optional arg)
  "Add git-annex TAGS to each file in FILE-LIST.
Used as an interactive command, prompt for a list of tags for all
files, showing the current tags all files currently have in common."
  (interactive
   (let* ((files (dired-get-marked-files t current-prefix-arg))
	  (shared-tags (jmm/dired-git-annex-current-tags files t))
	  ;; Cache directory tags
	  (current-tags (or jmm/git-annex-directory-tags
			    (setq jmm/git-annex-directory-tags
				  (or (jmm/dired-git-annex-current-tags '("--all")) '("")))))
	  (crm-separator " ")
	  (crm-local-completion-map
	   (let ((map (make-sparse-keymap)))
	     (set-keymap-parent map crm-local-completion-map)
	     (define-key map " " 'self-insert-command)
	     map))
	  (tags (completing-read-multiple
		 "Tags: " (--map (concat it crm-separator) current-tags)
		 nil nil
		 (when shared-tags (mapconcat 'identity shared-tags " ")))))
     (setq jmm/git-annex-directory-tags (-union tags jmm/git-annex-directory-tags))
     (list files tags current-prefix-arg)))
  (let ((args (cl-loop for x in tags
		       append (list "-t" x))))
    (-each file-list
      (lambda (file)
	(apply #'call-process "git" nil nil nil "annex" "metadata" (append args (list file)))))
    (message (format "Tagged %d file(s)" (length file-list)))))
#+END_SRC
*** Mark unavailable files

    Add a function that marks unavailable files.

    When you use this in combination with ~dired-do-kill-lines~ (by
    default bound to ~k~), it's easy to hide files that aren't present
    in the current annex repository.

#+BEGIN_SRC emacs-lisp
(defun jmm/dired-mark-git-annex-unavailable-files ()
  "Mark git-annex files that are not present."
  (interactive)
  (dired-mark-if
   (and (looking-at-p ".* -> \\(.*\\.git/annex/.+\\)")
	(not (file-exists-p (file-truename (dired-get-filename t)))))
   "unavailable file"))

(defun jmm/dired-mark-git-annex-available-files ()
  "Mark git-annex files that are present."
  (interactive)
  (dired-mark-if
   (and (looking-at-p ".* -> \\(.*\\.git/annex/.+\\)")
	(file-exists-p (file-truename (dired-get-filename t))))
   "available file"))
#+END_SRC
*** Mark git-annex files with git-annex-matching-options

    This command makes it easy to mark dired files using ~git-annex-matching-options~.

    For instance, you could find files that are in a certain remote
    using ~--in=remote~ or mark/unmark files that have a certain tag
    using ~--metadata tag=sometag~.

#+BEGIN_SRC emacs-lisp
(defun jmm/dired-mark-files-git-annex-matching (matchingoptions &optional marker-char)
  "Mark all files that match git annex's MATCHINGOPTIONS for use in later commands.
A prefix argument means to unmark them instead.
`.' and `..' are never marked."
  (interactive
   (list (read-string (concat (if current-prefix-arg "Unmark" "Mark")
                              " files matching (git annex match expression): ")
                      nil 'jmm-dired-annex-matchingoptions-history)
	 (if current-prefix-arg ?\040)))
  (let ((dired-marker-char (or marker-char dired-marker-char)))
    (dired-mark-if
     (and (not (looking-at-p dired-re-dot))
	  (not (eolp))			; empty line
	  (let ((fn (dired-get-filename nil t)))
	    (when (and fn (not (file-directory-p fn)))
	      (message "Checking %s" fn)
	      (s-present? (shell-command-to-string
			   (mapconcat
			    #'identity
			    (list "git annex find" matchingoptions (shell-quote-argument fn))
			    " "))))))
     "matching file")))

(eval-after-load 'dired
  '(bind-key "% a" #'jmm/dired-mark-files-git-annex-matching dired-mode-map))
#+END_SRC
*** Get git-annex file sizes
    Unfortunately, ~dired~ only shows symlink file size (as far as I
    can tell), which isn't really helpful when using git-annex.
    
    This function is a first pass at determining git-annex file
    sizes. I have ~@ s~ bound to
    ~jmm/dired-git-annex-print-human-file-size~, which will tell me
    the human readable file size of the git-annex file at point.
#+BEGIN_SRC emacs-lisp
(defun jmm/git-annex-file-target (filename)
  "If FILENAME is a git annex file, return its symlink target."
  (-when-let (symname (and filename
			   (file-symlink-p filename)))
    (when (string-match-p ".*\\.git/annex/.+" symname)
      symname)))

(defun jmm/dired-git-annex-file-target ()
  "If the dired file at point is a git annex file, return its symlink target."
  (jmm/git-annex-file-target (dired-get-filename nil t)))

(defun jmm/git-annex-file-size (filename)
  "Try to determine the size of the git annex file FILENAME."
  (-when-let (target (jmm/git-annex-file-target filename))
    (or (save-match-data
	  (when (string-match "SHA256E-s\\([0-9]+\\)--" target)
	    (string-to-number (match-string 1 target))))
	(-some-> (expand-file-name target (file-name-directory filename))
		 file-attributes
		 file-attribute-size))))

(defun jmm/dired-git-annex-print-human-file-size ()
  "Try to print the human readable file size of the dired git-annex file at point."
  (interactive)
  (let* ((filename (dired-get-filename nil t))
	 (string-file (file-name-nondirectory filename)))
    (-if-let (filesize (-some-> (jmm/git-annex-file-size filename)
				file-size-human-readable))
	(message "%s - %s" filesize string-file)
      (message "Can't determine git annex file size of %s" string-file))))
#+END_SRC
*** Show git-annex file sizes in dired
    Okay, I found a way to replace the symlink sizes of git-annex with
    the real sizes in ~dired~. Finally.

    This function does just that, it goes through all git annex files,
    replaces the file size with the actual file size (if it can
    determine it), and then aligns everything. Should work for
    subdirectories too. I'm binding this to ~@ S~, but theoretically
    you could add it to a hook if you wanted.

#+BEGIN_SRC emacs-lisp
;; Based off of `dired--align-all-files'
(defun jmm/dired-git-annex-add-real-file-sizes ()
  "Go through all the git-annex files in dired, replace the
symlink file size with the real file size, then try to align
everything."
  (interactive)
  (require 'dired-aux)
  (let ((regexp directory-listing-before-filename-regexp))
    (save-excursion
      (goto-char (point-min))
      (dired-goto-next-file)
      (while (or (dired-move-to-filename)
		 (progn (save-restriction
			  (narrow-to-region (dired-subdir-min) (dired-subdir-max))
			  (dired--align-all-files))
			(dired-next-subdir 1 t)
			(dired-goto-next-file)
			(dired-move-to-filename)))
	(let ((inhibit-read-only t))
	  (when (and (jmm/dired-git-annex-file-target)
		     (re-search-backward regexp (line-beginning-position) t))
	    (goto-char (match-beginning 0))
	    (-when-let (newsize (-some-> (jmm/git-annex-file-size (dired-get-filename nil t))
					 file-size-human-readable))
	      (search-backward-regexp "[[:space:]]" nil t)
	      (when (re-search-forward "[[:space:]]+\\([^[:space:]]+\\)[[:space:]]" nil t)
		(goto-char (match-beginning 1))
		(delete-region (point) (match-end 1))
		(insert-and-inherit newsize))))
	  (forward-line))))))

;; (add-hook 'dired-mode-hook #'jmm/dired-git-annex-add-real-file-sizes)
;; (add-hook 'dired-after-readin-hook #'jmm/dired-git-annex-add-real-file-sizes)



#+END_SRC
*** Browsing URLs for git-annex files
    
    Many times I have git-annex files that are dropped in the local
    repository, but still exist on the web. Sometimes, I'd like to
    browse these URLs directly, rather than waiting for the ~get~
    operation to complete on the file and then opening it.

#+BEGIN_SRC emacs-lisp
;; TODO: Process multiple files at once?
(defun jmm/git-annex-whereis-info (filename)
  "Get information about where a git-annex file exists.
Returns a parsed json list from whereis."
  (let* ((json-array-type 'list)
	 (whereisdata (shell-command-to-string
		       (mapconcat
			#'identity
			(list "git annex whereis --json" (shell-quote-argument filename))
			" "))))
    (when (s-present? whereisdata)
      (json-read-from-string whereisdata))))

(defun jmm/git-annex-urls (filename)
  "Get the git-annex web urls for FILENAME."
  (-some->> (jmm/git-annex-whereis-info filename)
	    (assoc-default 'whereis)
	    (-mapcat (lambda (x) (assoc-default 'urls x)))
	    (-map (lambda (s) (s-chop-prefix "yt:" s)))))

(defun jmm/git-annex-browse-url ()
  "Browse the first git-annex web urls for file at point."
  (interactive)
  (let* ((filename (dired-get-filename nil t))
	 (filestr (file-name-nondirectory filename)))
    (-if-let (url (car (jmm/git-annex-urls filename)))
	(progn
	  (message "Opening url: %s" url)
	  (jmm/org-open-link-alternate-browser #'browse-url url))
      (user-error "No url found for %s" filestr))))
#+END_SRC
*** Sort dired by file size

    "Wait", you may ask, "can't you already sort dired just by
    pressing ~s~"? Yeah, but that doesn't take into account git-annex
    file sizes. This function does.

    In the future this general sorting mechanism (sorting the lines
    instead of just reverting the dired buffer) will probably be
    useful for other stuff (maybe sort by last time a file was
    modified in a git commit, or by number of git-annex copies).
#+BEGIN_SRC emacs-lisp
(defun jmm/dired-dir-files-beginning ()
  "First point where there's a filename on the line. Beginning of line."
  (save-excursion
    (goto-char (dired-subdir-min))
    (dired-goto-next-file)
    (beginning-of-line)
    (point)))

(defun jmm/dired-dir-files-end ()
  "Last point where there's a filename. End of line."
  (save-excursion
    (goto-char (dired-subdir-max))
    (while (not (dired-get-filename nil t))
      (dired-previous-line nil))
    (end-of-line)
    (point)))

(defun jmm/dired-file-size ()
  "Return the file size of a file at point (for sorting). Takes
into account git-annex files."
  (let* ((filename (dired-get-filename nil t))
	 (string-file (file-name-nondirectory filename)))
    (or (jmm/git-annex-file-size filename)
	(file-attribute-size (file-attributes filename)))))

;; TODO: Should just try to directly use the field listed.
(defun jmm/dired-sort-size (&optional ascending)
  "Sort some dired lines by size (consider annex sizes).
With optional argument ASCENDING, sort by ascending file size. (I
like going the other way around usually.)"
  (interactive "P")
  (let (buffer-read-only
	(beg (jmm/dired-dir-files-beginning))
	(end (jmm/dired-dir-files-end)))
    (save-excursion
      (save-restriction
	(narrow-to-region beg end)
	(goto-char (point-min))
	(sort-subr (not ascending)
		   'forward-line 'end-of-line
		   #'jmm/dired-file-size nil)))))
#+END_SRC

** Dired ranger
   dired-ranger (see [[https://github.com/Fuco1/dired-hacks][dired-hacks]]) adds some really convenient ways to
   copy and paste files between buffers. It's a lot easier than
   hitting ~C~ and scrolling through your find-file history looking
   for the right path to copy to.

#+BEGIN_SRC emacs-lisp
(use-package dired-ranger
  :after (dired)
  :ensure t
  :bind (:map dired-mode-map
	      ("[" . dired-ranger-copy)
	      ("]")
	      ("] c" . dired-ranger-paste)
	      ("] h" . jmm/dired-ranger-hardlink)
	      ("] s" . jmm/dired-ranger-symlink)
	      ("] r" . jmm/dired-ranger-relsymlink)
	      ("] m" . dired-ranger-move)
	      ("{")
	      ("{ d" . jmm/latest-download-to-ranger)))
#+END_SRC
*** Add more actions for dired ranger

    Sometimes I want to do things other than copy or move
    files. Sometimes I'd like to symlink, relative symlink, or
    hardlink files. These functions make that easier to do.

#+BEGIN_SRC emacs-lisp
(defmacro jmm/make-dired-ranger-action (newfuncname actionname functiontocall char)
  "Make dired-ranger paste commands, but for other things like
symlink, hardlink, relsymlink, etc."
  `(defun ,newfuncname (arg)
     ,(format "%s the items from copy ring to current directory.

With raw prefix argument \\[universal-argument], do not remove
the selection from the stack so it can be copied again.

With numeric prefix argument, %s the n-th selection from the
copy ring." (s-capitalize actionname) (s-downcase actionname))
     (interactive "P")
     (let* ((index (if (numberp arg) arg 0))
	    (data (ring-ref dired-ranger-copy-ring index))
	    (files (cdr data))
	    (target-directory (dired-current-directory))
	    (pasted-files 0))
       (--each files (when (file-exists-p it)
		       (,functiontocall it target-directory)
		       (cl-incf pasted-files)))
       (dired-ranger--revert-target ,char target-directory files)
       (unless arg (ring-remove dired-ranger-copy-ring 0))
       (message (format ,(format "%sed %%d/%%d item%%s from copy ring." (s-capitalize actionname))
			pasted-files
			(length files)
			(if (> (length files) 1) "s" ""))))))

(jmm/make-dired-ranger-action jmm/dired-ranger-hardlink "Hardlink" dired-hardlink ?H)
(jmm/make-dired-ranger-action jmm/dired-ranger-symlink "Symlink" make-symbolic-link ?S)
(jmm/make-dired-ranger-action jmm/dired-ranger-relsymlink "Relsymlink" dired-make-relative-symlink ?R)
#+END_SRC
*** Make it easy to copy a recent download
    When I download things from my browser, it usually just gets
    dumped in my "~/Downloads" directory. Often I want to move or copy
    it somewhere else, but I prefer to do that in Emacs instead of the
    browser dialog box. This function makes it easy to add a file to
    ~dired-ranger~'s copy ring.
#+BEGIN_SRC emacs-lisp
(defcustom jmm/downloads-directory "~/Downloads"
  "Directory where downloads are usually stored."
  :type 'directory)

(defun jmm/latest-download-to-ranger ()
  "Add the latest file in `jmm/downloads-directory' to dired-ranger's copy ring.
Like `dired-ranger-copy' but I don't have to manually select the latest download."
  (interactive)
  (let ((latest-file (josh/latest-file jmm/downloads-directory "[:alpha:]")))
    (ring-insert
     dired-ranger-copy-ring
     (cons (list (dired-noselect jmm/downloads-directory)) (list latest-file)))
    (message (format "Copied %s into copy ring." latest-file))))
#+END_SRC
** Finding files in subdirectories with ivy/counsel
   Makes it easier to navigate project and find files with certain names.
#+BEGIN_SRC emacs-lisp
(defvar jmm/counsel-files-in-directory-history
  nil
  "Holds the file history of `jmm/counsel-files-in-directory'")

(defun jmm/counsel-action-jmm-dired-jump (x)
  "Use `jmm/dired-jump' on X."
  (jmm/dired-jump nil (expand-file-name x)))

(defun jmm/counsel-action-dired-ranger-copy (x)
  "Use `jmm/dired-jump' on X."
  (with-ivy-window
    (save-excursion
      (let ((file (expand-file-name x)))
	(jmm/dired-jump nil file)
	(ring-insert
	 dired-ranger-copy-ring
	 (cons (list (current-buffer)) (list file)))
	(message (format "Copied %s into copy ring." file))))))

(defun jmm/counsel-files-in-directory (arg &optional initial-input)
  "Prompt for a list of files in directory.
With optional numeric argument ARG, search from the project root.
With negative argument ARG, exclude directories
INITIAL-INPUT can be given as the initial minibuffer input."
  (interactive "P")
  (ivy-read "Find file: " (jmm/counsel-files-in-directory--candidates t
								      (not (< (prefix-numeric-value arg) 0))
								      (>= (abs (prefix-numeric-value arg)) 4))
	    :initial-input initial-input
	    :unwind #'counsel-delete-process
	    :action
	    '(1
	      ("f" (lambda (file)
		     (with-ivy-window (find-file file))) "find file")
	      ("j" jmm/mpv-scrobble-file "scrobblempv")
	      ("r" counsel-find-file-as-root "open as root")
	      ("d" jmm/counsel-action-jmm-dired-jump "dired")
	      ("[" jmm/counsel-action-dired-ranger-copy "dired ranger copy"))
	    :caller 'jmm/counsel-files-in-directory))
;; (bind-key "M-F" #'jmm/counsel-files-in-directory dired-mode-map)
#+END_SRC
** Change the "yes", "no", "all", or "quit" prompt to take a single character

I've aliased ~yes-or-no-p~ to be ~y-or-n-p~. This is nice because it
means I don't have to repeatedly type "yes". This used to work for
~dired~, but eventually it was changed to use
~dired--yes-no-all-quit-help~ when recursively deleting directories.

This function goes back to a single character response prompt.

#+BEGIN_SRC emacs-lisp
(defun jmm/dired--y-n-a-q-h (prompt &optional help-msg)
  "Ask a question with valid answers: (y)es, (n)o, (a)ll, (q)uit, (h)elp.
PROMPT must end with '? ', for instance, 'Delete it? '.
If optional arg HELP-MSG is non-nil, then is a message to show when
the user answers 'help'.  Otherwise, default to `dired-delete-help'."
  (let ((valid-answers (list ?y ?n ?a ?q))
	(answer-plist '(?y "yes" ?n "no" ?a "all" ?q "quit"))
        (answer "")
        (input-fn (lambda ()
                    (read-char
	             (format "%s [(y)es, (n)o, (a)ll, (q)uit, (h)elp] " prompt)))))
    (setq answer (funcall input-fn))
    (when (= answer ?h)
      (with-help-window "*Help*"
        (with-current-buffer "*Help*"
          (insert (or help-msg dired-delete-help)))))
    (while (not (member answer valid-answers))
      (unless (= answer ?h)
        (beep)
        (message "Please answer `(y)es' or `(n)o' or `(a)ll' or `(q)uit'")
        (sleep-for 2))
      (setq answer (funcall input-fn)))
    (plist-get answer-plist answer)))

(fset 'dired--yes-no-all-quit-help 'jmm/dired--y-n-a-q-h)
#+END_SRC
* Emacs lisp

#+begin_src emacs-lisp
(add-hook 'emacs-lisp-mode-hook 'rainbow-mode)
(bind-keys :package elisp-mode
	   :map emacs-lisp-mode-map
	   ("C-c C-m" . pp-macroexpand-last-sexp))
#+end_src


* Tramp
#+begin_src emacs-lisp
;; (eval-when-compile
;;   (require 'tramp))
#+end_src
** Proxies. Allow sudo
#+begin_src emacs-lisp
;; (set-default 'tramp-default-proxies-alist nil)
;; (add-to-list 'tramp-default-proxies-alist '((and (string-match system-name (tramp-file-name-host (car target-alist))) "DONTMATCHMEPLEASE") "\\`root\\'" "/ssh:%h:"))
#+end_src
** Speedups for TRAMP
   See suggestions in the TRAMP FAQ.

#+begin_src emacs-lisp
(setq vc-ignore-dir-regexp
      (format "\\(%s\\)\\|\\(%s\\)"
              vc-ignore-dir-regexp
              tramp-file-name-regexp))

;; I'm not really using SVN anymore
(setq vc-handled-backends '(Git))

;; TODO: Don't know if this is a reasonable value. I'm caching for 5
;; minutes. Maybe I should make this depend on the hosts I'm checking.
(setq remote-file-name-inhibit-cache 300)
#+end_src


** Kill Tramp buffers
   Sometimes, having Tramp buffers open will weirdly cause other Emacs
   functions to fail or load slowly. For example, if you've got a
   bunch of remote Tramp buffers open, using helm sometimes slows
   down, or sometimes using magit fails. I'm not sure why. Often I'd
   just like to kill all remote buffers so I don't have to wait for
   connections to be brought back up again. This function does that.
#+BEGIN_SRC emacs-lisp
  (defun josh/kill-tramp-buffers ()
    "Kill TRAMP buffers. This is useful if, for whatever reason, remote buffers are either slowing down emacs or making some commands act strangely."
    (interactive)
    (let ((i 0))
      (mapc (lambda (buff)
              (with-current-buffer buff
                (when (tramp-tramp-file-p default-directory)
                  (kill-buffer buff)
                  (setq i (1+ i)))))
            (buffer-list))
      (message (format "Killed %d buffer%s" i (if (eq i 1) "" "s")))))

  (bind-key "<f9> t" 'josh/kill-tramp-buffers)
#+END_SRC
** Get the remote path for TRAMP
   
   Sometimes I notice TRAMP having issues detecting the ~PATH~
   environment on NixOS. This should hopefully help with that.
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'tramp-sh
  ;; This is the part necessary for Nix
  (add-to-list 'tramp-remote-path 'tramp-own-remote-path)

  ;; This should be in there anyway
  (add-to-list 'tramp-remote-path 'tramp-default-remote-path))
#+END_SRC
** Dereference symlinks when copying with rsync

   It took me way too long to find out that TRAMP had an "rsync"
   method! All this time I've been waiting for it to do the default
   thing of piping stuff through ~base64~ and ~gzip~.

   Anyway, one issue I have with the rsync method is that copying
   symlinks doesn't work in the same way as when you use ~ssh~. That
   is, symlinks aren't dereferenced. I have a lot of symlinks since I
   use ~git-annex~ a lot, so I need to be able to copy the /file the
   symlink points to/ rather than just the /symlink itself/ (which
   fails). This modifies the ~rsync~ TRAMP method to add the "-L"
   argument to rsync to dereference links.

#+BEGIN_SRC emacs-lisp
(defun jmm/tramp-rsync-allow-dereference-symlinks ()
  "Add \"-L\" to rsync's copy arguments in `tramp-methods'"
  (let* ((rsync-args-pair (assoc 'tramp-copy-args (assoc-default "rsync" tramp-methods))))
    (cl-pushnew '("-L") (cadr rsync-args-pair) :test 'equal)))

;; Seems like both tramp-loaddefs and tramp-sh write tramp-methods. So
;; we have to load this after both.
(eval-after-load 'tramp-loaddefs
  '(jmm/tramp-rsync-allow-dereference-symlinks))
(eval-after-load 'tramp-sh
  '(jmm/tramp-rsync-allow-dereference-symlinks))
#+END_SRC
** Utilities to add/remove Tramp hops (e.g. for "sudo")

   These functions make it easier for me to find files with and
   without "sudo". They basically just construct TRAMP file names,
   adding hops where appropriate. I use this for my own version of
   ~counsel-find-file-as-root~, which doesn't work with remote files.

   Note, this won't work with some methods that don't chain
   particularly well. For example if you had ~/rsync:host:/some/file~,
   the resulting ~/rsync:host|sudo:host:/some/file~ doesn't seem to work for me.

#+BEGIN_SRC emacs-lisp
(defun jmm/tramp-vec-to-hop (vec)
  "Take in a Tramp VEC (as with `tramp-dissect-file-name') and output a hop."
  (let ((method (tramp-file-name-method vec))
	(user (tramp-file-name-user vec))
	(domain (tramp-file-name-domain vec))
	(host (tramp-file-name-host vec))
	(port (tramp-file-name-port vec))
	(hop (tramp-file-name-hop vec)))
    (->> (tramp-make-tramp-file-name method user domain host port nil hop)
	 (replace-regexp-in-string (concat "^" tramp-prefix-format) "")
	 (replace-regexp-in-string (concat tramp-postfix-host-format "$") tramp-postfix-hop-format))))


(defun jmm/tramp-add-sudo-method (file)
  "Add a sudo method to a file.
This should be idempotent (i.e. won't add sudo to a file that already has sudo.)"
  (if (tramp-tramp-file-p file)
      (let ((newhop (jmm/tramp-vec-to-hop (tramp-dissect-file-name file))))
	(with-parsed-tramp-file-name file v1
	  (if (string= v1-method "sudo")
	      file ;; Don't add sudo redundantly
	    (tramp-make-tramp-file-name
	     "sudo" v1-user v1-domain v1-host v1-port v1-localname newhop))))
    (tramp-make-tramp-file-name
     "sudo" nil nil nil nil file nil)))

(defun jmm/tramp-remove-final-method (file)
  "Remove the destination of the last hop."
  (if (tramp-tramp-file-p file)
      (with-parsed-tramp-file-name file v1
	(if v1-hop
	    (let ((hop-file-name (concat
				  tramp-prefix-format
				  (replace-regexp-in-string
				   (concat tramp-postfix-hop-regexp "$")
				   tramp-postfix-host-format v1-hop))))
	      (with-parsed-tramp-file-name hop-file-name v2
		(tramp-make-tramp-file-name v2-method v2-user v2-domain v2-host v2-port v1-localname v2-hop)))
	  v1-localname))
    file))

(defun jmm/tramp-is-sudo-p (file)
  "If this FILE being accessed with sudo?"
  (and (tramp-tramp-file-p file)
       (with-parsed-tramp-file-name file v1
	 (string= v1-method "sudo"))))

(defun jmm/tramp-toggle-sudo-file (file)
  "If FILE is being accessed with sudo, return the same path that isn't.
If it isn't being accessed with sudo, return the same path that is."
  (if (jmm/tramp-is-sudo-p file)
      (jmm/tramp-remove-final-method file)
    (jmm/tramp-add-sudo-method file)))
#+END_SRC

* Notmuch
  Notmuch is an email interface I started using to replace Gnus. It's
  got a couple of main selling points. First is that things are
  organized into tags instead of folders, so messages can have more
  than one category. The second is that it uses Xapian for searching,
  making full text search really, really fast.

#+BEGIN_SRC emacs-lisp
(use-package notmuch
    :bind (("C-c n" . notmuch-hello)
	   ("C-c N" . notmuch-search)
	   :map notmuch-common-keymap
	   ("g" . notmuch-refresh-this-buffer)
	   :map notmuch-show-mode-map
	   ("b" . josh/notmuch-send-html-to-browser)
	   ("B" . notmuch-show-resend-message)
	   ("G" . jmm/notmuch-refresh-buffer-show-multipart-html)
	   ("o" . jmm/notmuch-show-open-in-gmail)
	   ("S")
	   ("S F" . jmm/notmuch-search-from)
	   ("S f" . jmm/notmuch-search-from)
	   :map notmuch-search-mode-map
	   ("S")
	   ("S F" . jmm/notmuch-search-all-from-author)
	   ("S f" . jmm/notmuch-search-all-from-author)
	   ("L")
	   ("L F" . jmm/notmuch-search-limit-from-author)
	   ("L f" . jmm/notmuch-search-limit-from-author)
	   ("L w" . jmm/notmuch-search-limit-this-week)
	   ("L m" . jmm/notmuch-search-limit-this-month))
    :init
    (setq notmuch-multipart/alternative-discouraged 'jmm/notmuch-multipart/alternative-discouraged-from-tags)
    :config
    (add-to-list 'notmuch-show-insert-text/plain-hook #'jmm/notmuch-wash-links)
    ;; Override `notmuch-search-filter-by-tag' so it only suggests
    ;; tags that occur in the current search.
    (defun notmuch-search-filter-by-tag (tag &optional arg)
      "Filter the current search results based on a single tag.

Runs a new search matching only messages that match both the
current search results AND that are tagged with the given tag."
      (interactive
       (list (notmuch-select-tag-with-completion "Filter by tag: " notmuch-search-query-string)
	     current-prefix-arg))
      (notmuch-search (concat notmuch-search-query-string " and" (when arg " not") " tag:" tag)
		      notmuch-search-oldest-first)))
(use-package ol-notmuch
  :after (notmuch))
#+END_SRC

  Here's some stuff related to sending email (although not directly related to notmuch).
  I'm currently using [[http://msmtp.sourceforge.net/][msmtp]] to automatically handle sending email from different accounts.

#+BEGIN_SRC emacs-lisp
(setq send-mail-function 'sendmail-send-it
      sendmail-program "msmtp"
      mail-specify-envelope-from t
      ;; Argh, this messed me up.
      ;; Thanks RubyNoob
      ;; https://emacs.stackexchange.com/questions/63742/emacs-invokes-default-system-email-client-when-trying-to-send-via-msmtp
      message-send-mail-function 'message-send-mail-with-sendmail
      message-sendmail-envelope-from 'header
      mail-envelope-from 'header)

;; Starttls is deprecated
;; (require 'starttls)
;; use org structures and tables in message mode
;; Thanks, pragmaticemacs!
;; (add-hook 'message-mode-hook 'turn-on-orgtbl)
;; This seems not to work anymore
;; (add-hook 'message-mode-hook 'turn-on-orgstruct++)
#+END_SRC

When using ~shr~ to render HTML, sometimes the colors come out weird. This makes it more readable.
#+BEGIN_SRC emacs-lisp
(setq shr-color-visible-luminance-min 70
      shr-use-colors nil  ;; Don't use colors in text/html stuff
      shr-width 90 ;; Notmuch weirdly indents stuff, so using window with often results in weird word-wrapping
      shr-use-fonts nil) ;; I don't like proportional fonts
#+END_SRC

Function to send HTML part to the browser
#+BEGIN_SRC emacs-lisp
(defun josh/notmuch-send-html-to-browser ()
  "Search for \"text/html\" in the buffer and open it with `notmuch-show-view-part'"
  (interactive)
  (save-excursion
    (when (search-forward "text/html" nil t)
      (notmuch-show-view-part))))
#+END_SRC

** Open an email with gmail

Gmail does some nice stuff occasionally. One of the things I like is
that it caches loading of external images, so senders can't track when
you've opened some mail. Of course, /Gmail/ can still track you, so
it's up to you who you want tracking you (or, you can decide not to
see images in emails).

This function opens an email in Gmail. For most HTML files I should
use ~josh/notmuch-send-html-to-browser~ though.

#+BEGIN_SRC emacs-lisp
(defvar jmm/gmail-to-user-id-alist '(("tag0" . 0)
				     ("tag1" . 1))
  "This should be an alist of tags and their associated user number in gmail.
For example, if mail to your school account is user 0,
  specify (\"school\" . 0) as an item in the alist")

(defun jmm/notmuch-show-open-in-gmail ()
  "Open the displayed message in gmail"
  (interactive)
  (let ((msgid (notmuch-show-get-message-id t))
	(userid (or (cdr (assoc (car (-intersection (mapcar 'car jmm/gmail-to-user-id-alist)
						(notmuch-show-get-tags)))
				jmm/gmail-to-user-id-alist))
		    0)))
    (browse-url (concat (format "https://mail.google.com/mail/u/%d/?ibxr=0#search/" userid)
			(url-hexify-string (format "rfc822msgid:%s" msgid))))))
#+END_SRC
** Store Org mode links to sent messages

Sometimes when sending reply emails, I want to track the email in Org mode.
This function stores an Org mode link to the email (viewed in notmuch), any time I send an email.

#+BEGIN_SRC emacs-lisp
(defun jmm/message-send-store-notmuch-link ()
  "Store an org mode notmuch link to the message after sending."
  (let ((link (concat "notmuch:id:" (substring (message-fetch-field "message-id") 1 -1)))
	(subject (message-fetch-field "subject")))
    (push (list link subject) org-stored-links)))

(add-hook 'message-sent-hook 'jmm/message-send-store-notmuch-link)
#+END_SRC
** Wash out annoyingly long links from ~text/plain~

   A lot of mailing lists will put long tracking links in the
   ~plain/text~ part of their mail. These are long because they're
   meant for tracking/analytics. I find them to be visually too
   cluttering, and don't tend to click on them anyway. This just
   silently removes them.

#+BEGIN_SRC emacs-lisp
(defcustom jmm/tracking-link-regexps
  '("links.ealert" "click.engage.frontiersin.com")
  "Regular expressions for annoyingly long tracking links."
  :type '(repeat string))

;; TODO: Add a button or something to show where it would be?
(defun jmm/notmuch-wash-tracking-links (msg depth)
  "Hide tracking links."
  (goto-char (point-min))
  (while (re-search-forward goto-address-url-regexp nil t)
    (when (--some-p (string-match-p it (match-string 0)) jmm/tracking-link-regexps)
      (replace-match "" nil t))))
#+END_SRC
** Search for other emails from the same author

   This just adds a hotkey to search for emails from the same email
   author. This is useful for me when deciding to make new email
   filters based on authors. (Like, what does this dude usually send
   me? I guess I'll make a filter for him.)

#+BEGIN_SRC emacs-lisp
(defun jmm/notmuch-search-from ()
  "Search for all messages from the email in the \"from\" field."
  (interactive)
  (--if-let
      (-some-> (notmuch-show-get-from)
	       notmuch-clean-address
	       car)
      (progn
	(kill-new it)
	(notmuch-search (s-concat "from:" it)))
    (user-error "No email address was found.")))
#+END_SRC
** Limit a search to emails from the same author

   Some of my tags and searches aren't refined enough. Sometimes I
   have a lot of unread email from the same author and want to go
   through these at the same time.

   For example, I have a "journal" tag for emails from different
   academic journals. If I haven't caught up on them I'll just see
   them piled together. This makes it fast to narrow it down to a specific journal.

#+BEGIN_SRC emacs-lisp
(defun jmm/notmuch-get-email-addresses (search-terms)
  "Return a list of email addresses for SEARCH-TERMS.

The SEARCH-TERMS should be a list"
  (let ((args '("address" "--format=sexp" "--format-version=4")))
    (->> (apply #'notmuch-call-notmuch-sexp (append args search-terms))
	 (--map (plist-get it :address)))))

(defun jmm/notmuch-search-get-author-query ()
  "Get a query for the author/email address under point."
  (let ((author (--> (notmuch-search-find-stable-query)
		     (list (car it))
		     (jmm/notmuch-get-email-addresses it)
		     (car it))))
    (when author
      (concat "from:" author))))

(defun jmm/notmuch-search-limit-from-author (&optional arg)
  "Limit a search to the email address under the point.
With optional prefix ARG, invert the search."
  (interactive "P")
  (-when-let (authorq (jmm/notmuch-search-get-author-query))
    (notmuch-search-filter (concat (when arg "not ") authorq))))

(defun jmm/notmuch-search-all-from-author ()
  "Search all mail sent from the email address under the point."
  (interactive)
  (-when-let (authorq (jmm/notmuch-search-get-author-query))
    (notmuch-search authorq)))
#+END_SRC
** Other search limiting functions

   I get a lot of scientific journal articles emailed to me. I also
   read a lot of list emails. Sometimes I'm really behind on reading
   them, and only want to look at emails for this week or month.

#+BEGIN_SRC emacs-lisp
(defun jmm/notmuch-search-limit-this-week (&optional arg)
  "Limit a search to the emails from this week.
With optional prefix ARG, invert the search."
  (interactive "P")
  (notmuch-search-filter (concat (when arg "not ") "date:1w..")))

(defun jmm/notmuch-search-limit-this-month (&optional arg)
  "Limit a search to the emails from this month.
With optional prefix ARG, invert the search."
  (interactive "P")
  (notmuch-search-filter (concat (when arg "not ") "date:1M..")))
#+END_SRC

** Decode Proofpoint urls

Many email providers use Proofpoint to provide a kind of email defense
against phishing and malware. Unfortunately, this can often make plain
text emails hard to read. This function replaces Proofpoint links with
their original url.

#+BEGIN_SRC emacs-lisp
(defun jmm/url-decode-proofpoint (url)
  "Parse proofpoint urls.

Handy if proofpoint urls appear weirdly in plaintext emails.
Only decodes version 2.

Note: You'll have to be careful not to be phished, which is what
proofpoint defends against."
  (let ((urlobj (url-generic-parse-url url)))
    (if (s-equals? (url-host urlobj) "urldefense.proofpoint.com")
	(--> urlobj
	     (cdr (url-path-and-query it)) ; Get the query
	     (url-parse-query-string it)  ; Get an alist of query parameters
	     (car (alist-get "u" it nil nil #'equal))	; Get "u" which holds the url
	     (s-replace-all '(("-" . "%") ("_" . "/")) it) ; Replace special characters so we can unhexify it
	     (url-unhex-string it)) ; Unhex
      url)))
#+END_SRC

Also decode some explicitly tracking urls

#+BEGIN_SRC emacs-lisp
(defun jmm/url-decode-appspot (url)
  "Appspot isn't even trying to protect you. It's just tracking."
  (let ((urlobj (url-generic-parse-url url)))
      (if (string-match-p "appspot\.com$" (url-host urlobj))
	  (--> urlobj
	       (cdr (url-path-and-query it)) ; Get the query
	       (url-parse-query-string it)  ; Get an alist of query parameters
	       (car (alist-get "link" it nil nil #'equal))	; Get "u" which holds the url
	       (url-unhex-string it)) ; Unhex
	url)))
#+END_SRC

Decode convertkit-mail.

#+begin_src emacs-lisp
(defun jmm/url-decode-convertkitmail (url)
  "Parse convertkit-mail.com urls."
  (let ((urlobj (url-generic-parse-url url)))
    (if (s-equals? (url-host urlobj) "click.convertkit-mail.com")
	(--> urlobj
	     (car (url-path-and-query it))
	     (nth 1 (s-match "/[^/]+/[^/]+/\\([^/]+\\)" it))
	     (base64-decode-string it))
      url)))
#+end_src

Decode pocket. I think this was more of an issue with earlier emails, as later emails were cleaned up.

#+begin_src emacs-lisp
(defun jmm/url-decode-pocket (url)
  (let ((urlobj (url-generic-parse-url url)))
    (if (string-match-p "getpocket\.com/save/" url)
	(--> urlobj
	     (cdr (url-path-and-query it)) ; Get the query
	     (url-parse-query-string it)  ; Get an alist of query parameters
	     (car (alist-get "url" it nil nil #'equal))	; Get "url" which holds the url
	     (url-unhex-string it)) ; Unhex
      url)))
#+end_src


A query-parameter extracting function to be used for a more generic implementation later.

#+BEGIN_SRC emacs-lisp
(defun jmm/url-get-parameter (url parameter)
  "Get a query PARAMETER for a URL.
Useful for extracting redirects."
  (--> url
       (url-generic-parse-url it)
       (cdr (url-path-and-query it))
       (url-parse-query-string it)
       (car (alist-get parameter it nil nil #'equal))))
#+END_SRC


#+BEGIN_SRC emacs-lisp
(defun jmm/notmuch-wash-decodable-links (msg depth)
  "Decode proofpoint and decodeable tracking links."
  (goto-char (point-min))
  (while (re-search-forward goto-address-url-regexp nil t)
    (let* ((url (match-string 0))
	   (decoded-url (save-match-data (-> url
					     jmm/url-decode-proofpoint
					     jmm/url-decode-appspot
					     jmm/url-decode-convertkitmail
					     jmm/url-decode-pocket))))
      (replace-match decoded-url
		     nil t))))
#+END_SRC
** Remove superfluous tracking parameters

Tracking parameters like [[https://en.wikipedia.org/wiki/UTM_parameters][UTM parameters]] (e.g. ~utm_source~) in URLs is
really ugly and clutters my display. These functions help to wash out
unnecessary parameters.

Here's where you can define hosts and parameters to strip from them:

#+BEGIN_SRC emacs-lisp
(defcustom jmm/url-superfluous-parameters
  '(("^mailchi\\.mp$" "e")
    ("linkedin\\.com$" "trk" "trkEmail")
    ("." "utm_source" "utm_medium" "utm_campaign" "utm_term" "utm_content" "mc_eid" "mc_cid"))
  "Parameters that are unnecessary in links.
A list of (REGEXP PARAMETERS) where the regex matches the host and paramters must match exactly."
  :type '(alist :key-type (regexp :tag "Host regexp")
		:value-type (repeat (string :tag "Parameter"))))
#+END_SRC

Now the actual implementation

#+BEGIN_SRC emacs-lisp
(defun jmm/keys-to-remove-for-host (hostname)
  (->> jmm/url-superfluous-parameters
       (-filter (lambda (elem) (s-matches? (car elem) hostname)))
       (-mapcat #'cdr)))

(defun jmm/remove-keys-from-alist (keys al)
  "Remove any of KEYS in AL.

KEYS is a list of strings."
  (-remove (lambda (elem) (-contains? keys (car elem)))
	   al))

(defun jmm/url-clean-superfluous-parameters (url)
  "Remove superfluous parameters from URL.

See the variable `jmm/url-superfluous-parameters' for what gets cleaned."
  (-let* ((urlobj (url-generic-parse-url url))
	  ((path . query) (url-path-and-query urlobj))
	  (newquery (when query
		      (--> query
			   (url-parse-query-string it)
			   (jmm/remove-keys-from-alist (jmm/keys-to-remove-for-host (url-host urlobj)) it)
			   (url-build-query-string it)))))
    (setf (url-filename urlobj) (if (s-blank? newquery)
				    path
				  (concat path "?" newquery)))
    (url-recreate-url urlobj)))

(defun jmm/notmuch-wash-superfluous-parameters (msg depth)
  "Remove tracking paraters from links"
  (goto-char (point-min))
  (while (re-search-forward goto-address-url-regexp nil t)
    (let ((url (match-string 0)))
      (replace-match (save-match-data (jmm/url-clean-superfluous-parameters url))
  		     nil
  		     t))))
#+END_SRC
** Other plain text washing functions for links

   Emacs weirdly lets links end in a closing parenthesis, which is not
   usually what people do. Here I add a space between the parenthesis
   and url to fix that.

#+BEGIN_SRC emacs-lisp
(defun jmm/notmuch-wash-fix-link-parenthesis (msg depth)
  "Links that are enclosed in parenthesis get matched weird
sometimes. Add a space to the end to fix this."
  (goto-char (point-min))
  (while (re-search-forward goto-address-url-regexp nil t)
    (let ((url (match-string 0)))
      (when (string-match-p ")$" url)
	(replace-match (concat " " (s-chop-suffix ")" url) " )") nil t)))))
#+END_SRC

Here's where we define the pipeline of washing links. We do this in a
specific order because decoded urls may themselves have additional
tracking parameters.

#+BEGIN_SRC emacs-lisp
(defun jmm/notmuch-wash-links (msg depth)
  (jmm/notmuch-wash-fix-link-parenthesis msg depth)
  (jmm/notmuch-wash-decodable-links msg depth)
  (jmm/notmuch-wash-tracking-links msg depth)
  (jmm/notmuch-wash-superfluous-parameters msg depth))
#+END_SRC
** Occasionally show HTML multipart instead of text/plain

   Some senders have a ~text/plain~ multipart, but it's so cluttered
   and poorly formatted that it might as well not be there at
   all. Usually the problem is that there are too many links, and
   whatever they're using to convert HTML to plain text just doesn't
   work at all. You see this a lot with mailing lists, where the
   expected recipients are only using their personal Gmail.

   This function is for hiding the ~text/plain~ part and allowing
   ~text/html~ to be rendered.

#+begin_src emacs-lisp
(defun jmm/notmuch-refresh-buffer-show-multipart-html ()
  "Run `notmuch-refresh-this-buffer', but discourage text/plain.

See also `notmuch-multipart/alternative-discouraged'"
  (interactive)
  (let ((notmuch-multipart/alternative-discouraged '("text/plain")))
    (notmuch-refresh-this-buffer)))
#+end_src

   Note: ~notmuch-multipart/alternative-discouraged~ is actually
   allowed to be a function (though this isn't documented) that is
   passed the message.

   Here's how to check the tags to determine how to render it.

#+begin_src emacs-lisp
;; TODO: Add type: alist
(defvar jmm/notmuch-multipart/alternative-discouraged-tags
  '(("html" . ("text/plain"))
    ("plain" . ("text/html"))
    ;; Default value is nil.
    (nil . ("text/html" "multipart/related")))
  "Alist from a notmuch tag to a list of discouraged parts. See `notmuch-multipart/alternative-discouraged'")

;; TODO: Check performance
(defun jmm/notmuch-multipart/alternative-discouraged-from-tags (msg)
  "Check tags against `jmm/notmuch-multipart/alternative-discouraged-from-tags' to determine discouraged parts."
  (--> msg
    (plist-get it :tags)
    (-intersection (mapcar 'car jmm/notmuch-multipart/alternative-discouraged-tags)
		   it) ;; Tags we can act on. TODO: Sort
    (car it)		  ;; First tag
    (cdr (assoc it jmm/notmuch-multipart/alternative-discouraged-tags))	  ;; Find list of discouraged parts.
    ))

;; Try with (jmm/notmuch-multipart/alternative-discouraged-tags (notmuch-show-get-message-properties))
#+end_src


** Remove trailing whitespace from HTML

   ~shr~ leaves trailing whitespace when formatting. I find this kind
   of annoying when trying to copy links or text.

#+begin_src emacs-lisp
(defun jmm/notmuch/delete-trailing-whitespace (msg part)
  "This is just `delete-trailing-whitespace' with added arguments
  for advising `notmuch-show--insert-part-text/html-shr'."
  (delete-trailing-whitespace))

(advice-add 'notmuch-show--insert-part-text/html-shr :after #'jmm/notmuch/delete-trailing-whitespace)
;; (advice-remove 'notmuch-show--insert-part-text/html-shr #'jmm/notmuch/delete-trailing-whitespace)
#+end_src


* Elfeed
  [[https://github.com/skeeto/elfeed][elfeed]] is an RSS reader with a similar interface to [[https://notmuchmail.org/][notmuch]]. I used
  to use Gnus to read RSS, but elfeed is nice in that it doesn't block
  emacs when loading feeds. Also, after learning how to use notmuch,
  the elfeed interface started making a lot of sense.

  Pro tip: Use bookmarks (especially Helm bookmarks) to save elfeed
  searches. This gives you similar functionality to notmuch saved searches.

#+BEGIN_SRC emacs-lisp
(defun elfeed-toggle-images ()
  "Toggle the display of images"
  (interactive)
  (setq shr-inhibit-images (not shr-inhibit-images))
  (elfeed-show-refresh))

(defun elfeed-temporarily-inhibit-images ()
    "Inhibit the display of images, but don't set `shr-inhibit-images'"
    (interactive)
    (let ((shr-inhibit-images t))
      (elfeed-show-refresh)))

(defun josh/save-elfeed ()
    "Just call `elfeed-db-save'. We just need an interactive function to bind to a key"
    (interactive)
    (if (elfeed-db-save)
	(message "Saved")))

(use-package elfeed
  :bind (("C-x w" . elfeed)
	 :map elfeed-show-mode-map
	 ("I" . elfeed-toggle-images)
	 ("i" . elfeed-temporarily-inhibit-images)
	 ("k" . jmm/elfeed-tag-unread)
	 :map elfeed-search-mode-map
	 ("C-x C-s" . josh/save-elfeed))
  :config
  (advice-add 'elfeed-show-visit :around #'jmm/org-open-link-alternate-browser))
#+END_SRC
** Mark things as unread

#+BEGIN_SRC emacs-lisp
;; TODO: Make it easy to untag things too.
(defun jmm/elfeed-tag-unread ()
  "Tag as unread"
  (interactive)
  (elfeed-show-tag 'unread))
#+END_SRC

* Sawfish
  Automatically load .jl files as sawfish (not Julia)
#+begin_src emacs-lisp
  (when (require 'sawfish nil 'noerror)
    (setq auto-mode-alist (cons '("\\.sawfishrc$"  . sawfish-mode) auto-mode-alist)
          auto-mode-alist (cons '("\\.jl$"         . sawfish-mode) auto-mode-alist)
          auto-mode-alist (cons '("\\.sawfish/rc$" . sawfish-mode) auto-mode-alist)))

#+end_src
* Helm
#+begin_src emacs-lisp
(require 'helm-config)
(bind-key "C-c h" 'helm-mini)
(use-package helm-mode
  :diminish helm-mode
  :defer 1
  :bind (;;("M-x" . helm-M-x)
	 ("C-x b" . helm-buffers-list)
	 ;; ("C-x C-f" . helm-find-files)
	 ;; ("C-x f" . helm-for-files)
	 ("C-x C-i" . helm-semantic-or-imenu)
	 ("M-y" . helm-show-kill-ring)
	 ("M-s o" . helm-occur)
	 ("M-g s" . helm-do-grep)
	 ("M-g b" . helm-resume)
	 ("C-c SPC" . helm-all-mark-rings)
	 ("C-c b" . helm-bookmarks)
	 ;; :map helm-bookmark-map
	 ;; ("C-c s" . jmm/helm-bookmark-run-set-bookmark)
	 )
  :init
  (setq helm-ff-newfile-prompt-p nil)
  :config
  (bind-key "C-c j" 'helm-ff-dired helm-map)
  (bind-key "C-c J" 'helm-ff-xterm-directory helm-map)
  (bind-key "C-c C-m" 'helm-ff-mpv helm-map)
  (progn (mapc (lambda (x) (add-to-list 'helm-completing-read-handlers-alist
                               (list x)))
      (list 'dired-do-rename
            'dired-do-copy
            'dired-do-delete
            'dired-do-symlink
            'dired-create-directory
            'find-file))
         (helm-mode 1)))
#+end_src
** Other Helm actions I find useful
   I like being able to open an xterm or quickly jump to dired with helm.
#+begin_src emacs-lisp
(defun helm-ff-dired ()
  "Run open file externally command action from `helm-source-find-files'."
  (interactive)
  (when helm-alive-p
    (helm-quit-and-execute-action 'helm-point-file-in-dired)))

(defun helm-xterm-directory (file)
  "Open an xterm starting in FILE's directory."
  (start-xterm (if (file-directory-p file)
                   file
                 (file-name-directory file))))

(defun helm-ff-xterm-directory ()
  "Open xterm on file's directory"
  (interactive)
  (when helm-alive-p
    (helm-quit-and-execute-action 'helm-xterm-directory)))
#+end_src
** Helm locate
   I like spaces to narrow locate results, instead of having to type
   in ".*" to search for separate strings.
#+BEGIN_SRC emacs-lisp
  (setq helm-locate-command "locate %s -e -A --regex %s")
#+END_SRC
** Helm MPV
   I like being able to play a bunch of files with mpv, and sometimes
   I like to scrobble them to last.fm. I have a script called
   "scrobblempv2" in my path that enables scrobbling of tracks.
#+BEGIN_SRC emacs-lisp
  (defun helm-mpv (_ignore)
      "Play some files with mpv. Given a prefix, run scrobblempv2, a
    script made to enable plugins for mpv scrobbling.
  Given two prefixes, append file to the current playlist."
      (let* ((files (helm-marked-candidates :with-wildcard t))
             (len (length files))
             (mpv (cond
                   ((equal helm-current-prefix-arg '(16)) "scrobblempv2")
                   ((equal helm-current-prefix-arg '(4)) "mpvappendscrobble")
                   (t "mpv"))))
        (with-helm-display-marked-candidates
          helm-marked-buffer-name
          (mapcar #'(lambda (f)
                      (if (file-directory-p f)
                          (concat (helm-basename f) "/")
                        (helm-basename f)))
                  files)
          (apply 'start-process "scrobblempv2" " mpv process" mpv files))))

  (defun helm-ff-mpv ()
    "Open a file with mpv."
    (interactive)
    (when helm-alive-p
      (helm-quit-and-execute-action 'helm-mpv)))
#+END_SRC
** helm-swoop
Set up hotkeys and stuff for helm-swoop
#+BEGIN_SRC emacs-lisp
(use-package helm-swoop
  :ensure t
  :bind (("M-i" . helm-swoop)
         ("M-I" . helm-swoop-back-to-last-point)
         ("C-c M-i" . helm-multi-swoop)
	 ("C-c D" . helm-multi-swoop-dired)
         ("C-x M-i" . helm-multi-swoop-all)
	 :map isearch-mode-map
	 ;; When doing isearch, hand the word over to helm-swoop
	 ("M-i" . helm-swoop-from-isearch)
	 :map helm-swoop-map
	 ;; From helm-swoop to helm-multi-swoop-all
	 ("M-i" . helm-multi-swoop-all-from-helm-swoop)))
#+END_SRC

Make an easy way to find files in open dired buffers

#+BEGIN_SRC emacs-lisp
;; (require 'helm-swoop)
(defun helm-multi-swoop-dired (&optional $query)
  "Applies all dired-mode buffers to helm-multi-swoop"
  (interactive)
  (helm-multi-swoop-by-mode 'dired-mode $query))
#+END_SRC

** helm-descbinds
   Describe bindings.
#+BEGIN_SRC emacs-lisp
(use-package helm-descbinds
  :ensure t
  :defer t
  :bind (("C-h b" . helm-descbinds)
         ("C-h w" . helm-descbinds)))
#+END_SRC
** helm-org-rifle
   Helm-org-rifle is a really nice way to swoop through org-mode
#+BEGIN_SRC emacs-lisp
(use-package helm-org-rifle
  :ensure t
  :after (org)
  :bind (("C-c R" . helm-org-rifle-occur)
         ("C-c r" . helm-org-rifle)
	 :map helm-org-rifle-map
	 ("C-c C-l" . jmm/helm-org-rifle-insert-link-map-action)
	 ("C-c l" . jmm/helm-org-rifle-copy-link-map-action)))
#+END_SRC
*** Link to things with helm-org-rifle
    Helm-org-rifle is a great way to find entries, and I find it much
    faster than using an agenda search. Often, I want to add
    references from one entry to another. These functions allow
    copying and directly inserting links from helm-org-rifle.

#+BEGIN_SRC emacs-lisp
(defun jmm/helm-org-rifle-insert-link (candidate)
  "Insert a link to the current CANDIDATE in the current buffer."
  (-let (((buffer . pos) candidate))
    (helm-attrset 'new-buffer nil)  ; Prevent the buffer from being cleaned up
    (insert (with-current-buffer buffer
	      (save-excursion
		(goto-char pos)
		(org-store-link t))))))

(defun jmm/helm-org-rifle-insert-link-map-action ()
  "Exit Helm buffer and call `jmm/helm-org-rifle-insert-link' with selected candidate."
  (interactive)
  (with-helm-alive-p
    (helm-exit-and-execute-action 'jmm/helm-org-rifle-insert-link)))

(defun jmm/helm-org-rifle-copy-link (candidate)
  "Copy a link to the current CANDIDATE."
  (-let (((buffer . pos) candidate))
    (helm-attrset 'new-buffer nil)  ; Prevent the buffer from being cleaned up
    (with-current-buffer buffer
      (save-excursion
	(goto-char pos)
	(call-interactively 'org-store-link)))))

(defun jmm/helm-org-rifle-copy-link-map-action ()
  "Exit Helm buffer and call `jmm/helm-org-rifle-copy-link' with selected candidate."
  (interactive)
  (with-helm-alive-p
    (helm-exit-and-execute-action 'jmm/helm-org-rifle-copy-link)))
#+END_SRC
** helm-bookmarks

   Sometimes I have bookmarks that are frequently updated. For
   example, if I'm reading a really long PDF I'll have a bookmark for
   my current location. I add a hotkey ~C-c s~ for setting a candidate
   bookmark to the current location.

#+BEGIN_SRC emacs-lisp
(defun jmm/helm-bookmark-set-bookmark (candidate)
  (let (non-essential)
    ;; Honestly I don't know what non-essential is doing here, or if
    ;; it's even... *cough* essential here.
    (bookmark-set candidate)))

(defun jmm/helm-bookmark-run-set-bookmark ()
  "Reset a bookmark to current location."
  (interactive)
  (with-helm-alive-p
    (helm-exit-and-execute-action 'jmm/helm-bookmark-set-bookmark)))
;; TODO: Also don't know what this is doing or if it's needed. I'm
;; just using what I saw for other helm bookmark actions.
(put 'jmm/helm-bookmark-run-set-bookmark 'helm-only t)

;; (bind-key "C-c s" 'jmm/helm-bookmark-run-set-bookmark helm-bookmark-map)
#+END_SRC
* Ivy
  Ivy provides another completion framework. At some points it feels a
  bit quicker than helm.
#+BEGIN_SRC emacs-lisp
(use-package ivy
  :if (not noninteractive)
  :ensure t
  :defer 3
  :init
  (setq ivy-use-virtual-buffers t)
  (setq ivy-extra-directories nil) ;; Don't like seeing ./ and ../ in completions
  :bind (("C-c C-r" . ivy-resume)
	 :map ivy-mode-map
	 ("C-'" . ivy-avy)
	 :map ivy-minibuffer-map
	 ("C-<" . ivy-minibuffer-shrink)
	 ("C->" . ivy-minibuffer-grow)))

(use-package ivy-hydra
  :if (not noninteractive)
  :defer 2
  :ensure t)

(use-package swiper
  :if (not noninteractive)
  :ensure t
  :bind (("M-i" . swiper)
	 ("M-I" . swiper-all)))

(use-package counsel
  :if (not noninteractive)
  :ensure t
  ;; Require counsel for jmm/counsel-fasd-directories
  :defer 3
  :after (dired)
  :bind (("M-x" . counsel-M-x)
	 ("C-x b" . counsel-switch-buffer)
	 ("C-x l" . counsel-locate)
	 ("C-c k" . counsel-ag)
	 ("C-x C-f" . counsel-find-file)
	 ("<f2> u" . counsel-unicode-char)
	 ("<f1> f" . counsel-describe-function)
	 ("<f1> v" . counsel-describe-variable)
	 ("C-h C-b" . counsel-descbinds)
	 ("C-c d" . jmm/counsel-fasd-directories)
	 ("C-c j" . jmm/counsel-dired-file)
	 :map dired-mode-map
	 ("M-F" . jmm/counsel-files-in-directory))
  :init
  ;; Suggest the file at point, if it's a path
  (setq counsel-find-file-at-point t)
  :config
  ;; Fasd still works well with only two characters
  (add-to-list 'ivy-more-chars-alist '(jmm/counsel-fasd-directories . 2))
  ;; Optionally sort find-files by date
  (setf (alist-get 'read-file-name-internal ivy-sort-functions-alist)
      (list #'ivy-sort-file-function-default
	    #'file-newer-than-file-p))
  (ivy-set-actions
   'jmm/counsel-dired-file
   '(("x" counsel-locate-action-extern "xdg-open")
     ("j" jmm/mpv-scrobble-file "scrobblempv")
     ("J" jmm/mpv-play-file "mpv")
     ("t" jmm/counsel-find-file-toggle-root "open toggling root")
     ("r" jmm/counsel-find-file-as-root "open as root")
     ("d" jmm/counsel-dired-file-dired "dired")))
  (ivy-set-actions
   'counsel-locate
   '(("x" counsel-locate-action-extern "xdg-open")
     ("j" jmm/mpv-scrobble-file "scrobblempv")
     ("J" jmm/mpv-play-file "mpv")
     ("t" jmm/counsel-find-file-toggle-root "open toggling root")
     ("r" jmm/counsel-find-file-as-root "open as root")
     ("d" jmm/counsel-action-jmm-dired-jump "dired")))
  (ivy-set-actions
   'counsel-find-file
   '(("j" find-file-other-window "other window")
     ("f" find-file-other-frame "other frame")
     ("b" counsel-find-file-cd-bookmark-action "cd bookmark")
     ("x" counsel-find-file-extern "open externally")
     ("R" jmm/counsel-find-file-toggle-root "open toggling root")
     ("r" jmm/counsel-find-file-as-root "open as root")
     ("k" counsel-find-file-delete "delete")
     ("m" counsel-find-file-move "move or rename")
     ("d" counsel-find-file-mkdir-action "mkdir"))))

#+END_SRC
** Ivy completions for fasd
   Makes it easy to quickly navigate directories.
#+BEGIN_SRC emacs-lisp
(defun jmm/counsel-fasd-directory-function (str)
  ;; I normally don't use fasd for remote connections
  (let ((default-directory "~/"))
    (or
     (ivy-more-chars)
     (progn
       (counsel--async-command
	(format "fasd -dlR %s" str))
       '("" "working...")))))

(defvar jmm/counsel-fasd-directory-history nil
  "Maintains a list of fasd directories selected.")

(defun jmm/ivy--switch-directory (directory)
  "Switch to a dired directory from an ivy completion"
  (with-ivy-window
    (when directory
      (dired directory))))

(defun jmm/ivy--eshell-cd-directory (directory)
  "Send Eshell a command to switch to a directory from an ivy completion"
  (with-ivy-window
    (eshell-kill-input)
    (insert (concat "cd " (eshell-quote-argument directory)))
    (eshell-send-input)))

(defun jmm/counsel-fasd-directories (&optional initial-input)
  "Call the \"fasd\" shell command to get \"frecent\" directories.
     INITIAL-INPUT can be given as the initial minibuffer input."
  (interactive)
  (ivy-read "fasd directory: " #'jmm/counsel-fasd-directory-function
	    :initial-input initial-input
	    :dynamic-collection t
	    :history 'jmm/counsel-fasd-directory-history
	    :action
	    '(1
	      ("d" jmm/ivy--switch-directory "Open in dired")
	      ("e" jmm/ivy--eshell-cd-directory "CD in Eshell"))
	    :unwind #'counsel-delete-process
	    :caller 'jmm/counsel-fasd-directories))


;; Same thing but switch the default action
(defun jmm/counsel-fasd-directories-eshell (&optional initial-input)
  "Call the \"fasd\" shell command to get \"frecent\" directories.
     INITIAL-INPUT can be given as the initial minibuffer input."
  (interactive)
  (ivy-read "fasd directory: " #'jmm/counsel-fasd-directory-function
	    :initial-input initial-input
	    :dynamic-collection t
	    :history 'jmm/counsel-fasd-directory-history
	    :action
	    '(1
	      ("e" jmm/ivy--eshell-cd-directory "CD in Eshell")
	      ("d" jmm/ivy--switch-directory "Open in dired"))
	    :unwind #'counsel-delete-process
	    :caller 'jmm/counsel-fasd-directories))
#+END_SRC
** Ivy for opening a file visible in a dired buffer

   Makes it easier to find a file that I know is visible in some
   buried dired buffer somewhere.
#+BEGIN_SRC emacs-lisp
(defun jmm/get-dired-files ()
  "Get all files in a dired buffer"
  (when (eq major-mode 'dired-mode)
    (save-excursion
      (goto-char (point-min))
      (cl-loop until (eobp)
	       do (dired-goto-next-file)
	       collect (-if-let (filename (dired-get-filename nil t))
			   (propertize filename
				       'buffer (current-buffer)
				       ;; 'size (file-attribute-size (file-attributes filename))
				       ))
	       do (forward-line)))))

(defun jmm/get-all-dired-files ()
  "Get a list of all dired files."
  (->> (buffer-list)
       (--filter (with-current-buffer it
		   (eq major-mode 'dired-mode)))
       (--mapcat (with-current-buffer it
		   (jmm/get-dired-files)))
       -non-nil
       ;; (--sort (< (get-text-property 0 'size it)
       ;; 		  (get-text-property 0 'size other)))
       ))

;; TODO: Sort files by modification time?
(defun jmm/counsel-dired-file ()
  "Prompt for a file name. Go to it in a dired directory."
  (interactive)
  (ivy-read "File: "
	    (jmm/get-all-dired-files)
	    :action #'jmm/counsel-open-file))

(defun jmm/counsel-open-file (file)
  "Open FILE."
  (when file
    (find-file file)))

(defun jmm/counsel-dired-file-dired (x)
  "Go to the dired directory containing X."
  (switch-to-buffer (get-text-property 0 'buffer x))
  (dired-goto-file x))

(defun jmm/mpv-scrobble-file (x)
  (let* ((process-connection-type nil))
    (start-process "" nil "mpvappendscrobble" x)
    (message (format "Played %s" x))))

(defun jmm/mpv-play-file (x)
  (let* ((process-connection-type nil))
    (start-process "" nil "mpv" "--audio-pitch-correction" x)
    (message (format "Played %s" x))))
#+END_SRC
** Better method for finding files as root

   ~counsel-find-file-as-root~ doesn't seem to work with remote files (e.g. ~/sshx:user@host:/some/file~).

   These functions take care of that.

#+BEGIN_SRC emacs-lisp
(defun jmm/counsel-find-file-toggle-root (x)
  "Find file X toggling root privileges.
Works with remote (Tramp) files as well."
  (let* ((file-name (jmm/tramp-toggle-sudo-file x)))
    ;; If the current buffer visits the same file we are about to open,
    ;; replace the current buffer with the new one.
    (if (eq (current-buffer) (get-file-buffer x))
        (find-alternate-file file-name)
      (find-file file-name))))

(defun jmm/counsel-find-file-as-root (x)
  "Find file X with root privileges.
Works with remote (Tramp) files as well."
  (let* ((file-name (jmm/tramp-add-sudo-method x)))
    ;; If the current buffer visits the same file we are about to open,
    ;; replace the current buffer with the new one.
    (if (eq (current-buffer) (get-file-buffer x))
        (find-alternate-file file-name)
      (find-file file-name))))
#+END_SRC


* Magit
  [[https://magit.vc/][Magit]] is probably the best [[http://stackoverflow.com/a/6976506][git porcelain]] out there. I've been using it for a while.
#+BEGIN_SRC emacs-lisp
(use-package magit
  :ensure t
  :after (dired)
  :bind (("C-x g" . magit-status)
	 ("C-x M-g" . magit-dispatch-popup)
	 :map dired-mode-map
	 ("C-c C-l" . magit-dired-log)))
#+END_SRC

* Flycheck
  [[http://www.flycheck.org/en/latest/][Flycheck]] is a pretty good syntax checker for Emacs. Right now, I
  mostly use it to lint JavaScript files. I've also used it a couple
  times with Emacs lisp packages.
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :ensure t
  :commands (flycheck-mode global-flycheck-mode)
  :config
  ;; Disable jshint. I use eslint
  ;; Also disable Emacs lisp checkdoc stuff for now
  (setq-default flycheck-disabled-checkers
		(append flycheck-disabled-checkers
			'(javascript-jshint emacs-lisp-checkdoc))))
#+END_SRC
** Use a local eslint from ~node_modules~ before a global one
   From [[http://emacs.stackexchange.com/questions/21205/flycheck-with-file-relative-eslint-executable]]

#+BEGIN_SRC emacs-lisp
(defun my/use-eslint-from-node-modules ()
  (let* ((root (locate-dominating-file
                (or (buffer-file-name) default-directory)
                "node_modules"))
         (eslint (and root
                      (expand-file-name "node_modules/eslint/bin/eslint.js"
                                        root))))
    (when (and eslint (file-executable-p eslint))
      (setq-local flycheck-javascript-eslint-executable eslint))))

(add-hook 'flycheck-mode-hook #'my/use-eslint-from-node-modules)
#+END_SRC

* Useful, but unnecessary, functions
** Word counting
#+begin_src emacs-lisp
(defun word-count nil "Count words in buffer" (interactive)
  (shell-command-on-region (point-min) (point-max) "wc -w"))
#+end_src

** Aliases
#+begin_src emacs-lisp
(defun afm ()				;Shorter than typing auto-fill-mode
  (interactive)
  (auto-fill-mode))

(defun ttl ()
  (interactive)
  (toggle-truncate-lines))
#+end_src

** Killing buffers
#+begin_src emacs-lisp
;; Display buffers and kill them
(defun kill-some-buffers2 (&optional list)
  "Kill some buffers.  Asks the user whether to kill each one of them.
Non-interactively, if optional argument LIST is non-nil, it
specifies the list of buffers to kill, asking for approval for each one."
  (interactive)
  (if (null list)
      (setq list (buffer-list)))
  (while list
    (let* ((buffer (car list))
	   (name (buffer-name buffer)))
      (and name				; Can be nil for an indirect buffer
					; if we killed the base buffer.
	   (not (string-equal name ""))
	   (/= (aref name 0) ?\s)
	   (switch-to-buffer name)
	   (kill-buffer-ask buffer)))
    (setq list (cdr list))))
(bind-key "C-x M-k" 'kill-some-buffers2)
#+end_src


#+begin_src emacs-lisp
(add-hook 'artist-mode-hook
 (lambda ()
   (define-key artist-mode-map [remap artist-next-line] 'picture-move-down)
   ))
#+end_src
** Viewing and killing buffers
#+begin_src emacs-lisp
(defun view-and-kill-some-buffers (&optional list)
  "View and kill buffers"
  (interactive)
  (if (null list)
      (setq list (buffer-list)))
  (while list
    (let* ((buffer (car list))
	   (name (buffer-name buffer)))
      (switch-to-buffer buffer)
      (and name				; Can be nil for an indirect buffer
					; if we killed the base buffer.
	   (not (string-equal name ""))
	   (/= (aref name 0) ?\s)
	   (kill-buffer-ask buffer)))
    (setq list (cdr list))))
#+end_src

** What I do when editing some text files
#+begin_src emacs-lisp
(defun txt-stuff ()
  "A lot of stuff you do when writing in text files"
  (interactive)
  (auto-fill-mode 1)
  (use-hard-newlines 1 'always))
#+end_src

#+BEGIN_SRC emacs-lisp
(defun journal-stuff ()
  "A bunch of commands used when writing a daily journal."
  (interactive)
  (insert (replace-regexp-in-string "\.txt" "" (buffer-name))
          "\n"
          "(Written ")
  (ignore-errors (org-time-stamp '(16)))
  (insert ")\n\n")
  (text-scale-set -2)
  (txt-stuff))
#+END_SRC

** Starting an Xterm in current directory
#+begin_src emacs-lisp
(defun start-xterm (&optional dirpath)
    "Start a new xterm in the current directory. SSH if necessary"
    (interactive)
    (let ((path (if dirpath dirpath (expand-file-name (or (and (eq major-mode 'dired-mode)
                                                               (dired-current-directory))
                                                          default-directory)))))
      "Return the local portion of a path.

  If PATH is local, return it unaltered.
  If PATH is remote, return the remote diretory portion of the path."
      (if (tramp-tramp-file-p path)
          (let ((loc (tramp-file-name-localname (tramp-dissect-file-name path)))
                (host (tramp-file-name-host (tramp-dissect-file-name path))))
            (start-process "xterm" " xterm-processes" "xterm" "-T" (format "%s: %s" host loc) "-e" (format "ssh -t %s 'cd %s; bash'" host loc)))
        (start-process "xterm" " xterm-processes" "xterm" "-T" path "-e" (format "cd \"%s\"; zsh" path)))))
(bind-key "<f9> x" 'start-xterm)
#+end_src

#+begin_src emacs-lisp
(defun start-xterm-at-projectile-root (&optional dirpath)
    "Start a new xterm in the current directory. SSH if necessary"
    (interactive)
    (let ((path (if dirpath dirpath (expand-file-name (projectile-project-root)))))
      (if (tramp-tramp-file-p path)
          (let ((loc (tramp-file-name-localname (tramp-dissect-file-name path)))
                (host (tramp-file-name-host (tramp-dissect-file-name path))))
            (start-process "xterm" " xterm-processes" "xterm" "-T" (format "%s: %s" host loc) "-e" (format "ssh -t %s 'cd %s; bash'" host loc)))
        (start-process "xterm" " xterm-processes" "xterm" "-T" path "-e" (format "cd \"%s\"; zsh" path)))))
(bind-key "<f9> X" 'start-xterm-at-projectile-root)
#+end_src

** Copy the path
#+begin_src emacs-lisp
(defun file-name-copy-path ()
  "Copy the path the of the of the current buffer"
  (interactive)
  (kill-new (message "%s" (buffer-file-name))))
(bind-key "<f9> c" 'file-name-copy-path)
#+end_src

** Word wrapping
#+begin_src emacs-lisp
 (defun ww ()
  "Set word wrapping"
  (interactive)
  (setq word-wrap (if word-wrap nil t)))
#+end_src
** Half Term
#+begin_src emacs-lisp
(defun run-half-term ()
   "Run a shell in half a window."
   (interactive)
   (split-window-vertically nil)
   (other-window 1)
   (term "/bin/bash")
   (rename-uniquely)
   (other-window -1))

(bind-key "C-x 4 t" 'run-half-term)
#+end_src
** Search Gregg Shorthand Dictionary
#+begin_src emacs-lisp
(defun gsd ()
  "Search the Gregg Shorthand dictionary for a specific word, and
open up the PDF to that page."
  (interactive)
  (find-file-read-only (if (boundp 'jmm/nix-gsd-path)
			   (concat jmm/nix-gsd-path "/gsd.txt")
			 "~/Downloads/gregg/gsd.txt"))
  (swiper)
  (let ((gsd-pdf-path (expand-file-name (if (boundp 'jmm/nix-gsd-path)
					    (concat jmm/nix-gsd-path "/gsd.pdf")
					  "~/Downloads/gregg/gsd.pdf"))))
    (if (and (require 'pdf-tools nil 'noerror)
	     (require 'pdf-isearch nil 'noerror))
	(progn
	  (setq gsd-word (word-at-point))
	  (setq gsd-page (string-to-number (substring (what-page) 5 8)))
	  (find-file-read-only gsd-pdf-path)
	  (pdf-view-goto-page gsd-page)
	  (setq gsd-matches (pdf-isearch-search-page gsd-word))
	  (pdf-isearch-hl-matches (car gsd-matches) gsd-matches t))
      (start-process "evince-gsd" " gsd-processes" "evince"
		     (concat "--page-label="
			     (number-to-string (- (string-to-number
						   (substring (what-page) 5 8))
						  12)))
		     gsd-pdf-path))))

(bind-key "<f9> g" 'gsd)
#+end_src
** Window Dedication
#+begin_src emacs-lisp
;; http://dfan.org/blog/2009/02/19/emacs-dedicated-windows/
(defun toggle-current-window-dedication ()
 (interactive)
 (let* ((window    (selected-window))
        (dedicated (window-dedicated-p window)))
   (set-window-dedicated-p window (not dedicated))
   (message "Window %sdedicated to %s"
            (if dedicated "no longer " "")
            (buffer-name))))

(bind-key [pause] 'toggle-current-window-dedication)
#+end_src
** Chinese Cangjie 5 input
   I created a quail package for Cangjie version 5 using libcangjie's
   dictionary.  The main advantage to using it over the built-in
   =chinese-cns-tsangchi= or =chinese-b5-tsangchi= is that this method
   allows you to type simplified Chinese characters.

#+begin_src emacs-lisp
  (register-input-method
   "Cangjie5" "Chinese-BIG5" 'quail-use-package
   "C5" "Cangjie version 5"
   "cangjie5.el")
#+end_src

   A quick key to help look up Cangjie codes for characters I don't know.
#+begin_src emacs-lisp
  (bind-key "<f9> s" 'quail-show-key)
#+end_src
** Auto fill line
   Sometimes I want to wrap a line, but pressing =M-q= will treat
   everything as one huge paragraph, messing up the structure.
   This simple function acts like we temporarily turn on
   auto-fill-mode, wrap the line, and then turn it off.

#+begin_src emacs-lisp
  (defun josh/fill-line ()
    "Wrap the line"
    (interactive)
    (save-excursion
      (end-of-line)
      (funcall normal-auto-fill-function)))

  (bind-key "M-Q" 'josh/fill-line)
#+end_src
** Switch to scratch buffer
   A quick hotkey for switching to the scratch buffer.
#+begin_src emacs-lisp
  (defun switch-to-scratch ()
    "Switch to scratch"
    (interactive)
    (switch-to-buffer "*scratch*"))
  
  (bind-key "C-h C-s" 'switch-to-scratch)
#+end_src
** Comment a copy
   Sometimes when I'm debugging something, I'll want to make
   modifications to the line I'm working on, but keep a copy of it
   right above. This function allows me to automate that.
#+BEGIN_SRC emacs-lisp
  (defun jmm/comment-a-copy ()
      "Add a commented-out line above the current one.

  If the region is active, add a commented-out version of the region above the region"
      (interactive)
      (save-excursion
          (let* ((beg (if (use-region-p) (min (mark) (point)) (line-beginning-position)))
                 (end (if (use-region-p) (max (mark) (point)) (line-end-position)))
                 (selection (buffer-substring beg end)))
            (goto-char beg)
            (push-mark)
            (insert selection)
            (comment-region (mark) (point)))))

  (bind-key "C-c C" 'jmm/comment-a-copy)
#+END_SRC
** Find the latest file in a directory
   Decent function for finding the most recent file in a
   directory. For example, if I wanted to get the most recently
   downloaded PDF in "~/Downloads"
#+BEGIN_SRC emacs-lisp
(defun josh/latest-file (path glob)
  "Get the latest file in PATH matching the regex GLOB"
  (caar
   (sort (mapcar (lambda (file)
		  (cons (car file) (float-time (file-attribute-modification-time file))))
		(directory-files-and-attributes path 'full glob 'nosort))
	(lambda (file1 file2) (> (cdr file1) (cdr file2))))))
#+END_SRC
** Unfill Paragraph
   From https://www.emacswiki.org/emacs/UnfillParagraph
#+BEGIN_SRC emacs-lisp
;;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph
(defun unfill-paragraph (&optional region)
  "Takes a multi-line paragraph and makes it into a single line of text."
  (interactive (progn (barf-if-buffer-read-only) '(t)))
  (let ((fill-column (point-max))
        ;; This would override `fill-column' if it's an integer.
        (emacs-lisp-docstring-fill-column t))
    ;; Unhyphenate --Josh
    (when region
      (save-excursion
	(while (re-search-forward "-\n" (region-end) t)
	  (replace-match ""))))
    (fill-paragraph nil region)))
(define-key global-map (kbd "C-M-q") 'unfill-paragraph)
#+END_SRC
** Jump to a key's definition
   I use ~C-h k~ a lot to find out more about what an Emacs keybinding
   does. Sometimes I'm interested in just directly jumping to the
   definition of the command, instead of reading in the `*Help*`
   buffer and clicking the link to the definition (which opens a
   separate window, which also annoys me).

   This command, bound to ~C-h C-k~ prompts for a keybinding and jumps
   directly to its definition. You can pop back with ~M-,~.
#+BEGIN_SRC emacs-lisp
(defun jmm/jump-to-key-definition (&optional key-to-check)
  "Kind of like `describe-key', but just jump directly to the
definition without bringing up a help buffer.

If you provide KEY-TO-CHECK, pass it through `kbd' first."
  (interactive (list (caar (help--read-key-sequence))))
  (-if-let (xrefs (xref-backend-definitions 'elisp (nth 1 (help--analyze-key key-to-check nil))))
      (progn
	(xref--push-markers)
	(xref-pop-to-location (car xrefs) nil))
      (user-error "Can't find definition for: %s" key-to-check)))

(bind-key "C-h C-k" 'jmm/jump-to-key-definition)
#+END_SRC
** Opening links with other browsers

    Occasionally I want to open org-mode (or other) links in
    incognito/private mode or my non-default browser. Here I define a
    function that's usable as advice to ~org-open-at-point~, which
    allows me to set specific browser programs and arguments for
    opening a link.

    For example, using ~C-u C-c C-o~, I can open a link in Firefox's
    private mode. With ~C-u 2 C-c C-o~ I can open with Chromium's
    normal mode. And with ~C-u 3 C-c C-o~ I can open with Chromium's
    incognito mode.

    With ~C-u C-u C-c C-o~ the link is instead copied to the kill ring
    and clipboard.

    This is also useful with other things that open links, like ~elfeed~.

 #+BEGIN_SRC emacs-lisp
 (defvar jmm/browse-url-generic-alternate '(("firefox" "--private-window")
					    ("chromium")
					    ("chromium" "--incognito"))
   "A list of programs and arguments to set
   `browse-url-generic-program' and
   `browse-url-generic-args'.")

 (defun jmm/org-open-link-alternate-browser (orig-fun &rest args)
   "With a prefix arg, set `browse-url-generic-program' and
  `browse-url-generic-args' to use different settings in `jmm/browse-url-generic-alternate'.

  With universal prefix, use first option in
  `jmm/browse-url-generic-alternate'. With a number argument, use
  the nth option in `jmm/browse-url-generic-alternate'.

  Handy for opening in other browsers or incognito/private mode."
   (if current-prefix-arg
       (if-let ((jmm/browse-url-alt (pcase current-prefix-arg
				      ('(4) (car jmm/browse-url-generic-alternate))
				      ('(16) nil)
				      (_ (elt jmm/browse-url-generic-alternate (- current-prefix-arg 1))))))
	   (let* ((browse-url-generic-program (car jmm/browse-url-alt))
		  (browse-url-generic-args (cdr jmm/browse-url-alt)))
	     (apply orig-fun args))
	 (jmm/copy-url-at-point))
     (apply orig-fun args)))

 (defun jmm/get-url-at-point--shr ()
   "With the point on some shr link, get the url at point"
   ;; 'shr-url shows up in notmuch HTML messages
   (or (get-char-property (point) 'shr-url)
       (if (save-excursion
	     (goto-char (previous-single-char-property-change
			 (point) 'goto-address nil
			 (line-beginning-position)))
	     (looking-at goto-address-url-regexp))
	   (browse-url-url-at-point))))

 (defun jmm/get-url-at-point--org ()
   "With the point over a link, return the URL."
   (when (derived-mode-p 'org-mode)
     (let* ((context
	     ;; Only consider supported types, even if they are not the
	     ;; closest one.
	     (org-element-lineage
	      (org-element-context)
	      '(clock comment comment-block footnote-definition
		      footnote-reference headline inline-src-block inlinetask
		      keyword link node-property planning src-block timestamp)
	      t))
	    (type (org-element-type context)))
       (when (eq type 'link)
	 (org-element-property :raw-link context)))))

 (defun jmm/get-url-at-point ()
   "Try to get some url at point.
 Should work for org-mode links and shr links, falling back to `browse-url-url-at-point'."
   (or (jmm/get-url-at-point--org)
       (jmm/get-url-at-point--shr)
       (browse-url-url-at-point)))

 (defun jmm/copy-url-at-point ()
   "Copy url at point to kill ring and clipboard.
 See `jmm/get-url-at-point'."
   (interactive)
   (--when-let (jmm/get-url-at-point)
     (kill-new it)
     (gui-set-selection 'PRIMARY it)
     (message "Copied: %s" it)))
 #+END_SRC

 Here's an example of using it on ~shr~ links.
#+BEGIN_SRC emacs-lisp
(use-package shr
  :defer t
  :config
  (advice-add 'shr-browse-url :around #'jmm/org-open-link-alternate-browser))
#+END_SRC
** Search only visible text

   It's just easier to have this hotkey than having to type ~C-s M-s
   i~ all the time. Handy for org-mode.

#+BEGIN_SRC emacs-lisp
(defun jmm/isearch-forward-visible ()
  "Just `isearch-forward` but don't match invisible text."
  (interactive)
  (let ((search-invisible nil))
    (isearch-forward)))

;; I guess it can't just be "C-S" because the "S" looks like it means
;; "shift".
(bind-key "C-S-S" 'jmm/isearch-forward-visible)
#+END_SRC
** Quick jumping to certain files

   Some files I access really frequently. So frequently, in fact, that
   even just using bookmarks is slow. Normally I use a register to
   store their location, but that reduces the number of usable registers.

#+begin_src emacs-lisp
(defmacro jmm/bind-key-for-file-navigation (key nickname location)
  "Make a function and a keybinding for navigating to some location"
  (let ((newname (intern (format "jmm/navigate-to/%s" nickname))))
    `(progn
       (defun ,newname ()
	 ,(format "Navigate to %s" location)
	 (interactive)
	 (find-file ,location))
       (bind-key (kbd ,key) (quote ,newname)))))

(jmm/bind-key-for-file-navigation "M-g D" download-tmp "~/Downloads/tmp")
(jmm/bind-key-for-file-navigation "M-g d" downloads "~/Downloads")
(jmm/bind-key-for-file-navigation "M-g f l" ledger "~/org/josh-ledger.dat")
(jmm/bind-key-for-file-navigation "M-g f e" emacs-config "~/.emacs.d/jmm-emacs.org")
(jmm/bind-key-for-file-navigation "M-g f o" org-config "~/.emacs.d/jmm-org-config.org")
#+end_src
** Printing a junior-sized PDF of the current buffer

   Sometimes I like reading and editing things on paper.

   I use a junior/A5 sized discbound notebook. I have a script called
   ~junior-lpr~ that converts a PDF from letter-sized to junior-sized,
   then prints it. This function is for printing the current buffer
   (with fontification) as a junior-sized PDF. It's pretty useless
   without ~junior-lpr~ though.

#+begin_src emacs-lisp
(defun jmm/print-junior-buffer-with-faces ()
    "Print the current buffer (with font-lock) as a junior-sized pdf.

Based off of Kaushal Modi's `modi/pdf-print-buffer-with-faces' from
https://emacs.stackexchange.com/a/9373
"
    (interactive)
    (let ((tempfile (make-temp-file "ps-file" nil ".ps"))
	  (outfile (make-temp-file "ps-file" nil ".pdf")))
      (unwind-protect
	  (progn
	    (ps-print-buffer-with-faces tempfile)
	    (if (= (call-process "ps2pdf" nil nil nil tempfile outfile) 0)
		(message "ps2pdf %s" outfile)
	      (error "ps2pdf failed"))
	    (if (= (call-process "junior-lpr" nil nil nil outfile) 0)
		(message "junior-lpr succeeded")
	      (error "junior-lpr failed"))
	  (delete-file tempfile)
	  (delete-file outfile)))))
#+end_src


* Emacs Rocks
  Things I got from watching "Emacs Rocks"
** Multiple Cursors
#+begin_src emacs-lisp
(use-package multiple-cursors
  :ensure t
  :bind (("C-S-c C-S-c" . mc/edit-lines)
	 ("C->" . mc/mark-next-like-this)
	 ("C-<" . mc/mark-previous-like-this)
	 ("C-M-<" . mc/mark-all-like-this-dwim)
	 ("C-<mouse-1>" . mc/add-cursor-on-click))
  :init
  (unbind-key "C-<down-mouse-1>")
  :config
  (add-to-list 'mc/cmds-to-run-for-all #'jmm/replace-numbers-with-zero-padding)
  (add-to-list 'mc/cmds-to-run-for-all #'jmm/replace-month-name-with-num))
#+end_src
*** Inserting letters for each cursor
    Basically exactly like ~mc/insert-numbers~ but for letters.
#+BEGIN_SRC emacs-lisp
  (require 'multiple-cursors-core)

  (defun mc/insert-letters (arg)
    "Insert increasing letters for each cursor, starting at 0 or ARG."
    (interactive "cStart at character: ")
    (setq mc--insert-letters-letter (or arg ?a))
    (mc/for-each-cursor-ordered
     (mc/execute-command-for-fake-cursor 'mc--insert-letter-and-increase cursor)))

  (defvar mc--insert-letters-letter 0)

  (defun mc--insert-letter-and-increase ()
    (interactive)
    (insert (char-to-string mc--insert-letters-letter))
    (setq mc--insert-letters-letter (1+ mc--insert-letters-letter)))
#+END_SRC
*** Keymap for multiple-cursor commands
    Taken from http://endlessparentheses.com/multiple-cursors-keybinds.html
#+BEGIN_SRC emacs-lisp
  (define-prefix-command 'endless/mc-map)
  ;; C-x m is usually `compose-mail'. Bind it to something
  ;; else if you use this command.
  (define-key ctl-x-map "m" 'endless/mc-map)

  ;;; Really really nice!
  (define-key endless/mc-map "i" #'mc/insert-numbers)
  (define-key endless/mc-map "h" #'mc-hide-unmatched-lines-mode)
  (define-key endless/mc-map "a" #'mc/mark-all-like-this)

  ;;; Occasionally useful
  (define-key endless/mc-map "d"
    #'mc/mark-all-symbols-like-this-in-defun)
  (define-key endless/mc-map "r" #'mc/reverse-regions)
  (define-key endless/mc-map "s" #'mc/sort-regions)
  (define-key endless/mc-map "l" #'mc/edit-lines)
  (define-key endless/mc-map "\C-a"
    #'mc/edit-beginnings-of-lines)
  (define-key endless/mc-map "\C-e"
    #'mc/edit-ends-of-lines)

  (define-key endless/mc-map " " #'mc/vertical-align-with-space)
  (define-key endless/mc-map "|" #'mc/vertical-align)
#+END_SRC
*** Disable primary selection for multiple cursors
    Setting ~x-select-enable-primary~ allows me to paste into emacs from an xterm selection using "~C-y~" (yank)
    A problem, though, is that it breaks ~kill-ring-save~ yanking with multiple-cursors
    You can still paste from the X primary selection using middle click

    But since I want to copy from dired using ~w~ and paste into
    xterm, I'll only disable ~x-select-enable-primary~ while using multiple cursors.

#+BEGIN_SRC emacs-lisp
(add-hook 'multiple-cursors-mode-enabled-hook (lambda () (setq select-enable-primary nil)))
(add-hook 'multiple-cursors-mode-disabled-hook (lambda () (setq select-enable-primary t)))
#+END_SRC
*** Replacing month names with numbers
    I need to replace month names with numbers a lot when formatting
    calendar events.
#+BEGIN_SRC emacs-lisp
(defvar jmm/month-names
  '(("\\bJan\\(uary\\)?\\b" "01")
    ("\\bFeb\\(ruary\\)?\\b" "02")
    ("\\bMar\\(ch\\)?\\b" "03")
    ("\\bApr\\(il\\)?\\b" "04")
    ("\\bMay\b" "05")
    ("\\bJun\\(e\\)?\\\b" "06")
    ("\\bJul\\(y\\)?\\b" "07")
    ("\\bAug\\(ust\\)?\\b" "08")
    ("\\bSept?\\(ember\\)?\\b" "09")
    ("\\bOct\\(ober\\)?\\b" "10")
    ("\\bNov\\(ember\\)?\\b" "11")
    ("\\bDec\\(ember\\)?\\b" "12")))

(defun jmm/replace-month-name-with-num (beginning end)
  "Replace month names with numbers in active region.
Useful for formatting dates for inputs into calendars."
  (interactive "r")
  (when (use-region-p)
    (cl-dolist (thismonth jmm/month-names)
      (-let [(searchexpr replaceresult) thismonth]
	  (save-excursion
	    (goto-char beginning)
	    (while (re-search-forward searchexpr end t)
	      (replace-match replaceresult))
	    )))))

(define-key endless/mc-map "M" #'jmm/replace-month-name-with-num)
#+END_SRC
*** Zero padding multiple cursors
    The function ~mc/insert-numbers-default~ is pretty handy, but
    sometimes I need integers to be zero padded to the same
    length. This function helps me do that.

#+BEGIN_SRC emacs-lisp
(defun jmm/replace-numbers-with-zero-padding (numzeros beginning end)
  "Replace numbers/integers in active region with zero-padded versions.
This is also handy when using multiple cursors."
  (interactive "P\nr")
  (when (use-region-p)
    (let ((formatstr (format "%%0%dd" (if (listp numzeros) 2 numzeros)))
	  (end-marker (set-marker (make-marker) end))) ;; Replacing can affect the region's end..
      (save-excursion
	(goto-char (region-beginning))
	(while (re-search-forward "[0-9]+" end-marker t)
	  (replace-match (format formatstr (string-to-number (match-string 0)))))))))

(define-key endless/mc-map "0" #'jmm/replace-numbers-with-zero-padding)
#+END_SRC

** Expand Region
#+begin_src emacs-lisp
(use-package expand-region
  :ensure t
  :bind ("C-=" . er/expand-region))
#+end_src
** Ace Jump Mode
#+begin_src emacs-lisp
  (use-package ace-jump-mode
               :disabled
               :bind (("C-0" . ace-jump-mode)
                      ("C-x C-SPC" . ace-jump-mode-pop-mark))
               :init (progn
                       ;; To set to only use lowercase
                       (setq ace-jump-mode-case-fold t)
                       (setq ace-jump-mode-scope 'frame)))
  ;; (setq ace-jump-mode-move-keys (loop for i from ?a to ?z collect i))
#+end_src
*** Ace Jump Zap
#+BEGIN_SRC emacs-lisp
(use-package ace-jump-zap
  :ensure t :defer t
  :bind
  (("M-z" . ace-jump-zap-up-to-char-dwim)
   ("M-Z" . ace-jump-zap-to-char-dwim)))
#+END_SRC
*** ace-mc
    My own package! Check it out [[https://github.com/mm--/ace-mc][here]].
    It basically makes adding multiple cursors easier.
#+BEGIN_SRC emacs-lisp
(use-package ace-mc
  :ensure t
  :bind
  (("C-)" . ace-mc-add-multiple-cursors)
   ("C-M-)" . ace-mc-add-single-cursor)))
#+END_SRC
** Avy
   [[https://github.com/abo-abo/avy/][Avy]] is like ace-jump-mode, but apparently better updated and with
   some newer features. I haven't really gotten around to using it
   instead of ace-jump-mode yet, but I'm trying to see what it has to offer.
#+BEGIN_SRC emacs-lisp
(use-package avy
  :ensure t
  ;; The override global map was breaking ivy-avy
  ;; :bind* (("C-'" . avy-goto-char-timer)
  ;; 	  ("C-0" . avy-goto-word-1))
  :bind (("C-:" . avy-goto-char-2)
	 ("M-g w" . avy-goto-word-1)
	 ("C-'" . avy-goto-char-timer)
	 ("C-0" . avy-goto-word-1)
	 :map isearch-mode-map
	 ("C-'" . avy-isearch))
  :init (setq avy-keys (number-sequence ?a ?z)
	      avy-style 'at-full
	      avy-single-candidate-jump nil ;; I'd like to be able to yank/teleport single candidates
	      avy-background t
	      avy-timeout-seconds 0.5)
  :config
  ;; Unfortunately I use all lowercase letters as candidate keys. So
  ;; dispatch keys need to be uppercase or modified with the control key.
  (setq avy-dispatch-alist
	'((?M . jmm/avy-action-add-mc)
	  (?X . avy-action-kill-stay)
	  (?\C-k . jmm/avy-action-kill-line-stay)
	  (?T . avy-action-teleport)
	  (?\C-t . jmm/avy-action-teleport-line)
	  (?\C-r . jmm/avy-action-replace-stay)
	  (?\C-s . jmm/avy-action-swap)
	  (?Y . avy-action-yank)
	  (?\C-y . jmm/avy-action-yank-line)
	  (?C . avy-action-copy)
	  (?\C-c . jmm/avy-action-copy-line)
	  (?I . avy-action-ispell)
	  (?Z . avy-action-zap-to-char)
	  (?\C-z . jmm/avy-action-zap-up-to-yank-with-avy)
	  (?\M-z . jmm/avy-action-zap-up-to-yank)))
  (advice-add 'avy--read-candidates :around #'jmm/avy--hide-timer-overlays))
#+END_SRC

You can add a multiple cursor by customizing
~avy-dispatch-alist~. Here I define a function that adds a multiple
cursor to an avy candidate. The way you use it is as follows: Use your
favorite avy jump technique (~avy-goto-char-timer~ or
~avy-goto-word-1~ for example), and before pressing the candidate key,
press capital ~M~. Then press the candidate key. This will leave your
cursor in place but add a multiple cursor to the candidate location.

One caveat is that you /need/ to have multiple candidates to use
~avy-dispatch-alist~. If there's only one candidate, you'll
immediately jump to it without giving you a chance to activate the ~M~
dispatch action. (Since writing this I realized you should just change
~avy-single-candidate-jump~ to ~nil~)
#+BEGIN_SRC emacs-lisp
(defun jmm/avy-action-add-mc (pt)
  "Add multiple cursor at PT."
  (save-excursion
    (goto-char pt)
    (mc/create-fake-cursor-at-point)
    (mc/maybe-multiple-cursors-mode)
    ;; (avy-resume) ;; You can kind of get a terrible "ace-mc" type
    ;; thing going by automatically resuming after selecting a
    ;; targt. However, the overlays don't appear over avy's
    ;; background.
    ))
#+END_SRC
*** Hide premature background overlays for avy timers
Some commit this year made timers show backgrounds /immediately/, even
before you had any candidates to select. Probably due to the theme I'm
using this made it harder to select candidates. This function advice
restores the old behavior.
#+BEGIN_SRC emacs-lisp
(defun jmm/avy--hide-timer-overlays (orig-fun &rest args)
  "Advice to hide backgrounds on avy timers. I only want to show
backgrounds once there are candidates to select."
  (let (avy-background)
    (apply orig-fun args)))
#+END_SRC
*** Other convenience dispatch actions

Avy has a really cool feature where you can change what action will
happen to the candidate select. This makes it really easy to copy a
symbol to the point you're currently at.

Here I add some other convenience functions like teleporting and
yanking the rest of a line, which is helpful sometimes in command
prompts. Theoretically you should be able just to switch
~avy-command~, but I haven't found out how to do that on the fly.

#+BEGIN_SRC emacs-lisp
(defun jmm/avy-action-yank-line (pt)
  "Yank the rest of the line at point here."
  (let ((avy-command 'avy-goto-line))
    (avy-action-yank pt)))

(defun jmm/avy-action-copy-line (pt)
  "Copy the rest of the line at point here."
  (let ((avy-command 'avy-goto-line))
    (avy-action-copy pt)))

(defun jmm/avy-action-teleport-line (pt)
  "Teleport the rest of the line at point here."
  (let ((avy-command 'avy-goto-line))
    (avy-action-teleport pt)))

(defun jmm/avy-action-kill-line-stay (pt)
  "Kill the rest of the line at point here but stay here."
  (let ((avy-command 'avy-goto-line))
    (avy-action-kill-stay pt)))
#+END_SRC

Here are functions for swapping two locations, or replacing one
location with what you have under point.
#+BEGIN_SRC emacs-lisp
(defun jmm/avy--kill-sexp-at-old-position ()
  "Swtich to the old window, kill the sexp at point and return the string."
  (with-selected-window (cdr (ring-ref avy-ring 0))
    (let ((thing-bounds (bounds-of-thing-at-point 'sexp))
	  (oldstr (thing-at-point 'sexp)))
      (kill-region (car thing-bounds) (cdr thing-bounds))
      oldstr)))

(defun jmm/avy-action-replace-stay (pt)
  "Replace sexp at PT with the one we're currently at (point).
The sexp at point is looked for backwards as well as forwards.
For example, if you just typed \"hello\" and had your point past
the \"o\", it'll still use \"hello\" to replace stuff."
  (let ((m1 (set-marker (make-marker) pt))
	(oldstr (jmm/avy--kill-sexp-at-old-position)))
    (save-excursion
      (goto-char m1)
      (avy-forward-item)
      (kill-region m1 (point))
      (insert oldstr))
    (set-marker m1 nil))
  (message "Killed: %s" (current-kill 0))
  (select-window
   (cdr
    (ring-ref avy-ring 0)))
  t)

(defun jmm/avy-action-swap (pt)
  "Swap sexp at PT with the one we're currently at (point).
The sexp at point is looked for backwards as well as forwards.
For example, if you just typed \"hello\" and had your point past
the \"o\", it'll still use \"hello\" to replace stuff.

Note: Only swaps starting from PT. So if you want to swap the
whole sexp, start at the beginning character.
Note: This also messes up with multiple windows"
  (let ((m1 (set-marker (make-marker) pt))
	(oldstr (jmm/avy--kill-sexp-at-old-position)))
    (save-excursion
      (goto-char m1)
      (avy-forward-item)
      (kill-region m1 (point))
      (insert oldstr))
    (set-marker m1 nil))
  (select-window
   (cdr
    (ring-ref avy-ring 0)))
  (yank)
  t)
#+END_SRC

Here are some functions for yanking some text from a remote point by
zapping to a character.

#+begin_src emacs-lisp
(defun jmm/avy-action-zap-up-to (pt)
  "Zap up to character. Copy it."
  (save-excursion
    (goto-char pt)
    (let ((direction 1)
	  (char (read-char-from-minibuffer "Avy zap up to char: "
					   nil 'read-char-history))
	  str)
      (setq str (buffer-substring (point)
				  (progn
				    (forward-char direction)
				    (unwind-protect
					(search-forward (char-to-string char))
				      (backward-char direction))
				    (point))))
      (kill-new str)
      (message "Copied: %s" str)))
  (let ((dat (ring-ref avy-ring 0)))
    (select-frame-set-input-focus
     (window-frame (cdr dat)))
    (select-window (cdr dat))
    (goto-char (car dat))))

(defun jmm/avy-action-zap-up-to-with-avy (pt)
  "Avy-zap up to character. Copy it."
  (save-excursion
    (goto-char pt)
    (let ((direction 1)
	  (char (read-char-from-minibuffer "Avy zap up to char: "
					   nil 'read-char-history))
	  (avy-all-windows nil)
	  str)
      (setq str (buffer-substring (point)
				  (progn
				    (avy-with avy-goto-char
				      (avy-jump
				       (if (= 13 char)
					   "\n"
					 (regexp-quote (string char)))
				       :beg (point)
				       :end (save-excursion
					      (forward-paragraph)
					      (point))))
				    (point))))
      (kill-new str)
      (message "Copied: %s" str)))
  (let ((dat (ring-ref avy-ring 1)))
    (select-frame-set-input-focus
     (window-frame (cdr dat)))
    (select-window (cdr dat))
    (goto-char (car dat))))

(defun jmm/avy-action-zap-up-to-yank (pt)
  "Zap up to character and yank"
  (jmm/avy-action-zap-up-to pt)
  (yank)
  t)

(defun jmm/avy-action-zap-up-to-yank-with-avy (pt)
  "Avy-zap up to character and yank"
  (jmm/avy-action-zap-up-to-with-avy pt)
  (yank)
  t)

#+end_src


* Nix

  [[https://nixos.org/nix/][Nix]] is an awesome way to declaratively build and distribute
  packages.

  Its purely functional expression language enforces a kind of
  discipline of rigorously defining all dependencies needed to build
  something (be it a binary, Emacs configuration, etc.).

  I'm currently using it to manage parts of my Emacs configuration,
  build packages/tools (like shell scripts that need specific binaries
  installed), as well as using it to perform distributed builds of
  some Bayesian data analyses I'm working on.

** Nix environment
  
  I have a small Emacs lisp file that gets loaded which adds a Nix
  ~buildEnv~ to ~exec-path~ and ~PATH~. It includes binaries that I
  find helpful to have installed alongside Emacs, such as "grip" for
  markdown rendering and ~silver-searcher~. This loads it if it finds
  it.

#+BEGIN_SRC emacs-lisp
(require 'jmm-add-nix-path nil t)
#+END_SRC
** Rename man page buffers under Nix

   When you look up man pages with Emacs in Nix, you end up with
   buffer names like "\*Man -l
   /run/current-system/sw/share/man/man1/cat.1.gz\*". This is way too
   verbose and makes it hard to switch buffers (as the name of the
   command usually gets clipped from the end).

   This function and hook renames man page buffers, getting rid of the
   path information.

#+BEGIN_SRC emacs-lisp
(defun jmm/man-rename-nix-man-page ()
  "Renames a man page and gets rid of the nix path."
  (interactive)
  (when (s-match "^\\*Man " (buffer-name))
    (rename-buffer (->> (buffer-name)
			(s-replace-regexp " -l " " ")
			(s-replace-regexp "/.+/" "" )
			(s-replace-regexp "\\.gz\\*" "*"))
		   t)))

;; (add-hook 'Man-mode-hook #'jmm/man-rename-nix-man-page)
#+END_SRC
** Jumping to the definition of a Nix attribute

   Nix already has the command ~nix edit nixpkgs.emacs26~, which will
   open up your ~$EDITOR~ (obviously Emacs) to the nix expression
   defining a derivation.

   However, this doesn't seem to work for attributes that define
   functions. Like, ~nix edit nixpkgs.lib.attrsets.attrByPath~ won't
   find where it's defined. This is interesting since you can type
   ~lib.attrsets.attrByPath~ into a ~nix repl '<nixpkgs>'~ and it'll
   show you the file, line, and column.

   These functions allow you to find where an attribute is declared
   and then jump to it.

   One thing to note, though, is that although ~nix edit
   nixpkgs.emacs26~ will open the ~emacs/default.nix~ expression,
   ~(jmm/nix-goto-attr-definition "emacs26")~ will actually go to the
   "emacs26" attribute in ~all-packages.nix~.

#+BEGIN_SRC emacs-lisp
(defun jmm/nix-get-attr-definition-position (attrpath)
  "Given a Nixpkgs ATTRPATH like \"rPackages.rstan\", return an
  alist of the file, line, and column the attribute was defined
  bin.
  This function automatically adds \"pkgs\" to the front of attrpath. "
  (let* ((attrpath (s-split "\\." attrpath))
	 (parentpath (s-join "." (cons "pkgs" (butlast attrpath))))
	 (attrname (car (last attrpath)))
	 (evalstr (format "(with import <nixpkgs> {}; builtins.unsafeGetAttrPos \"%s\" %s)"
			  attrname
			  parentpath)))
    (json-read-from-string
     (with-output-to-string
       (with-current-buffer
	   standard-output
	 (process-file "nix" nil t nil "eval" "--json" evalstr))))))

;; TODO: Make this something like xref-find-definitions
;; Possibly use a cached "nix search --json" for completion.
(defun jmm/nix-goto-attr-definition (attrpath)
  "Given a Nixpkgs ATTRPATH like \"rPackages.rstan\", jump to its definition position."
  (interactive (list (xref--read-identifier "Find definitions of: ")))
  (-if-let ((&alist 'file file 'line line 'column column) (jmm/nix-get-attr-definition-position attrpath))
      (progn
	(xref-push-marker-stack)
	(find-file file)
	(goto-line line)
	(move-to-column (1- column)))	; Not sure if the column is correct
    (error "Can't find definition of %s" attrpath)))
#+END_SRC
** Jump to a dired buffer of the Nix store that provides a command

   What package provides ~iwgetid~ in Nix or NixOS? Sometimes I want
   to find what other binaries are distributed with the same package.
   ~(jmm/nix-which-dired "iwgetid")~ goes to the Nix store path
   containing the binary, and shows all other files installed by that
   package.

#+BEGIN_SRC emacs-lisp
(defun jmm/nix-which-dired (commandname)
  "View a dired buffer that provides COMMANDNAME."
  (interactive (list (read-shell-command "Command name: ")))
  (dired
   (->
    (shell-command-to-string
     (format "realpath $(which %s)" (shell-quote-argument commandname)))
    string-trim-right
    ;; Seems like a weird way to go up two directories....
    directory-file-name
    file-name-directory
    directory-file-name
    file-name-directory)
   "-alhvR")
  (dired-goto-file
   (string-trim-right
    (shell-command-to-string
     (format "realpath $(which %s)" (shell-quote-argument commandname))))))
#+END_SRC

* LSP

  The [[https://en.wikipedia.org/wiki/Language_Server_Protocol][Language Server Protocol]] seems like a decent way to unify code
  editing facilities across different languages and editors. It kind
  of reminds me of Emacs's version control mode, which is nice in that
  you only need to learn one set of keybindings.

#+BEGIN_SRC emacs-lisp
;; See https://emacs-lsp.github.io/lsp-mode/page/performance/
;; (setq gc-cons-threshold 100000000)
(setq read-process-output-max (* 1024 1024)) ;; 1mb

;; Adapted from https://emacs-lsp.github.io/lsp-mode/page/installation/
(setq lsp-keymap-prefix "M-k")
;; (define-key lsp-mode-map (kbd "M-k") lsp-command-map)

(use-package lsp-mode
  :if (not noninteractive)
  :hook ((python-mode . lsp))
  :commands lsp)
#+END_SRC

* Other modes
** Enriched Mode
#+begin_src emacs-lisp
(add-hook 'enriched-mode-hook
 (lambda ()
   (define-key enriched-mode-map [remap newline-and-indent] nil)
   (define-key enriched-mode-map "\C-m" nil)
   (define-key enriched-mode-map [remap move-beginning-of-line] nil)
   ))
#+end_src
** Java Mode
#+begin_src emacs-lisp
(add-hook 'java-mode-hook
	  (lambda ()
	    (c-set-style "java")))
#+end_src
** Ledger
#+begin_src emacs-lisp
(use-package ledger
  :commands ledger-mode
  :ensure ledger-mode)
#+end_src

Seems like something changed (or I changed something) that stopped tab
completion. This code from the manual brings it back.
#+BEGIN_SRC emacs-lisp
(add-hook 'ledger-mode-hook
          (lambda ()
            (setq-local tab-always-indent 'complete)
            (setq-local completion-cycle-threshold t)
            (setq-local ledger-complete-in-steps t)
	    ;; Company-mode is messing up ledger.
	    ;; See https://github.com/syl20bnr/spacemacs/issues/12024
	    ;; TODO: Add this snippet in a section that depends on both ledger and company
	    (company-mode -1)
	    ))
#+END_SRC

** Swank-js
#+begin_src emacs-lisp
  (add-hook 'css-mode-hook
             (lambda ()
               (define-key css-mode-map "\M-\C-x" 'slime-js-refresh-css)
               (define-key css-mode-map "\C-c\C-r" 'slime-js-embed-css)))
#+end_src
#+begin_src emacs-lisp
  (bind-key [f5] 'slime-js-reload)
  ;; (add-hook 'js-mode-hook
  ;;           (lambda ()
  ;;             (js2-minor-mode 1)
  ;;             (auto-complete-mode 1)))
#+end_src
** js2-mode
   Use js2-mode by default
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+end_src
   I prefer less indentation.
#+begin_src emacs-lisp
  (setq-default js2-basic-offset 4)
#+end_src
   I'm checking style/semicolons/whatever with eslint, so I don't want js2-mode to tell me about it.
#+BEGIN_SRC emacs-lisp
(setq-default js2-strict-missing-semi-warning nil)
(setq-default js2-mode-show-parse-errors nil)
(setq-default js2-mode-show-strict-warnings nil)
#+END_SRC
** Tern.js for Javascript
   [[http://ternjs.net/][Tern]] seems to be a pretty cool tool much like ctags.

   It's able to find the definitions of functions and variables in
   your javascript files as well as tell you the type of variable.

#+begin_src emacs-lisp
(add-to-list 'load-path "~/Downloads/tern/emacs")
(use-package tern
  :commands tern-mode
  :config (add-hook 'js2-mode-hook (lambda () (tern-mode t))))
#+end_src
** Projectile
   Projectile is a neat library that makes it easy to deal with
   various tasks in a project. For example, it makes it easy to switch
   to project-related buffers or to search all buffers.

   This configuration also turns on ~helm-projectile~ bindings by default.
#+begin_src emacs-lisp
(use-package projectile
  :ensure t
  :diminish projectile-mode
  :bind-keymap ("C-c p" . projectile-command-map)
  :bind (:map projectile-command-map
	      ("x x" . jmm/projectile-start-xterm))
  :config
  (progn
    (projectile-global-mode)
    ;; Easily switch between .html, .js, and .css
    (add-to-list 'projectile-other-file-alist '("html" "css" "js"))
    (add-to-list 'projectile-other-file-alist '("js" "css" "html"))
    (setq projectile-svn-command "find . -type f -not -iwholename '*.svn/*' -print0")
    (setq projectile-completion-system 'helm-comp-read)))

(use-package helm-projectile
  :ensure t
  :after projectile
  :config
  (helm-projectile-toggle 1))
#+end_src
*** Start xterm in projectile root
#+BEGIN_SRC emacs-lisp
(defun jmm/projectile-start-xterm ()
  "Start an xterm in the projectile root"
  (interactive)
  (start-xterm (projectile-project-root)))
#+END_SRC

** Yasnippet
   So I can have recursive snippets.
#+begin_src emacs-lisp
(use-package yasnippet
  :if (not noninteractive)
  :ensure t
  :commands (yas-global-mode yas-minor-mode)
  :init
  (setq yas-triggers-in-field t)
  (add-hook 'text-mode-hook 'yas-minor-mode)
  :config
  (yas-reload-all))
#+end_src
** Switch window
   A visual way to switch windows. Kind of like ace-jump, but for windows.
#+BEGIN_SRC emacs-lisp
  (use-package switch-window
    :disabled t
    :bind ("C-x o" . switch-window))
#+END_SRC
** Smartparens
#+BEGIN_SRC emacs-lisp
(use-package smartparens
  :if (not noninteractive)
  :ensure t
  :defer 4
  :disabled
  :init
  (progn (require 'smartparens-config)
	 ;; Profiler seems to suggest "sp-show--pair-function" is
	 ;; causing a bit of a slowdown when typing.
	 (add-to-list 'sp-ignore-modes-list 'latex-mode)
         (smartparens-global-mode t)
	 (fset 'my-wrap-with-paren "\C-](")

         (show-smartparens-global-mode t))

  ;; Mostly just the default bindings
  :bind (:map smartparens-mode-map
	      ("C-M-f" . sp-forward-sexp)
	      ("C-M-b" . sp-backward-sexp)

	      ("C-M-d" . sp-down-sexp)
	      ("C-M-a" . sp-backward-down-sexp)
	      ("C-S-a" . sp-beginning-of-sexp)
	      ("C-S-d" . sp-end-of-sexp)
	      
	      ("C-M-e" . sp-up-sexp)
	      ("C-M-u" . sp-backward-up-sexp)
	      ("C-M-t" . sp-transpose-sexp)
	      ("C-M-n" . sp-next-sexp)
	      ("C-M-p" . sp-previous-sexp)

	      ("C-M-k" . sp-kill-sexp)
	      ("C-M-w" . sp-copy-sexp)
	      ;; ("M-<delete>" . sp-unwrap-sexp)
	      ;; I usually use backword kill
	      ;; ("M-<backspace>" . sp-backward-unwrap-sexp)
	      ("C-<right>" . sp-forward-slurp-sexp)
	      ("C-<left>" . sp-forward-barf-sexp)
	      ("C-M-<left>" . sp-backward-slurp-sexp)
	      ("C-M-<right>" . sp-backward-barf-sexp)

	      ("M-D" . sp-splice-sexp)
	      ("M-S" . sp-split-sexp)
	      ("C-M-<delete>" . sp-splice-sexp-killing-forward)
	      ("C-M-<backspace>" . sp-splice-sexp-killing-backward)
	      ("C-S-<backspace>" . sp-splice-sexp-killing-around)

	      ("C-]" . sp-select-next-thing-exchange)
	      ("C-<left_bracket>" . sp-select-previous-thing)
	      ("C-M-]" . sp-select-next-thing)
	      ("C-(" . my-wrap-with-paren)
	      
	      ("M-F" . sp-forward-symbol)
	      ("M-B" . sp-backward-symbol)))
#+END_SRC
** Ag
#+BEGIN_SRC emacs-lisp
(use-package helm-ag
  :ensure t
  :bind ("<f9> a" . helm-ag)
  :config
  (advice-add 'helm-ag--persistent-action :after #'jmm/helm-ag-org-reveal))

(defun jmm/helm-ag-org-reveal (&rest args)
  "Use `org-reveal' when using `helm-ag'"
  (when (eq major-mode 'org-mode)
    (org-reveal)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package ag
  ;; TODO: Perhaps :ensure-system-package or :when ag is installed
  :bind ("<f9> A" . ag-project-at-point)
  :init
  (progn
    (setq ag-highlight-search t)))
#+END_SRC
** Wgrep
   Wgrep is pretty cool. It's like wdired, but for grep (duh),
   allowing you to make changes directly in a \*grep\* buffer.
#+BEGIN_SRC emacs-lisp
(use-package wgrep
  :ensure t
  :init
  (progn
    (setq wgrep-auto-save-buffer t)
    (setq wgrep-enable-key "r"))
  :after (grep))
#+END_SRC
** nxml mode
   Turn off flyspell mode with nxml, as for whatever reason it hangs.
#+BEGIN_SRC emacs-lisp
  (add-hook 'nxml-mode-hook  (lambda () (flyspell-mode -1)))
#+END_SRC
** skewer-mode
   Some functions to evaluate either the region (if active) or the last expression.
#+BEGIN_SRC emacs-lisp
(defun skewer-eval-last-expression-or-region (&optional prefix)
  "Evaluate the JavaScript expression before the point in the
waiting browser. If invoked with a prefix argument, insert the
result into the current buffer."
  (interactive "P")
  (if (use-region-p)
      (skewer-eval-region (region-beginning) (region-end))
    (skewer-eval-last-expression prefix)))

(defun skewer-eval-region (beg end)
  "Execute the region as JavaScript code in the attached browsers."
  (interactive "r")
  (deactivate-mark)
  (skewer-flash-region beg end)
  (skewer-eval (buffer-substring beg end) #'skewer-post-minibuffer))

(use-package skewer-mode
  :commands (skewer-mode skewer-html-mode skewer-css-mode run-skewer)
  :config
  (define-key skewer-mode-map (kbd "C-x C-e") 'skewer-eval-last-expression-or-region))
#+END_SRC
** diff-hl
   Diff-hl seems to be a useful way to visualize uncommitted changes in a file.
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :disabled t
    :config
    (add-hook 'dired-mode-hook 'diff-hl-dired-mode))
#+END_SRC
** Octave mode
   Open ".m" files with ~octave-mode~ by default
#+BEGIN_SRC emacs-lisp
  (autoload 'octave-mode "octave" nil t)
  ;; (setq auto-mode-alist
  ;;       (cons '("\\.m$" . octave-mode) auto-mode-alist))
#+END_SRC
** Matlab mode
   For a lot of neural science stuff, I have to use Matlab instead of Octave.

   I use a remote session, which means I usually set
   ~matlab-shell-command~ to a shell script that runs matlab over ssh.
#+BEGIN_SRC emacs-lisp
(use-package matlab
  :mode ("\\.m$" . matlab-mode)
  :init
  (setq matlab-shell-echoes nil)
  :config
  (define-key matlab-mode-map (kbd "C-c C-j") 'matlab-shell-run-region-or-line)) 
#+END_SRC

** Pdf-tools
   [[https://github.com/politza/pdf-tools][pdf-tools]] is a great package that makes viewing PDFs in Emacs much
   easier. Basically it's a replacement to DocView, but it allows you
   to do things such as incremental search, highlighting, and clicking
   on links.
#+BEGIN_SRC emacs-lisp
;; TODO: Automatically install?
(use-package pdf-tools
  :mode ("\\.[pP][dD][fF]\\'" . pdf-view-mode)
  :init
  (setq pdf-view-continuous nil)
  (advice-add 'abort-if-file-too-large :around #'jmm/dont-prompt-about-large-pdf-files)
  :config
  (pdf-tools-install)
  :bind (:map pdf-view-mode-map
	      ("x" . xah-open-in-external-app)
	      ("M-s o" . pdf-occur)
	      ("e" . jmm/pdf-view-espeak-page)
	      ("E" . jmm/pdf-edit-helm-bibtex-notes)
	      ("a" . jmm/pdf-annotate-hydra/body)
	      ("c" . jmm/pdf-view-copy-text-other-window)
	      ("C-c C-o" . jmm/pdf-crop-image-width)))
#+END_SRC

*** Espeak a PDF page

    Have Espeak read a PDF page for you.

#+BEGIN_SRC emacs-lisp
(defvar josh/espeak-speed
  300
  "Default espeak WPM")

(defvar jmm/espeak-script
  "espeak-mpv"
  "Location of a shell script to run espeak. This script should
  take one argument, the initial words-per-minute (WPM) speed.")

(defun jmm/pdf-view-unfill-text (&optional deactivate default)
  "Take the PDF active region and unfill text, removing hyphens.

With optional arg DEACTIVATE, deactivate region afterward. With
argument DEFAULT, unfill this string if the region is not active."
  (let ((pdf-text (prog1
		      (if pdf-view-active-region
			  (mapconcat 'identity
				     (pdf-view-active-region-text)
				     " ")
			default)
		    (when deactivate (pdf-view-deactivate-region)))))
    (when pdf-text
      (->> pdf-text
	   (replace-regexp-in-string "-\n" "")
	   (replace-regexp-in-string "\n" " ")))))

(defun jmm/pdf-view-espeak-page (&optional arg)
  "Espeak current PDF page (or current selection) in PDF view.
   Optional ARG takes an WPM speed (i.e. \"4\" becomes 400 WPM)"
  (interactive "P")
  (let* ((wpm (number-to-string (if arg (* arg 100) josh/espeak-speed)))
	 (pdf-text (jmm/pdf-view-unfill-text t (progn (unless pdf-view-active-region (pdf-view-mark-whole-page))
						    (pdf-view-active-region-text))))
	 (fixed-pdf-text (replace-regexp-in-string "\\. \\([A-Z]\\)" ".\n\\1" pdf-text))
	 (process (start-process "espeak-process" " *espeak-pdf-view*" jmm/espeak-script wpm)))
    (process-send-string process (concat fixed-pdf-text "\n"))
    (process-send-eof process)))
#+END_SRC

*** Open bibtex notes

Many of the PDFs I open are stored in my ~org-ref~ / ~helm-bibtex~
directory. I'd like a hotkey to open notes I have for a PDF. This
function splits the window slightly and opens the notes file there.

#+BEGIN_SRC emacs-lisp
(defun jmm/pdf-edit-helm-bibtex-notes ()
  "Edit the notes for the PDF, assuming it's in one of our bibtex files"
  (interactive)
  (let ((key (file-name-base)))
    (when (= (length (window-list)) 1)
      (split-window nil -90 'left))
    (other-window 1)
    (bibtex-completion-edit-notes (list key))))
#+END_SRC

*** Keys to highlight with colors

    Pdf-tools makes highlighting fairly straightforward. Here I
    provide a hydra that makes it easy to quickly choose colors and
    annotation types for PDFs. To use it, select some text you want to
    highlight/underline/strike-out and press "~a~".

#+BEGIN_SRC emacs-lisp
(require 'hydra)
(defvar jmm/pdf-annot-type 'highlight)

(defun jmm/pdf-add-annot (color)
  (let ((regiontext (jmm/pdf-view-unfill-text)))
    (kill-new regiontext)
    (let* ((annot-id (alist-get 'id
				(pdf-annot-add-markup-annotation (pdf-view-active-region t) jmm/pdf-annot-type color)))
	   (file (bookmark-buffer-file-name))
	   (desc regiontext)
	   link)
      (org-store-link-props :type "pdfview" :annot annot-id :file file)
      (setq link (format "pdfview:%s::%s" file (list :annot annot-id)))
      (org-add-link-props :link link :description desc)
      (push (list link desc) org-stored-links)
      link)))

(defhydra jmm/pdf-annotate-color-hydra (:exit t)
  "Color"
  ("y" (jmm/pdf-add-annot "yellow") "yellow")
  ("b" (jmm/pdf-add-annot "blue") "blue")
  ("g" (jmm/pdf-add-annot "green") "green")
  ("o" (jmm/pdf-add-annot "orange") "orange")
  ("r" (jmm/pdf-add-annot "red") "red")
  ("B" (jmm/pdf-add-annot "brown") "brown")
  ("p" (jmm/pdf-add-annot "pink") "pink")
  ("v" (jmm/pdf-add-annot "violet") "violet")
  ("q" nil "cancel"))

(defun jmm/pdf-annotate-run-hydra-with-type (type)
  "See `pdf-annot-add-markup-annotation' for possible TYPEs"
  (setq jmm/pdf-annot-type type)
  (let ((jmm/pdf-annot-type type))
    (jmm/pdf-annotate-color-hydra/body)))

(defhydra jmm/pdf-annotate-hydra (:exit t)
  "Annotate"
  ("h" (jmm/pdf-annotate-run-hydra-with-type 'highlight) "highlight")
  ("s" (jmm/pdf-annotate-run-hydra-with-type 'squiggly) "squiggly")
  ("u" (jmm/pdf-annotate-run-hydra-with-type 'underline) "underline")
  ("o" (jmm/pdf-annotate-run-hydra-with-type 'strike-out) "strike-out")
  ("q" nil "cancel"))
#+END_SRC

*** Clip an image

    A really cool feature of PDF Tools is that there's a command
    ~pdf-view-extract-region-image~ that's bound to ~C-c C-i~. By
    holding down ~Meta~ and dragging your mouse, you can easily select
    a region to clip. The only problem (for me) is that sometimes this
    clipped image is kinda small. If I want to use the image in a
    presentation, I'd like a high-resolution version.

    This command allows me to extract an image with a specified width.

#+BEGIN_SRC emacs-lisp
(require 'dash)
(defvar jmm/pdf-image-preferred-width 1000
  "Default width for cropping an image")

(defun jmm/pdf-crop-image-width (&optional arg)
  "Crop an image. Use optional ARG as the pixel width, otherwise
use `jmm/pdf-image-preferred-width'.

This function uses `pdf-view-extract-region-image'
but more easily allows you to scale up images."
  (interactive "P")
  (-let* (((left top right bottom) (car (pdf-view-active-region)))
	  (percentwidth (- right left))
	  (desiredwidth (if (numberp arg) arg jmm/pdf-image-preferred-width))
	  (fakesize (round (/ desiredwidth percentwidth))))
    (pdf-view-extract-region-image (pdf-view-active-region) nil (cons fakesize nil))))
#+END_SRC
**** Make a clipped image easy to copy to a specific directory

     After using ~jmm/pdf-crop-image-width~, you'll get a buffer named
     ~\*PDF Image\*~. Saving this file to the directory you want can
     be cumbersome. Usually I want to save the image to a directory
     different from the one the PDF lives in.

     This function writes the image to a temporary file (with private
     mode settings) and copies it to the
     ~dired-ranger-copy-ring~. This makes it really easy to paste into
     an open ~dired~ buffer, exactly where you want it.

#+BEGIN_SRC emacs-lisp
(defun jmm/image-copy-to-dired-ranger-ring ()
  "Save the image as a PNG, and push it to `dired-ranger-copy-ring'"
  (interactive)
  (let ((filename (make-temp-file "pdf-" nil ".png")))
    (with-file-modes #o600
      (write-region (point-min) (point-max) filename))
    (ring-insert
     dired-ranger-copy-ring
     (cons (list (current-buffer))
	   (list filename)))
    (message (format "Copied %s into copy ring." filename))))


(with-eval-after-load 'image-mode
  (require 'dired-ranger)
  (bind-key "[" #'jmm/image-copy-to-dired-ranger-ring image-mode-map))
#+END_SRC

*** Copy string to other window

    This function makes it easy to copy quotes into my notes files.

#+BEGIN_SRC emacs-lisp
(defun jmm/pdf-view-copy-text-other-window (&optional arg)
  "Copy the text in PDF view to the other window.
This function automatically unfills and re-fills text, eliminating word-wrapping hyphens.
With optional ARG, quote the string."
  (interactive "P")
  (let* ((fixed-pdf-text (jmm/pdf-view-unfill-text t (car kill-ring))))
    ;; (save-selected-window
    (other-window 1)
    (when arg (insert "\""))
    (insert fixed-pdf-text)
    (when arg (insert "\""))
    (fill-paragraph)))
#+END_SRC
*** Don't prompt if a PDF file is too large

    Normally Emacs tries out ~abort-if-file-too-large~ to ask whether
    you really want to open a large file. This is good normally,
    because you don't want to open huge buffers that might contain
    long lines and slow things down. We don't need this for PDF Tools
    though because it's kind of opened/processed externally.

#+begin_src emacs-lisp
(defun jmm/dont-prompt-about-large-pdf-files (orig-fun &rest args)
   "Advice for `abort-if-file-too-large' so
`files--ask-user-about-large-file' doesn't prompt about PDFs."
   (-let [(_size _op-type filename . rest) args]
     ;; TODO: I probably need to strip out TRAMP stuff and backup extensions.
     (unless (eq (assoc-default filename auto-mode-alist 'string-match)
		 'pdf-view-mode)
       (apply orig-fun args))))
#+end_src

** Ace-window
[[https://github.com/abo-abo/ace-window][ace-window]] seems to provide a good way to switch between different windows.
It also provides functions for swapping and moving windows, which is super helpful.
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :bind (("C-9" . ace-window)
	 ("C-(" . ace-swap-window))
  :init
  (setq aw-scope 'visible))
#+END_SRC

** Web-mode
   Web-mode is a pretty good mode for editing HTML and JSX files.
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode ("\\.html?\\'" . web-mode))
#+END_SRC

** Emojify
   Emoji are very important.
#+BEGIN_SRC emacs-lisp
(use-package emojify
  :ensure t
  :defer t
  :init
  (setq emojify-emoji-styles '(unicode))
  (bind-key "<f9> e" 'emojify-insert-emoji)
  :config
  (global-emojify-mode 1))
#+END_SRC
** Maxima

   I don't really use Maxima right now, but at one point I was trying to learn it

   Here's a setup for Maxima, from EmacsWiki.
 #+BEGIN_SRC emacs-lisp
   (add-to-list 'load-path "/usr/share/emacs/site-lisp/maxima/")
   (autoload 'maxima-mode "maxima" "Maxima mode" t)
   (autoload 'imaxima "imaxima" "Frontend for maxima with Image support" t)
   (autoload 'maxima "maxima" "Maxima interaction" t)
   (autoload 'imath-mode "imath" "Imath mode for math formula input" t)
   (setq imaxima-use-maxima-mode-flag t)
   (add-to-list 'auto-mode-alist '("\\.ma[cx]" . maxima-mode))
 #+END_SRC
** Processing
   Define the location of processing.
   Will be different for you.
 #+begin_src emacs-lisp
   (setq processing-location "~/Downloads/processing-2.1.2/processing-java")
 #+end_src
** Dumb jump

   I tried using [[https://github.com/jacktasia/dumb-jump][dumb-jump]] a bit, but didn't like its default keybindings.

   [[https://cestlaz.github.io/posts/using-emacs-33-projectile-jump/][Mike Zamansky]] has a post with some good bindings for it.

#+BEGIN_SRC emacs-lisp
(use-package dumb-jump
  :ensure
  :bind (("M-g o" . dumb-jump-go-other-window)
	 ("M-g j" . dumb-jump-go)
	 ("M-'" . dumb-jump-quick-look)
	 ("M-g a" . dumb-jump-back)
	 ("M-g x" . dumb-jump-go-prefer-external)
	 ("M-g z" . dumb-jump-go-prefer-external-other-window))
  :config
  (setq dumb-jump-selector 'helm))
#+END_SRC
** goto-last-change

   ~goto-last-change~ is a simple, but pretty handy, function. I find
   myself occasionally scrolling off screen, and forgetting where I
   last was. ~goto-last-change~ helps me go back to where I was last editing.

#+BEGIN_SRC emacs-lisp
(use-package goto-last-change
  :ensure
  :bind (("C-x C-'" . goto-last-change)))
#+END_SRC
** which-key

   ~[[https://github.com/justbur/emacs-which-key][which-key]]~ displays keybindings for prefixes. Handy if you forget which key maps to what.

   This does seem to cause some significant performance issues with something in my org-mode config.
   Like, I think it's somehow calling ~require~ and ~apply~ a lot. Maybe to look at what different keys do.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure
  :defer 5
  :disabled t
  :diminish which-key-mode
  :init
  (setq which-key-use-C-h-commands nil)
  :config (which-key-mode))
#+END_SRC
** SQL

   In ~sql-interactive-mode~, don't wrap lines.
#+BEGIN_SRC emacs-lisp
(add-hook 'sql-interactive-mode-hook
	  (lambda ()
	    (toggle-truncate-lines 1)))
#+END_SRC
** buffer-move

   [[https://www.emacswiki.org/emacs/buffer-move.el][Buffer-move]] makes it easy to swap windows.

#+BEGIN_SRC emacs-lisp
(use-package buffer-move
  :bind (("<C-S-up>" . buf-move-up)
	 ("<C-S-down>" . buf-move-down)
	 ("<C-S-left>" . buf-move-left)
	 ("<C-S-right>" . buf-move-right)))
#+END_SRC
** Company

   Company provides pretty decent completion.
#+BEGIN_SRC emacs-lisp
(use-package company
  :if (not noninteractive)
  :diminish company-mode
  :ensure t
  :defer 3
  :init (global-company-mode 1)

  :bind (:map company-active-map
	 ("TAB" . nil)
	 ("C-n" . company-select-next)
	 ("C-p" . company-select-previous)))
#+END_SRC
** Docker

#+BEGIN_SRC emacs-lisp
(use-package dockerfile-mode
  :ensure t
  :mode ("Dockerfile\\'" . dockerfile-mode))
#+END_SRC

** YAML
#+BEGIN_SRC emacs-lisp
(use-package yaml-mode
  :ensure t
  :mode ("\\.\\(e?ya?\\|ra\\)ml\\'" . yaml-mode))
#+END_SRC

** Eyebrowse

   [[https://github.com/wasamasa/eyebrowse][Eyebrowse]] seems like a decent way to manage window configurations.

#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :if (not noninteractive)
  :ensure t
  :bind-keymap ("C-c w" . eyebrowse-mode-map)
  :init
  ;; So we don't override "refile" for org-mode
  (setq eyebrowse-keymap-prefix (kbd "C-c w"))
  ;; Switch to scratch buffer for a new workspace
  (setq eyebrowse-new-workspace t)
  :config
  (eyebrowse-mode t)
  ;; Make it easier to clone slots
  (advice-add 'eyebrowse-switch-to-window-config :around #'jmm/eyebrowse-temporarily-clone-slot)
  ;; Since we defer loading, we'll need to initialize all frames when we first call it.
  (--each (frame-list) (with-selected-frame it (eyebrowse-init))))
#+END_SRC

*** Cloning slots

    I usually just prefer to switch to the "scratch" buffer for new
    slots, but occasionally I'll want to clone the old one. For
    example, I often like cloning window configurations if I'm working
    in a projectile project. This allows me to use keys like ~C-c w 2~
    and ~C-c w c~ like normal, but when I provide a prefix like ~C-u
    C-c w c~ it'll clone the last window configuration instead of
    switching to "scratch".

#+BEGIN_SRC emacs-lisp
(defun jmm/eyebrowse-temporarily-clone-slot (orig-fun &rest args)
  "With a prefix arg, set `eyebrowse-new-workspace' to nil in order to \"clone\" windows."
   (if current-prefix-arg
       (let* ((eyebrowse-new-workspace nil)) ;Nil means clone
	 (apply orig-fun args))
     (apply orig-fun args)))
#+END_SRC

** Markdown mode
   I'm using markdown mode to edit markdown and Rmarkdown files.

#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :ensure t
  :mode (("\\.Rmd" . markdown-mode)
	 ("\\.markdown\\'" . markdown-mode)
	 ("\\.md\\'" . markdown-mode)))
#+END_SRC

When editing code indirectly (with ~edit-indirect-region~, which
~markdown-mode~ calls), display it in the same window. I don't want it
obscuring other windows.

#+BEGIN_SRC emacs-lisp
(use-package edit-indirect
  :after markdown-mode
  :init
  (add-to-list 'display-buffer-alist
	       `("^\\*edit-indirect" . (,#'display-buffer-same-window)))
  :config
  ;; Conflicts with ESS
  (unbind-key "C-c C-c" edit-indirect-mode-map))
#+END_SRC
** Resize-window

   Trying out ~[[https://github.com/dpsutton/resize-window][resize-window]]~ for resizing.
#+BEGIN_SRC emacs-lisp
(use-package resize-window
  :ensure t
  :bind (("C-c ;" . resize-window)))
#+END_SRC
** org-bookmark-heading

   Great way to add headings to bookmarks.  I'm putting this here
   instead of my org-config for now since I might try to use
   ~org-bookmark-jump~ before it's loaded.
#+BEGIN_SRC emacs-lisp
(use-package org-bookmark-heading
  :ensure t
  :init
  (autoload #'org-bookmark-jump "org-bookmark-heading" nil)
  :after (org))
#+END_SRC

** fasd
   Useful for navigating to frequently visited files and directories
#+BEGIN_SRC emacs-lisp
(use-package fasd
  :if (not noninteractive)
  :ensure t
  ;; ":after" doesn't force loading of required dependencies
  ;; :after (helm-mode)
  :init
  (require 'helm-mode)
  (setq fasd-enable-initial-prompt nil)
  (global-fasd-mode 1)
  :bind (("C-c f" . fasd-find-file)))
#+END_SRC
** symbol-overlay

   It's sometimes nice to have the symbol at point automatically
   highlighted, to see where it's used.

#+BEGIN_SRC emacs-lisp
(use-package symbol-overlay
  :if (not noninteractive)
  :diminish symbol-overlay-mode
  :disabled t
  :ensure t
  :hook (prog-mode . symbol-overlay-mode)
  :bind (:map prog-mode-map
	      ("M-r" . symbol-overlay-put)))
#+END_SRC


** savehist-mode

   Save ~M-x~ history. Makes it easier to see frequently used commands for Helm ~M-x~.
   Probably should clean up file history, though.
   
#+begin_src emacs-lisp
(use-package savehist
  :unless noninteractive
  :init
  (savehist-mode 1))
#+end_src
** plantuml-mode

   This might not work right with ~direnv~ since ~plantuml-mode~ calls
   some initialization stuff that might be shared.

#+begin_src emacs-lisp
(use-package plantuml-mode
  :unless noninteractive
  :init
  (setq plantuml-default-exec-mode 'executable))

#+end_src

