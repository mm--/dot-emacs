#+TITLE: Josh Moller-Mara's Emacs configuration
#+OPTIONS: toc:1 h:4

The whole org-babel setup is shamelessly stolen from Sacha Chua.
* Personal information
  Here I set up my name and email, which is used for things like Gnus.
#+begin_src emacs-lisp
  (setq user-full-name "Joshua Moller-Mara"
        user-mail-address "j.moller-mara@berkeley.edu")
#+end_src

* Emacs initialization and package management
  Here I set up where to find my Elisp files, and the repositories for
  packages.
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/elisp")
  (add-to-list 'load-path "~/.emacs.d/elisp")
  (require 'package)
  (package-initialize)
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)
  (add-to-list 'package-archives '("ELPA" . "http://tromey.com/elpa/") t)
  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/") t)
  (add-to-list 'package-archives '("melpa" . "http://melpa.milkbox.net/packages/") t)
#+end_src

  If I make any changes using Custom, I want them to be in a separate file.
#+begin_src emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file)
#+end_src

  Secret info. (Authentication info)
#+begin_src emacs-lisp
(load-file "~/.emacs.secrets")
#+end_src


** Byte compile stuff?

#+begin_src emacs-lisp
(defun emacs/byte-recompile ()
  (interactive)
  (byte-recompile-directory "~/.emacs.d" 0)
  (byte-recompile-directory "~/elisp" 0))
#+end_src

* Basic configuration

Enable all the disabled commands
#+begin_src emacs-lisp
  (setq disabled-command-function nil)
#+end_src

#+begin_src emacs-lisp
  ;; I don't like having to type "yes"
  (fset 'yes-or-no-p 'y-or-n-p)

  (transient-mark-mode 1)
  (column-number-mode 1)
  (show-paren-mode 1)
  (menu-bar-mode -1)
  (tool-bar-mode 0)
  (blink-cursor-mode 0)

  (set-register ?e '(file . "~/.emacs.d/jmm-emacs.org"))
  (set-register ?l '(file . "~/org/josh-ledger.dat"))
  (set-register ?n '(file . "~/org/neuroecon.org"))
  (set-register ?o '(file . "~/org/gtd-test.org"))

  (server-start)

  (setq visible-bell 0)                   ;Set visible bell on.
  (setq ring-bell-function 'ignore)       ;Visible bell.

  (setq frame-title-format "Emacs - %b")
  (setq set-mark-command-repeat-pop t)
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
  (winner-mode 1)
  (setq inhibit-splash-screen t)
  (setq Man-notify-method 'pushy)
  (set-default-font "-misc-fixed-medium-r-normal-*-13-*-*-*-*-*-*-*")
  (setq visual-line-fringe-indicators '(nil right-curly-arrow))

  (setq browse-url-browser-function 'browse-url-generic
        browse-url-generic-program "chromium")
  (setq shr-external-browser 'browse-url-generic) ;For eww
#+end_src

Make scripts executable
#+begin_src emacs-lisp
(add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+end_src

** Prompt before exiting Emacs

#+begin_src emacs-lisp
(setq kill-emacs-query-functions
      (cons (lambda () (yes-or-no-p "Really kill Emacs?"))
     kill-emacs-query-functions))
#+end_src

** Dealing with the clipboard
#+begin_src emacs-lisp
(setq x-select-enable-clipboard t) ; as above
(setq interprogram-paste-function 'x-cut-buffer-or-selection-value)
;; I think I need this now for my clipboard
(setq x-select-enable-primary t)
#+end_src
** Windmove
#+begin_src emacs-lisp
(windmove-default-keybindings 'control)
#+end_src

* Theme
#+begin_src emacs-lisp
(add-to-list 'custom-theme-load-path "~/elisp/zenburn-emacs/")
(load-theme 'zenburn)
#+end_src
* Keybindings

#+begin_src emacs-lisp
  (global-set-key (kbd "C-x g") 'gnus)
  (global-set-key (kbd "C-x C-a") 'artist-mode)
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (global-set-key (kbd "<f9> m") 'magit-status)
  (define-key (current-global-map) [remap imenu] 'helm-imenu)
  ;; Replaced with helm
#+end_src

* Autosaves and backups

Autosaves
#+begin_src emacs-lisp
;; Put autosave files (ie #foo#) in one place, *not*
;; scattered all over the file system!
(defvar autosave-dir
 "~/emacs_autosaves/")

(make-directory autosave-dir t)

(defun auto-save-file-name-p (filename)
  (string-match "^#.*#$" (file-name-nondirectory filename)))

(defun make-auto-save-file-name ()
  (concat autosave-dir
   (if buffer-file-name
      (concat "#" (file-name-nondirectory buffer-file-name) "#")
    (expand-file-name
     (concat "#%" (buffer-name) "#")))))
#+end_src

Backups
Put backup files (ie foo~) in one place too. (The backup-directory-alist
list contains regexp=>directory mappings; filenames matching a regexp are
backed up in the corresponding directory. Emacs will mkdir it if necessary.)
#+begin_src emacs-lisp
  (defvar backup-dir "~/emacs_backups/")
  (make-directory backup-dir t)
  (setq backup-directory-alist (list (cons ".dreams." ".") (cons "." backup-dir)))
#+end_src

* Autocompletion, Hippie expand

#+begin_src emacs-lisp
(global-set-key (kbd "M-<return>") 'complete-tag) ;;bind complete-tag.
(global-set-key (kbd "M-?") 'hippie-expand)
#+end_src

** Hippie Expand stuff:

#+begin_src emacs-lisp
(setq hippie-expand-try-functions-list (quote (try-complete-file-name-partially try-complete-file-name try-expand-all-abbrevs try-expand-list try-expand-line try-expand-dabbrev try-expand-dabbrev-all-buffers try-expand-dabbrev-from-kill try-complete-lisp-symbol-partially try-complete-lisp-symbol try-expand-dict-command)))
#+end_src

#+begin_src emacs-lisp
(defun he-dict-command-beg ()
  (let ((p))
    (save-excursion
      (backward-word 1)
      (setq p (point)))
    p))

(defun try-expand-dict-command (old)
  (unless old
    (he-init-string (he-dict-command-beg) (point))
    (setq he-expand-list (sort
			  (all-completions he-search-string (mapcar 'list (lookup-words (concat old "*") ispell-complete-word-dict)))
			  'string-lessp)))
  (while (and he-expand-list
              (he-string-member (car he-expand-list) he-tried-table))
    (setq he-expand-list (cdr he-expand-list)))
  (if (null he-expand-list)
      (progn
	(when old (he-reset-string))
	())
    (he-substitute-string (car he-expand-list))
    (setq he-tried-table (cons (car he-expand-list) (cdr he-tried-table)))
    (setq he-expand-list (cdr he-expand-list))
    t))
#+end_src

* Compiling conveniences

#+begin_src emacs-lisp
(require 'compile)
(add-hook 'c++-mode-hook
	  (lambda ()
	    (unless (file-exists-p "Makefile")
	      (set (make-local-variable 'compile-command)
		   ;; emulate make's .c.o implicit pattern rule, but with
		   ;; different defaults for the CC, CPPFLAGS, and CFLAGS
		   ;; variables:
		   ;; $(CC) -c -o $@ $(CPPFLAGS) $(CFLAGS) $<
		   (let ((file (file-name-nondirectory buffer-file-name)))
		     (format "%s %s %s -o %s"
			     (or (getenv "CPP") "g++")
			     (or (getenv "CFLAGS") "-g -Os")
			     file
			     (file-name-sans-extension file)
			     ))))))
#+end_src

#+begin_src emacs-lisp
(global-set-key (kbd "<f9> <f9>") 'recompile)
#+end_src

#+begin_src emacs-lisp
(setq compilation-scroll-output 1)
#+end_src

* Spelling

#+begin_src emacs-lisp
(setq-default ispell-program-name "aspell")
(setq-default ispell-grep-command "grep")
(setq-default ispell-grep-options "-iE")
(setq-default ispell-complete-word-dict "/usr/share/dict/american-english")
#+end_src

#+begin_src emacs-lisp
(add-hook `text-mode-hook `flyspell-mode)
(add-hook `latex-mode-hook `flyspell-mode)
(add-hook `tex-mode-hook `flyspell-mode)
(add-hook `bibtex-mode-hook `flyspell-mode)
#+end_src

** Accepting previous misspelled words

#+begin_src emacs-lisp
(defun flyspell-accept-prev (position &optional savetype)
  "Accept the previously mispelled word onscreen. Defaults saving to session, but optional savetype can save to personal dict"
  (interactive "d")
  (or savetype (setq savetype 'session))
  (let ((top (window-start))
	(bot (window-end))
	correctpos)
    (save-excursion
      (save-restriction
	(narrow-to-region top bot)
	(overlay-recenter (point))

	  (let ((overlay-list (overlays-in (point-min) position))
		(new-overlay 'dummy-value))

	    ;; search for previous (new) flyspell overlay
	    (while (and new-overlay
			(or (not (flyspell-overlay-p new-overlay))
			    ;; check if its face has changed
			    (not (eq (get-char-property
				      (overlay-start new-overlay) 'face)
				     'flyspell-incorrect))))
	      (setq new-overlay (car-safe overlay-list))
	      (setq overlay-list (cdr-safe overlay-list)))

	    ;; if nothing new exits new-overlay should be nil
	    (if new-overlay ;; the length of the word may change so go to the start
		(setq correctpos
		      (overlay-start new-overlay))))

	(when correctpos
	  (save-excursion
	    (goto-char correctpos)
	    (let ((cursor-location (point))
		  (opoint (point))
		  (word (flyspell-get-word)))
	      (if (consp word)
		  (let ((start (car (cdr word)))
			(end (car (cdr (cdr word))))
			(word (car word))
			poss ispell-filter)
		    (flyspell-do-correct savetype poss word cursor-location start end opoint)
		    (ispell-pdict-save t))))))))))

(defun flyspell-accept-prev-save (position)
  "Save the previously mispelled word. See flyspell-accept-prev"
  (interactive "d")
  (flyspell-accept-prev position 'save))

(add-hook 'flyspell-mode-hook
 (lambda ()
   (define-key flyspell-mode-map (kbd "C-M-;") 'flyspell-accept-prev)
   (define-key flyspell-mode-map (kbd "C-:") 'flyspell-accept-prev-save)
   ))
#+end_src

* LaTeX

#+begin_src emacs-lisp
(setq latex-run-command "pdflatex")
(setq tex-output-extension ".pdf")
#+end_src

#+begin_src emacs-lisp
(add-hook `latex-mode-hook (lambda () (defun tex-view ()
  (interactive)
  (tex-send-command "evince" (tex-append tex-print-file ".pdf") t))))
#+end_src

Make it easier to insert Greek symbols
#+begin_src emacs-lisp
  (add-hook 'LaTeX-mode-hook 'LaTeX-math-mode)
#+end_src

** Bibtex stuff (no longer needed?)
#+begin_src emacs-lisp
(add-hook 'latex-mode-hook
	  (lambda ()
	    (defun tex-bibtex-file ()
	      "Run BibTeX on the current buffer's file."
	      (interactive)
	      (if (tex-shell-running)
		  (tex-kill-job)
		(tex-start-shell))
	      (let* (shell-dirtrack-verbose
		     (source-file (tex-main-file))
		     (tex-out-file
		      (tex-append (file-name-nondirectory source-file) ""))
		     (file-dir (file-name-directory (expand-file-name source-file))))
		(tex-send-command tex-shell-cd-command file-dir)
		(tex-send-command tex-bibtex-command tex-out-file))
	      (tex-display-shell))))
#+end_src

** AUCTeX and skeletons
#+begin_src emacs-lisp
  ;; AUCTeX
  ;; (setq load-path (append load-path "~/.emacs.d/elpa/auctex-11.87.2/"))
  ;; (load "auctex.el" nil t t)
  ;; (load "preview-latex.el" nil t t)
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq-default TeX-master nil)
  (add-hook 'LaTeX-mode-hook 'TeX-PDF-mode) ;use pdflatex by default

  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)
  (setq reftex-plug-into-AUCTeX t)

  (setq skeleton-end-newline nil)
  (add-hook 'LaTeX-mode-hook
   (lambda ()
     (define-key LaTeX-mode-map (kbd "` v (") 'latex-skeleton-left-paren)
     (define-key LaTeX-mode-map (kbd "` v [") 'latex-skeleton-left-bracket)
     (define-key LaTeX-mode-map (kbd "` v {") 'latex-skeleton-left-brace)
     (define-key LaTeX-mode-map (kbd "` v t") 'latex-math-text)
     (define-key LaTeX-mode-map (kbd "` v $") 'quoted-parens)
     (define-key LaTeX-mode-map (kbd "` v %") 'quoted-brackets)
     ))

  (define-skeleton latex-skeleton-left-paren
    "Insert \\left( ... \\right)."
    nil "\\left(" _ "\\right)")

  (define-skeleton latex-skeleton-left-bracket
    "Insert \\left[ ... \\right]."
    nil "\\left[" _ "\\right]")

  (define-skeleton latex-skeleton-left-brace
    "Insert \\left\\{ ... \\right\\}."
    nil "\\left\\{" _ "\\right\\}")

  (define-skeleton latex-math-text
    "Insert \\text{ ... }."
    nil "\\text{" _ "}")

  (define-skeleton quoted-parens
    "Insert \\( ... \\)."
    nil "\\(" _ "\\)")

  (define-skeleton quoted-brackets
    "Insert \\[ ... \\]."
    nil "\\[" _ "\\]")
#+end_src
** AUCTeX handling errors
Sometimes AUCTex can't parse errors correctly, prompting you to create a directory
#+begin_src emacs-lisp
(setq LaTeX-command-style '(("" "%(PDF)%(latex) -file-line-error %S%(PDFout)")))
#+end_src
* R/ESS
  This seems to be necessary when installing ESS from MELPA.
#+begin_src emacs-lisp
  (require 'ess-site)
#+end_src

#+begin_src emacs-lisp
  (setq comint-scroll-to-bottom-on-input t)
  (setq comint-scroll-to-bottom-on-output t)
  (setq comint-move-point-for-output t)

  (add-hook 'ess-mode-hook
            (lambda ()
              (flyspell-prog-mode)
              (auto-complete-mode 1)
              (ac-flyspell-workaround)))

  (add-hook 'inferior-ess-mode-hook
            (lambda ()
              (auto-complete-mode 1)))

  (autoload 'ess-rdired "ess-rdired"
    "View *R* objects in a dired-like buffer." t)
#+end_src
** JAGS
#+begin_src emacs-lisp
(require 'ess-jags-d)
#+end_src

** View an object
#+begin_src emacs-lisp
  (defun ess-dump-object-into-view-buffer (object)
    "Edit an ESS object in its view buffer."
    (interactive
     (progn
       (ess-force-buffer-current "Process to dump from: ")
       (if (ess-ddeclient-p)
           (list (read-string "Object to edit: "))
         (ess-read-object-name "Object to edit"))))
    (ess-execute (ess-rdired-get object)
               nil "R view" ))

  (eval-after-load "ess-mode"
    '(define-key ess-mode-map (kbd "C-c v") 'ess-dump-object-into-view-buffer))
#+end_src

** Clear the shell
#+begin_src emacs-lisp
(defun clear-shell ()
   (interactive)
   (let ((old-max comint-buffer-maximum-size))
     (setq comint-buffer-maximum-size 0)
     (comint-truncate-buffer)
     (setq comint-buffer-maximum-size old-max)))
#+end_src

** Truncate automatically
#+begin_src emacs-lisp
  (setq comint-buffer-maximum-size 2000)
  (add-hook 'comint-output-filter-functions
            'comint-truncate-buffer)
#+end_src
* ERC
#+begin_src emacs-lisp
  (require 'erc-services)
  (erc-services-mode 1)
  (setq erc-nick "emdash"
        erc-server "localhost"
        erc-port "1799")
  (setq erc-auto-query 'bury)
#+end_src
** Notify
#+begin_src emacs-lisp
;;list of regexpes ignored by tray icon
(defun erc-tray-change-state (arg)
  "Enables or disable blinking, depending on arg"
  (if arg
      (shell-command-to-string
       "echo B > /tmp/tray_daemon_control")
    (shell-command-to-string
     "echo b > /tmp/tray_daemon_control")))
(defun erc-tray-update-state ()
  "Updates the state of the tray icon according to the contents
of erc-modified-channels-alist"
  (interactive)
  (let ((blinkify nil))
    (mapcar (lambda (el)
	      (when (string-match "erc-current-nick-face" (face-name (nthcdr 2 el)))
		(setq blinkify t)))
	    erc-modified-channels-alist)
    (erc-tray-change-state blinkify)))
(when window-system
  (add-hook 'erc-track-list-changed-hook 'erc-tray-update-state))
(setq erc-track-exclude-types '("JOIN" "NICK" "PART" "QUIT"))
#+end_src

** More notify stuff
#+begin_src emacs-lisp
  ;; Notify my when someone mentions my nick.
  (defun erc-global-notify (matched-type nick msg)
    (interactive)
    (when (eq matched-type 'current-nick)
      (shell-command
       (concat "notify-send -t 4000 -c \"im.received\" \""
               (car (split-string nick "!"))
               " mentioned your nick\" \""
               msg
               "\""))))
  (add-hook 'erc-text-matched-hook 'erc-global-notify)
#+end_src
** Timestamp
#+begin_src emacs-lisp
(make-variable-buffer-local
 (defvar erc-last-datestamp nil))

(defun ks-timestamp (string)
  (erc-insert-timestamp-left string)
  (let ((datestamp (erc-format-timestamp (current-time) erc-datestamp-format)))
    (unless (string= datestamp erc-last-datestamp)
      (erc-insert-timestamp-left datestamp)
      (setq erc-last-datestamp datestamp))))


(setq erc-timestamp-only-if-changed-flag t
      erc-timestamp-format "%H:%M "
      erc-datestamp-format " === [%Y-%m-%d %a] ===\n" ; mandatory ascii art
      erc-fill-prefix "      "
      erc-insert-timestamp-function 'ks-timestamp)
#+end_src

* rcirc
#+begin_src emacs-lisp
(require 'rcirc)
#+end_src
** Spelling
#+begin_src emacs-lisp
(add-hook 'rcirc-mode-hook (lambda ()
			     (flyspell-mode 1)))
#+end_src
** Other
#+begin_src emacs-lisp
  (setq rcirc-debug-flag t)

  ;; Adjust the colours of one of the faces.
  (set-face-foreground 'rcirc-my-nick "red" nil)

  (setq rcirc-default-nick "emdash")
  (setq rcirc-default-user-name "joshm")
  (setq rcirc-default-full-name "Josh Moller-Mara")

  (setq rcirc-buffer-maximum-lines 2000)
  ;; rcirc-server-alist moved to secrets file, as it contains passwords.

  (add-hook 'rcirc-mode-hook
            (lambda ()
              (rcirc-track-minor-mode 1)))

  (add-hook 'rcirc-mode-hook (lambda ()
                               (flyspell-mode 1)))

#+end_src

** Reconnect after disconnect

#+begin_src emacs-lisp
  (eval-after-load 'rcirc
    '(defun-rcirc-command reconnect (arg)
       "Reconnect the server process."
       (interactive "i")
       (unless process
         (error "There's no process for this target"))
       (let* ((server (car (process-contact process)))
              (port (process-contact process :service))
              (nick (rcirc-nick process))
              channels query-buffers)
         (dolist (buf (buffer-list))
           (with-current-buffer buf
             (when (eq process (rcirc-buffer-process))
               (remove-hook 'change-major-mode-hook
                            'rcirc-change-major-mode-hook)
               (if (rcirc-channel-p rcirc-target)
                   (setq channels (cons rcirc-target channels))
                 (setq query-buffers (cons buf query-buffers))))))
         (delete-process process)
         (rcirc-connect server port nick
                        rcirc-default-user-name
                        rcirc-default-full-name
                        channels))))
#+end_src

** Load rcirc-notify
#+begin_src emacs-lisp
  (eval-after-load 'rcirc '(require 'rcirc-notify))
#+end_src

** Load rcirc color
#+begin_src emacs-lisp
  (eval-after-load 'rcirc '(require 'rcirc-color))
#+end_src
* Scheme
#+begin_src emacs-lisp
(setq scheme-program-name "csi")

(defun run-half-scheme () "
   Run Scheme in half a window."
   (interactive)
   (split-window-vertically nil)
   (other-window 1)
   (call-interactively 'run-scheme))

(add-hook 'scheme-mode-hook
 (lambda ()
   (define-key scheme-mode-map (kbd "C-c C-s") 'run-half-scheme)
   ))
#+end_src
* C
#+begin_src emacs-lisp
(setq-default c-basic-offset 8)
(setq c-default-style "gnu")
#+end_src
* Shells
#+begin_src emacs-lisp
(defun run-half-shell ()
   "Run a shell in half a window."
   (interactive)
   (split-window-vertically nil)
   ;; (other-window 1)
   (shell (concat (buffer-name) " shell")))

(global-set-key (kbd "C-x 4 s") 'run-half-shell)
#+end_src
* Encryption
#+begin_src emacs-lisp
(require 'epa-file)			;So we can encrypt authinfo
(setq epa-file-cache-passphrase-for-symmetric-encryption t) ;So it doesn't ask for password multiple times
#+end_src
  Put the following on the top of files to encrypt them to myself.
  May need to run "normal-mode" to set the file local variables.
  Also, remember that just because files are encrypted to you does not
  mean they're signed by you. So when encrypting stuff for yourself,
  you may want to sign it.
#+begin_src emacs-lisp
  (set-register ?G "-*- epa-file-encrypt-to: (\"j.moller-mara@berkeley.edu\") -*-\n")
#+end_src
* BBDB
#+begin_src emacs-lisp
(require 'bbdb)
(bbdb-initialize 'gnus 'message)
(setq bbdb-use-pop-up nil)		;Don't pop up
(setq bbdb-quiet-about-name-mismatches nil)
#+end_src
* GNUS/Email
#+begin_src emacs-lisp
(setq mail-user-agent 'gnus-user-agent)	;Uses Message mode instead of mail mode
#+end_src
** Spoofing dates
#+begin_src emacs-lisp
(defun gnus-date-spoof ()
  (interactive)
  (message-generate-headers '(Date))
  (setq message-deletable-headers (delq 'Date message-deletable-headers))
  (message "Deletable headers are %s %s" message-deletable-headers "(DONT FORGET SMTPMAIL-FQDN)"))

(defun gnus-date-unspoof ()
  (interactive)
  (add-to-list 'message-deletable-headers 'Date)
  (message "Deletable headers are %s" message-deletable-headers))
#+end_src

** Kill IMAP
Sometimes IMAP freezes, so I like to be able to kill it.
#+begin_src emacs-lisp
(defun kill-imap ()
  "Kill openssl imap"
  (interactive)
  ;; (delete-process "imap")
  (mapc (lambda (x) (if (string-match "imap" (process-name x)) (delete-process x))) (process-list)))
#+end_src

** Espeak article
   Read an article out loud
#+begin_src emacs-lisp
  (defun josh/espeak-article (&optional arg)
    "Select the gnus article and read it"
    (interactive "P")
    (with-current-buffer gnus-article-buffer
      (save-excursion
        (save-restriction
          (widen)
          (when (article-goto-body)
            (let* ((wpm (number-to-string (* (if arg arg 5) 100)))
                   (process (start-process "espeak-process" " *espeak-gnus*" "espeak" "-a" "200" "-v" "english-us" "-s" wpm)))
              (process-send-region process (point) (point-max))
              (process-send-string process "\n")
              (process-send-eof process)))))))

  (global-set-key (kbd "<f9> e") 'josh/espeak-article)
#+end_src

* Dired
** Listing switches
#+begin_src emacs-lisp
(setq dired-listing-switches "-alh")
#+end_src

** Dired-X
Because dired-jump is pretty useful
#+begin_src emacs-lisp
(add-hook 'dired-load-hook
	  (function (lambda () (load "dired-x"))))
#+end_src
* Tramp
#+begin_src emacs-lisp
(require 'tramp)
#+end_src
** Proxies. Allow sudo
#+begin_src emacs-lisp
(set-default 'tramp-default-proxies-alist nil)
(add-to-list 'tramp-default-proxies-alist '((and (string-match system-name (tramp-file-name-host (car target-alist))) "FUCKNO") "\\`root\\'" "/ssh:%h:"))
#+end_src

** Prompt for Yubikeys
#+begin_src emacs-lisp
  (setq tramp-password-prompt-regexp "^.*\\(Yubikey\\|[pP]assword\\|[pP]assphrase\\).*: ? *")
#+end_src
* Org Mode
** Setup my agenda file
   Read from "org-agendas" where the agenda files are.
   Set the default span to a day view.
#+begin_src emacs-lisp
  (setq org-agenda-files (concat (file-name-as-directory org-directory) "org-agendas.txt"))
  (setq org-agenda-span 'day)
#+end_src
** Default notes file?
   Note to self, figure out what the difference between this and agenda is.

#+begin_src emacs-lisp
  (setq org-default-notes-file (concat (file-name-as-directory org-directory) "gtd-test.org"))
#+end_src
** Capturing and agenda keybindings
#+begin_src emacs-lisp
  (define-key global-map (kbd "C-c c") 'org-capture)
  (global-set-key (kbd "C-c a") 'org-agenda)
#+end_src
** Capture templates
   Need to make this more portable across different systems. I think it defaults to org-directory.
#+begin_src emacs-lisp
  (setq org-capture-templates
        '(("t" "Todo" entry (file+headline "gtd-test.org" "Tasks")
           "* TODO %i %?\n\tAdded: %U")
          ("a" "Today" entry (file+headline "gtd-test.org" "Tasks")
           "* TODO %i %?\n\tSCHEDULED: <%<%Y-%m-%d %a>>\n\tAdded: %U")
          ("l" "Lookup" entry (file+headline "gtd-test.org" "Lookup")
           "* %?\n\tAdded: %U")
          ("c" "Calendar" entry (file+headline "gtd-test.org" "Calendar")
           "* %i %?\n\tAdded: %U")
          ("s" "Shopping" entry (file+headline "gtd-test.org" "Shopping")
           "* %i %?\n\tAdded: %U")
          ("n" "Neuroecon" entry (file+headline "neuroecon.org" "Neuroecon")
           "* %?\n%i\n\tAdded: %U")
          ("m" "Someday/Maybe" entry (file+headline "gtd-test.org" "Someday/Maybe")
           "* %?\n\tAdded: %U")
          ("o" "thoughts" plain (file "thoughts-misc.txt")
           "\n\n%U -\n\n %?\n" :empty-lines 1)
          ("j" "Jokes" plain (file "jokes.txt")
           "\n\n%U -\n\n %?\n" :empty-lines 1)
          ("v" "Vocabulary" entry
           (file+headline "~/reading/words-i-learned.org" "Vocabulary")
           "* %^{The word} :drill:\n Added: %U\n %^{Extended word (may be empty)|%\\1}\n** Answer \n%^{The definition}")))
#+end_src
   Fix a bug causing org-capture to mess up line numbers
#+begin_src emacs-lisp
  (setq-default cache-long-scans nil)
#+end_src
** Org agenda listings
#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        (quote
         (("w" todo "WAITING")
          ("W" todo-tree "WAITING")
          ("H" "Office and Home Lists"
           ((agenda)
            (tags-todo "OFFICE")
            (tags-todo "HOME")
            (tags-todo "COMPUTER")
            (tags-todo "DVD")
            (tags-todo "READING")))
          ("b" "Things to do if bored"
           tags "IFBORED"
           ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done)))
           ("~/org/blockreddit/ifbored.html"))
          ("D" "Daily Action List"
           ((agenda "" ((org-agenda-ndays 1)
                        (org-agenda-sorting-strategy
                         (quote ((agenda time-up priority-down tag-up) )))
                        (org-deadline-warning-days 0)))))
          ("U" "Unscheduled NoDeadline" alltodo ""
           ((org-agenda-skip-function
             '(org-agenda-skip-entry-if 'scheduled 'deadline))))
          ("k" agenda "" ((org-agenda-span 7)) ("~/org/week-agenda.html"))
          ("X" agenda "" ((org-agenda-span 3)
                          ;; (org-agenda-start-with-log-mode t)
                          (org-agenda-start-with-clockreport-mode t)) ("~/org/newtab/agenda.html"))
          )))
#+end_src
** Define a stuck project
#+begin_src emacs-lisp
  (setq org-stuck-projects
             '("+PROJECT/-MAYBE-DONE" ("NEXT" "TODO") ("@SHOP")
                                      "\\<IGNORE\\>"))
#+end_src

** If I didn't want it to interfere with windmove
#+begin_src emacs-lisp
  ;; (setq org-replace-disputed-keys t)
#+end_src

** Writing my current task to a file
   I have a conky script that displays my current task. That way, even
   when I'm not in Emacs, I can see what task I'm supposed to be
   working on, and how long I've been clocked into it.
#+begin_src emacs-lisp
  (setq josh/clock-current-task-file "~/.currenttask")

  (defun josh/org-clock-in-conky ()
    (interactive)
    "Creates a file `josh/clock-current-task-file' with the current task and the time started.
  To be used with a script in conky to display what I'm working on."
    (if org-clock-current-task
        (with-temp-file josh/clock-current-task-file
            (progn
              (insert org-clock-current-task)
              (newline)
              (insert (format-time-string "%s" org-clock-start-time))
              (newline)))))

  (defun josh/org-clock-out-conky ()
    (interactive)
    "When I clock out, remove `josh/clock-current-task-file'"
    (if (file-exists-p josh/clock-current-task-file)
            (delete-file josh/clock-current-task-file)))

  ;; (add-hook 'org-clock-in-hook 'josh/org-clock-in-conky)
  ;; (add-hook 'org-clock-out-hook 'josh/org-clock-out-conky)
#+end_src

   Here's another hook that works with my "ceftoolbar" in sawfish.

   The ceftoolbar is a Chromium embedded framework toolbar that
   displays CPU usage, network usage, as well as my current task

#+begin_src emacs-lisp
  (defun josh/org-clock-2 ()
    (interactive)
    "When I clock in or out, call a script that updates the ceftoolbar"
    (start-process "LogTime"
                   (get-buffer-create " *josh-clock-buffer*")
                   "~/.sawfish/scripts/clock-in.sh"))

  (defun josh/org-clock-in-conky2 ()
    (josh/org-clock-in-conky)
    (josh/org-clock-2))

  (defun josh/org-clock-out-conky2 ()
    (josh/org-clock-out-conky)
    (josh/org-clock-2))

  (add-hook 'org-clock-in-hook 'josh/org-clock-in-conky2)
  (add-hook 'org-clock-out-hook 'josh/org-clock-out-conky2)

#+end_src

** Org-drill
Require org-drill.
Add random noise to the due dates of cards, so they're not always clumped together.
Also, change the default cloze delimiters, as the defaults weren't working well for me.
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/elisp/org-mode/contrib/lisp/")
  (add-to-list 'org-modules 'org-drill)
  (require 'org-drill)
  (setq org-drill-add-random-noise-to-intervals-p t)
  (setq org-drill-hint-separator "||")
  (setq org-drill-left-cloze-delimiter "<[")
  (setq org-drill-right-cloze-delimiter "]>")
  (setq org-drill-learn-fraction 0.3)
#+end_src
** Org-habit
#+begin_src emacs-lisp
  (add-to-list 'org-modules 'org-habit)
  (require 'org-habit)
#+end_src
** For exporting latex
http://blog.karssen.org/2013/08/22/using-bibtex-from-org-mode/
#+begin_src emacs-lisp
  (setq org-latex-pdf-process '("latexmk -pdf -bibtex %f"))
#+end_src
** Clocking
*** Easier method to clock into some frequent habits
Some habits occur quite frequently, and it's kind of a pain to have to
find them in my GTD org file before clocking in. This simplifies
clocking into frequent tasks. (Mostly helps me track bad habits.)
#+begin_src emacs-lisp
  (require 'helm-adaptative)
  (defun josh/org-helm-candidates ()
    (interactive)
    (org-map-entries
     (lambda () (let* ((title (nth 4 (org-heading-components))))
                  (cons title (cons title (current-buffer)))))
     nil
     'agenda))

  (setq josh/helm-source-org-clock
    '((name . "Clock in to what")
      (candidates . josh/org-helm-candidates)
      (filtered-candidate-transformer
       helm-adaptive-sort)
      (action . (("Clock in"
                  . josh/org-clock-in)))))

  (defun josh/org-clock-in (candidate)
    "Clock into taskname in gtd-test"
    (interactive)
    (save-excursion
      (let* ((taskname (car candidate))
             (taskbuffer (cdr candidate))
             (place (org-find-exact-headline-in-buffer taskname taskbuffer)))
        (with-current-buffer (marker-buffer place)
          (goto-char place)
          (org-clock-in)))))

  (defun josh/helm-org-clock-in ()
    "Use helm to clock into a task"
    (interactive)
    (helm-other-buffer 'josh/helm-source-org-clock
                       "*Helm Clock-in*"))

  (global-set-key (kbd "<f9> z") 'josh/helm-org-clock-in)

  (defun josh/helm-org-jump-candidate (candidate)
    "Jump to a candidate with org"
    (interactive)
    (let* ((taskname (car candidate))
           (taskbuffer (cdr candidate))
           (place (org-find-exact-headline-in-buffer taskname taskbuffer)))
      (switch-to-buffer (marker-buffer place))
      (goto-char place)
      (org-show-context)))

  (setq josh/helm-jump-org
    '((name . "Jump to org")
      (candidates . josh/org-helm-candidates)
      (filtered-candidate-transformer
       helm-adaptive-sort)
      (action . (("Jump to"
                  . josh/helm-org-jump-candidate)))))

  (defun josh/helm-org-jump ()
    "Use helm to clock into a task"
    (interactive)
    (helm-other-buffer 'josh/helm-jump-org
                       "*Org Jump*"))

  (global-set-key (kbd "<f9> j") 'josh/helm-org-jump)
#+end_src
*** Setting a timer on the current task
   I use =<f9> z= to set the current task. When I want to set a timer,
   for instance in a pomodoro-type fashion, I'll use this function
   which I have bound to =<f9> p=. It's the same thing as
   =org-timer-set-timer=, but I don't have to switch buffers to find
   the task I'm already clocked into.
#+begin_src emacs-lisp
  (defun josh/org-current-task-timer (&optional opt)
    "Find the current clocking task and set a timer on it."
    (interactive "P")
    (when (org-clocking-p)
      (save-excursion
        (org-no-warnings (set-buffer (org-clocking-buffer)))
        (save-restriction
          (widen)
          (goto-char org-clock-marker)
          (beginning-of-line 1)
          (org-timer-set-timer opt)))))

  (global-set-key (kbd "<f9> p") 'josh/org-current-task-timer)
#+end_src
*** Quick key for clocking into current task

#+begin_src emacs-lisp
  (global-set-key (kbd "<f11>") 'org-clock-jump-to-current-clock)
#+end_src

** Refiling to other places
   This is so we're able to refile to other files
#+begin_src emacs-lisp
  (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                   (org-agenda-files :maxlevel . 9))))
#+end_src
** Store links
   Storing links in Emacs
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c l") 'org-store-link)
#+end_src
** Better task states
   From http://doc.norang.ca/org-mode.html
#+begin_src emacs-lisp
  (setq org-todo-keywords
         (quote ((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d)")
                 (sequence "WAITING(w@/!)" "HOLD(h@/!)" "|" "CANCELLED(c@/!)" "DEFERRED(f@/!)"))))

  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "red" :weight bold)
                ("NEXT" :foreground "blue" :weight bold)
                ("DONE" :foreground "forest green" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold)
                ("DEFERRED" :foreground "forest green" :weight bold))))

  (setq org-todo-state-tags-triggers
        (quote (("CANCELLED" ("CANCELLED" . t))
                ("WAITING" ("WAITING" . t))
                ("HOLD" ("WAITING") ("HOLD" . t))
                (done ("WAITING") ("HOLD"))
                ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                ("DONE" ("WAITING") ("CANCELLED") ("HOLD")))))
#+end_src
** Babel
*** Babel languages
#+begin_src emacs-lisp
  (org-babel-do-load-languages
   (quote org-babel-load-languages)
   (quote ((emacs-lisp . t)
           (ditaa . t)
           (R . t)
           (python . t)
           (ledger . t)
           (org . t)
           (latex . t))))
#+end_src
*** Ditaa
#+begin_src emacs-lisp
  (setq org-ditaa-jar-path "/usr/bin/ditaa")
#+end_src
* Sawfish
  Automatically load .jl files as sawfish (not Julia)
#+begin_src emacs-lisp
  (setq auto-mode-alist (cons '("\\.sawfishrc$"  . sawfish-mode) auto-mode-alist)
        auto-mode-alist (cons '("\\.jl$"         . sawfish-mode) auto-mode-alist)
        auto-mode-alist (cons '("\\.sawfish/rc$" . sawfish-mode) auto-mode-alist))

#+end_src
* Helm
#+begin_src emacs-lisp
  (require 'helm-config)
  (global-set-key (kbd "C-c h") 'helm-mini)
  ;; (helm-mode 1)
  (global-set-key (kbd "C-x b") 'helm-buffers-list)
  ;; (global-set-key (kbd "C-x C-f") 'helm-find-files)
  (global-set-key (kbd "C-x f") 'helm-for-files)
  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (global-set-key (kbd "M-s o") 'helm-occur)
  (global-set-key (kbd "M-g s") 'helm-do-grep)
  (global-set-key (kbd "M-g b") 'helm-resume)
  (global-set-key (kbd "C-c SPC") 'helm-all-mark-rings)
#+end_src
** Other Helm actions I find useful
   I like being able to open an xterm or quickly jump to dired with helm.
#+begin_src emacs-lisp
  (defun helm-ff-dired ()
    "Run open file externally command action from `helm-source-find-files'."
    (interactive)
    (when helm-alive-p
      (helm-quit-and-execute-action 'helm-point-file-in-dired)))

  (define-key helm-map (kbd "C-c j") 'helm-ff-dired)

  (defun helm-xterm-directory (file)
    "Open an xterm starting in FILE's directory."
    (start-xterm (if (file-directory-p file)
                     file
                   (file-name-directory file))))

  (defun helm-ff-xterm-directory ()
    "Open xterm on file's directory"
    (interactive)
    (when helm-alive-p
      (helm-quit-and-execute-action 'helm-xterm-directory)))

  (define-key helm-map (kbd "C-c J") 'helm-ff-xterm-directory)
#+end_src

* Processing
  Define the location of processing.
  Will be different for you.
#+begin_src emacs-lisp
  (setq processing-location "~/Downloads/processing-2.1.2/processing-java")
#+end_src
* Useful, but unnecessary, functions
** Word counting
#+begin_src emacs-lisp
(defun word-count nil "Count words in buffer" (interactive)
  (shell-command-on-region (point-min) (point-max) "wc -w"))
#+end_src

** Aliases
#+begin_src emacs-lisp
(defun afm ()				;Shorter than typing auto-fill-mode
  (interactive)
  (auto-fill-mode))

(defun ttl ()
  (interactive)
  (toggle-truncate-lines))
#+end_src

** Killing buffers
#+begin_src emacs-lisp
;; Display buffers and kill them
(defun kill-some-buffers2 (&optional list)
  "Kill some buffers.  Asks the user whether to kill each one of them.
Non-interactively, if optional argument LIST is non-nil, it
specifies the list of buffers to kill, asking for approval for each one."
  (interactive)
  (if (null list)
      (setq list (buffer-list)))
  (while list
    (let* ((buffer (car list))
	   (name (buffer-name buffer)))
      (and name				; Can be nil for an indirect buffer
					; if we killed the base buffer.
	   (not (string-equal name ""))
	   (/= (aref name 0) ?\s)
	   (switch-to-buffer name)
	   (kill-buffer-ask buffer)))
    (setq list (cdr list))))
(global-set-key (kbd "C-x M-k") 'kill-some-buffers2)
#+end_src


#+begin_src emacs-lisp
(add-hook 'artist-mode-hook
 (lambda ()
   (define-key artist-mode-map [remap artist-next-line] 'picture-move-down)
   ))
#+end_src
** Viewing and killing buffers
#+begin_src emacs-lisp
(defun view-and-kill-some-buffers (&optional list)
  "View and kill buffers"
  (interactive)
  (if (null list)
      (setq list (buffer-list)))
  (while list
    (let* ((buffer (car list))
	   (name (buffer-name buffer)))
      (switch-to-buffer buffer)
      (and name				; Can be nil for an indirect buffer
					; if we killed the base buffer.
	   (not (string-equal name ""))
	   (/= (aref name 0) ?\s)
	   (kill-buffer-ask buffer)))
    (setq list (cdr list))))
#+end_src

** What I do when editing some text files
#+begin_src emacs-lisp
(defun txt-stuff ()
  "A lot of stuff you do when writing in text files"
  (interactive)
  (auto-fill-mode 1)
  (use-hard-newlines 1 'always))
#+end_src

** Starting an Xterm in current directory
#+begin_src emacs-lisp
  (defun start-xterm (&optional dirpath)
      "Start a new xterm in the current directory. SSH if necessary"
      (interactive)
      (let ((path (if dirpath dirpath default-directory)))
        "Return the local portion of a path.

    If PATH is local, return it unaltered.
    If PATH is remote, return the remote diretory portion of the path."
        (if (tramp-tramp-file-p path)
            (let ((loc (elt (tramp-dissect-file-name path) 3))
                  (host (elt (tramp-dissect-file-name path) 2)))
              (start-process "xterm" " xterm-processes" "xterm" "-T" (format "%s: %s" host loc) "-e" (format "ssh -t %s 'cd %s; bash'" host loc)))
          (start-process "xterm" " xterm-processes" "xterm" "-T" path "-e" (format "cd \"%s\"; zsh" path)))))
  (global-set-key (kbd "<f9> x") 'start-xterm)
#+end_src

** Copy the path
#+begin_src emacs-lisp
(defun file-name-copy-path ()
  "Copy the path the of the of the current buffer"
  (interactive)
  (kill-new (message "%s" (buffer-file-name))))
(global-set-key (kbd "<f9> c") 'file-name-copy-path)
#+end_src

** Word wrapping
#+begin_src emacs-lisp
 (defun ww ()
  "Set word wrapping"
  (interactive)
  (setq word-wrap (if word-wrap nil t)))
#+end_src
** Half Term
#+begin_src emacs-lisp
(defun run-half-term ()
   "Run a shell in half a window."
   (interactive)
   (split-window-vertically nil)
   (other-window 1)
   (term "/bin/bash")
   (rename-uniquely)
   (other-window -1))

(global-set-key (kbd "C-x 4 t") 'run-half-term)
#+end_src
** Search Gregg Shorthand Dictionary
#+begin_src emacs-lisp
  (defun gsd ()
    (interactive)
      (find-file-read-only "~/Downloads/gregg/gsd.txt")
      (helm-occur)
      (start-process "evince-gsd" " gsd-processes" "evince"
                     (concat "--page-label="
                             (number-to-string (- (string-to-number
                                                   (substring (what-page) 5 8))
                                                  12)))
                     "/home/jm3/Downloads/gregg/gsd.pdf"))
  (global-set-key (kbd "<f9> g") 'gsd)
#+end_src
** Window Dedication
#+begin_src emacs-lisp
;; http://dfan.org/blog/2009/02/19/emacs-dedicated-windows/
(defun toggle-current-window-dedication ()
 (interactive)
 (let* ((window    (selected-window))
        (dedicated (window-dedicated-p window)))
   (set-window-dedicated-p window (not dedicated))
   (message "Window %sdedicated to %s"
            (if dedicated "no longer " "")
            (buffer-name))))

(global-set-key [pause] 'toggle-current-window-dedication)
#+end_src
** Chinese Cangjie 5 input
   I created a quail package for Cangjie version 5 using libcangjie's
   dictionary.  The main advantage to using it over the built-in
   =chinese-cns-tsangchi= or =chinese-b5-tsangchi= is that this method
   allows you to type simplified Chinese characters.

#+begin_src emacs-lisp
  (register-input-method
   "Cangjie5" "Chinese-BIG5" 'quail-use-package
   "C5" "Cangjie version 5"
   "cangjie5.el")
#+end_src

   A quick key to help look up Cangjie codes for characters I don't know.
#+begin_src emacs-lisp
  (global-set-key (kbd "<f9> s") 'quail-show-key)
#+end_src
** Auto fill line
   Sometimes I want to wrap a line, but pressing =M-q= will treat
   everything as one huge paragraph, messing up the structure.
   This simple function acts like we temporarily turn on
   auto-fill-mode, wrap the line, and then turn it off.

#+begin_src emacs-lisp
  (defun josh/fill-line ()
    "Wrap the line"
    (interactive)
    (save-excursion
      (end-of-line)
      (funcall normal-auto-fill-function)))

  (global-set-key (kbd "M-Q") 'josh/fill-line)
#+end_src
** Switch to scratch buffer
   A quick hotkey for switching to the scratch buffer.
#+begin_src emacs-lisp
  (defun switch-to-scratch ()
    "Switch to scratch"
    (interactive)
    (switch-to-buffer "*scratch*"))
  
  (global-set-key (kbd "C-h C-s") 'switch-to-scratch)
#+end_src
* Emacs Rocks
  Things I got from watching "Emacs Rocks"
** Multiple Cursors
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/Downloads/multiple-cursors/")
  (require 'multiple-cursors)
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-M-<") 'mc/mark-all-like-this-dwim)
  (global-unset-key (kbd "C-<down-mouse-1>"))
  (global-set-key (kbd "C-<mouse-1>") 'mc/add-cursor-on-click)
#+end_src
** Expand Region
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/Downloads/expand-region.el/")
  (require 'expand-region)
  (global-set-key (kbd "C-=") 'er/expand-region)
#+end_src
** Ace Jump Mode
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/elisp/ace-jump-mode/")
  (require 'ace-jump-mode)
  (global-set-key (kbd "C-0") 'ace-jump-mode)
  (setq ace-jump-mode-case-fold t)
  (setq ace-jump-mode-scope 'frame)
  ;; To set to only use lowercase
  ;; (setq ace-jump-mode-move-keys (loop for i from ?a to ?z collect i))
#+end_src

* Other modes
** Enriched Mode
#+begin_src emacs-lisp
(add-hook 'enriched-mode-hook
 (lambda ()
   (define-key enriched-mode-map [remap newline-and-indent] nil)
   (define-key enriched-mode-map "\C-m" nil)
   (define-key enriched-mode-map [remap move-beginning-of-line] nil)
   ))
#+end_src
** Java Mode
#+begin_src emacs-lisp
(add-hook 'java-mode-hook
	  (lambda ()
	    (c-set-style "java")))
#+end_src
** Ledger
#+begin_src emacs-lisp
  (add-to-list 'load-path "~/elisp/ledger/")
  (require 'ledger)
#+end_src
** Swank-js
#+begin_src emacs-lisp
  (add-hook 'css-mode-hook
             (lambda ()
               (define-key css-mode-map "\M-\C-x" 'slime-js-refresh-css)
               (define-key css-mode-map "\C-c\C-r" 'slime-js-embed-css)))
#+end_src
#+begin_src emacs-lisp
  (global-set-key [f5] 'slime-js-reload)
  (add-hook 'js-mode-hook
            (lambda ()
              (js2-minor-mode 1)
              (auto-complete-mode 1)
              (slime-js-minor-mode 1)))
#+end_src
** js2-mode
   Use js2-mode by default
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.js$" . js2-mode))
#+end_src
   I prefer less indentation.
#+begin_src emacs-lisp
  (setq-default js2-basic-offset 4)
#+end_src

** Projectile
#+begin_src emacs-lisp
  (require 'projectile)
  (projectile-global-mode)
  (setq projectile-completion-system 'helm-comp-read)
#+end_src
** Yasnippet
   So I can have recursive snippets.
#+begin_src emacs-lisp
  (setq yas-triggers-in-field t)
#+end_src
