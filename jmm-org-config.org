#+TITLE: Josh Moller-Mara's Org-mode config
#+AUTHOR: Josh Moller-Mara
#+OPTIONS: toc:2 h:4

I make heavy use of [[http://orgmode.org/][Org-mode]], for organizing my TODOs, keeping track
of ideas, references, and links, as well as for literate programming.

Since I use a lot of the contributed modules, we make sure we've
loaded ~org-plus-contrib~

#+BEGIN_SRC emacs-lisp
(use-package org
  :ensure org-plus-contrib
  :defer t
  :bind (("C-c c" . org-capture)
	 ("C-c a" . org-agenda)
	 ("C-c l" . org-store-link)
	 ("C-c L" . org-insert-link-global)
	 ("C-c o" . org-open-at-point-global)
	 :map org-mode-map
	 ("M-T" . josh/org-convert-added-to-created-property)
	 ("M-N" . josh/org-convert-added-or-add-created)
	 ("M-M" . josh/org-toggle-marked-tag)
	 )
  :mode ("\\.org\\'" . org-mode)
  :init
  (setq org-indirect-buffer-display 'current-window)
  (setq org-catch-invisible-edits 'smart)
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id)
  (setq org-clock-out-remove-zero-time-clocks t)
  (setq org-highest-priority ?A
	org-lowest-priority ?F
	org-default-priority ?D)
  (setq org-agenda-dim-blocked-tasks nil)
  (unbind-key "C-'" org-mode-map)
  :config
  (add-to-list 'org-tags-exclude-from-inheritance "MARKED")
  (add-to-list 'org-tag-faces '("MARKED" :foreground "MediumPurple1" :weight bold))
  (require 'org-screenshot)
  ;; (require 'org-depend) 		;Replace with org-edna
  (require 'org-expiry)
  (require 'org-inlinetask)
  (require 'org-collector)
  (require 'ox))
#+END_SRC

* Setup my agenda file
   Read from "org-agendas" where the agenda files are.
   Set the default span to a day view.
   I also have a script periodically export agendas. So to keep from
   destroying an agenda I'm currently viewing, I turn on sticky agendas.

   I find that time grids can get in my way if there are too many of
   them, so we'll just show a few times instead of the default of every two hours.
#+begin_src emacs-lisp
(setq org-agenda-files (concat (file-name-as-directory org-directory) "org-agendas.txt"))
(setq org-agenda-span 3)
(setq org-agenda-sticky t)
;; (setcar (nthcdr 2 org-agenda-time-grid) '(900 1200 1700))
#+end_src
** Don't open encrypted files

   You can have encrypted files in your org-agenda. The only problem
   is that every time you want to generate an agenda, you either need
   to have the encrypted file open or you need to enter your
   password. I'd rather only display encrypted org files in my agenda
   if they're already open, otherwise I just skip them.

#+BEGIN_SRC emacs-lisp
(defun jmm/org-agenda-skip-unopened-encrypted (orig-fun &rest args)
  "Don't try to open encrypted org files that aren't already open."
  (let ((res (apply orig-fun args)))
    (-filter (lambda (file)
	       (if (s-equals? (f-ext file) "gpg")
		   (get-file-buffer file)
		 t))
	     res)))

(advice-add 'org-agenda-files :around #'jmm/org-agenda-skip-unopened-encrypted)

(defun jmm/org-id-skip-unopened-encrypted (orig-fun &rest args)
  "Don't try to open encrypted org files that aren't already open when updating the org-id database."
  (let ((org-id-files (-filter (lambda (file)
				       (if (s-equals? (f-ext file) "gpg")
					   (get-file-buffer file)
					 t))
			       org-id-files)))
    (apply orig-fun args)))
;; TODO: Maybe we should push the encrypted files back into the id
;; database afterward, though. This currently just removes them from
;; the db completely.

(advice-add 'org-id-update-id-locations :around #'jmm/org-id-skip-unopened-encrypted)
#+END_SRC

* Default notes file?
   Note to self, figure out what the difference between this and agenda is.

#+begin_src emacs-lisp
  (setq org-default-notes-file (concat (file-name-as-directory org-directory) "gtd-test.org"))
#+end_src
* Capture templates
   Need to make this more portable across different systems. I think it defaults to org-directory.
#+begin_src emacs-lisp
(setq org-capture-templates
      '(("t" "Todo" entry (file+headline "gtd-test.org" "Tasks")
         "* TODO %i%?\n  Added: %U")
        ("r" "Refile" entry (file "refile.org")
         "* %i%?\n  Added: %U")
        ("a" "Today" entry (file+headline "gtd-test.org" "Tasks")
         "* TODO %?\n  SCHEDULED: <%<%Y-%m-%d %a>>\n  Added: %U")
        ("d" "Date" entry (file+datetree+prompt "~/org/journal.org")
         "* %?\n%t\n")
	("w" "Calendar" entry (file+headline "gtd-test.org" "Calendar")
         "* %?\n%^t\n")
	("E" "Email capture")
	("EE" "Event (from email)" entry (file+headline "gtd-test.org" "Calendar")
	 "* %:subject%?\n%^T\n%i\n%a%^{LOCATION}p")
	("Et" "Todo (from email)" entry (file+headline "gtd-test.org" "Tasks")
	 "* TODO %:subject%?  :email:\n%i\n%a")
	("Ea" "Todo today (from email)" entry (file+headline "gtd-test.org" "Tasks")
	 "* TODO %:subject%?   :email:\n  SCHEDULED: <%<%Y-%m-%d %a>>\n%a\n%i")
	("Er" "Todo reply to email" entry (file+headline "gtd-test.org" "Tasks")
	 "* TODO Reply to %(car (s-split \" \" \"%:from\")): \"%:subject\"%?   :email:\n%a\n%i")
        ("l" "Lookup stuff")
        ("ll" "Lookup" entry (file+headline "lookup.org" "Lookup")
         "* %?\n  Added: %U")
        ("lp" "Lookup paper" entry (file+headline "lookup.org" "Paper lookup")
         "* TODO %?")
	("lP" "Lookup paper (link)" entry (file+headline "lookup.org" "Paper lookup")
	 "* [[%c][%(www-get-page-title (current-kill 0))]]\n  Added: %U\n  - %c")
        ("L" "Lookup link" entry (file+headline "lookup.org" "Lookup")
         "* [[%c][%(www-get-page-title (current-kill 0))]]\n  Added: %U\n  - %c")
        ("s" "Shopping" entry (file+headline "gtd-test.org" "Shopping")
         "* %?\n  Added: %U")
        ("N" "Neuroecon" entry (file+headline "neuroecon.org" "Neuroecon")
         "* %?\n%i\n  Added: %U")
	("n" "NYU")
	("ne" "NYU Events" entry (file+headline "nyu.org" "NYU Events Calendar") "* %?\n%^t\n")
	("nc" "CNS Events" entry (file+headline "nyu.org" "CNS Events") "* %?\n%^t\n")
	("nd" "Service disruption" entry (file+headline "nyu.org" "Service disruption") "* %?\n%^t\n")
        ("M" "Someday/Maybe" entry (file+headline "someday-maybe.org" "Someday/Maybe")
         "* %?\n  Added: %U")
        ("m" "Someday/Maybe lists")
        ("mm" "Someday/Maybe" entry (file+headline "someday-maybe.org" "Someday/Maybe")
         "* %?\n  Added: %U")
        ("mc" "Computer maybe" entry (file+headline "someday-maybe.org" "Computer Maybe")
         "* %?\n  Added: %U")
        ("ml" "Learn" entry (file+headline "someday-maybe.org" "Learn")
         "* %?\n  Added: %U")
        ("mb" "Books/Reading" entry (file+headline "movies-books-media.org" "Books/Reading")
         "* %?\n  Added: %U")
        ("mv" "Movies" entry (file+headline "movies-books-media.org" "Movies")
         "* %?\n  Added: %U")
        ("ma" "Audio/Music" entry (file+headline "movies-books-media.org" "Music/Audio")
         "* %?\n  Added: %U")
        ("ms" "Shanghai goals" entry (file+headline "someday-maybe.org" "Shanghai Goals")
         "* %?\n  Added: %U")
        ("o" "thoughts" plain (file "thoughts-misc.txt")
         "\n\n%U -\n\n %?\n" :empty-lines 1)
        ("e" "Erlich stuff")
        ("et" "Erlich tasks" entry (file+headline "erlich.org" "Erlich tasks")
         "* TODO %i%?\n  Added: %U")
        ("ea" "Erlich today" entry (file+headline "erlich.org" "Erlich tasks")
         "* TODO %?\n  SCHEDULED: <%<%Y-%m-%d %a>>\n  Added: %U")
        ("eo" "Erlich thoughts" entry (file+headline "erlich.org" "Erlich thoughts")
         "* %i%?\n  Added: %U")
        ("em" "Erlich maybe" entry (file+headline "erlich.org" "Erlich maybe")
         "* %?\n  Added: %U")
        ("j" "Journal Stuff")
        ("jr" "Journal Resume" entry (file+datetree "~/org/journal.org")
         "* %?\n%U\n" :clock-in t :clock-resume t)
        ("jc" "Journal Clock-In" entry (file+datetree "~/org/journal.org")
         "* %?\n%U\n" :clock-in t :clock-keep t)
        ("ji" "Journal Clock-In Immediate" entry (file+datetree "~/org/journal.org")
         "* %c %u\n%U\n" :clock-in t :clock-keep t :immediate-finish t)
	("jw" "Journal Weight table" table-line (id "ffb6e5d6-fdfe-47cf-ad1c-a6e4ea7900dc")
         "| %u | %? |")
	("jW" "Journal Wake table" table-line (id "3bca8376-bfdc-40af-bf0a-c130fd677c33")
         "| %U | %u | %? |")
        ("J" "Jokes" plain (file "jokes.txt")
         "\n\n%U -\n\n %?\n" :empty-lines 1)
        ("v" "Vocabulary" entry
         (file+headline "~/reading/words-i-learned.org" "Vocabulary")
         "* %^{The word} :drill:\n Added: %U\n %^{Extended word (may be empty)|%\\1}\n** Answer \n%^{The definition}")
        ("V" "Two-sided Vocabulary" entry
         (file+headline "~/reading/words-i-learned.org" "Vocabulary")
         "* <[%^{The word}]> :drill:\n Added: %U\n    :PROPERTIES:\n    :DRILL_CARD_TYPE: twosided\n    :END:\n** Word\n%^{Extended word (may be empty)|%\\1}\n** Definition\n%^{Definition}\n** Examples\n%^{Examples}\n")
        ("c" "Chinese Word" entry
         (file+headline "~/reading/skip/chinese.org" "Words")
         "* <[%(josh/chinese-prompt)]> :drill:\n Added: %U\nDefinition:\n%(josh/chinese-get-definition (josh/chinese-dict-find josh/chinese-word))\n** Characters\n%(josh/chinese-get-word josh/chinese-word-dict)\n** Pronunciation\n%(josh/chinese-get-pronunciation josh/chinese-word-dict)\n** Cangjie\n%(josh/chinese-cangjie-codes josh/chinese-words)\n")
        ("C" "Chinese Word (Read)" entry
         (file+headline "~/reading/skip/chinese.org" "Words")
         "* <[%(josh/chinese-prompt)]> :drill:\n Added: %U\n%(josh/chinese-get-word (josh/chinese-dict-find josh/chinese-word))\n** Pronunciation\n%(josh/chinese-get-pronunciation josh/chinese-word-dict)\n** Cangjie\n%(josh/chinese-cangjie-codes josh/chinese-words)\n** Definition\n%(josh/chinese-get-definition josh/chinese-word-dict)\n")
        ("R" "reading" plain
         (file "~/org/data/reading.csv")
         "%(format-time-string \"%s\"),\"%(format-time-string \"%Y-%m-%d\")\",\"%(josh/prompt-book)\",%^{Start},%^{End}")
	("x" "Miscellaneous")
	("xt" "Tweet" entry (file+headline "ideas.org" "Tweets")
         "* %i%?\n  Added: %U")))
#+end_src
   Fix a bug causing org-capture to mess up line numbers. This can
   make loading things with long lines slow, though.
#+begin_src emacs-lisp
  (setq-default cache-long-scans nil)
  (setq org-element-use-cache nil)
#+end_src

   A a function to make testing capture templates easier.
#+BEGIN_SRC emacs-lisp
(defun josh/add-to-capture (template)
  (let ((key (car template)))
    (setq org-capture-templates
	  (delete-if (lambda (x) (equal (car x) key)) org-capture-templates))
    (add-to-list 'org-capture-templates
		 template)))
#+END_SRC
** Get the title of a URL
    Used for a capture template. I want my links to also have a sort of description
#+BEGIN_SRC emacs-lisp
(defun html-entities-to-unicode (string)
  "Convert html entities. Modified from konr's answer on https://stackoverflow.com/a/8483409"
  (let* ((plist '(Aacute "Á" aacute "á" Acirc "Â" acirc "â" acute "´" AElig "Æ" aelig "æ" Agrave "À" agrave "à" alefsym "ℵ" Alpha "Α" alpha "α" amp "&" and "∧" ang "∠" apos "'" aring "å" Aring "Å" asymp "≈" atilde "ã" Atilde "Ã" auml "ä" Auml "Ä" bdquo "„" Beta "Β" beta "β" brvbar "¦" bull "•" cap "∩" ccedil "ç" Ccedil "Ç" cedil "¸" cent "¢" Chi "Χ" chi "χ" circ "ˆ" clubs "♣" cong "≅" copy "©" crarr "↵" cup "∪" curren "¤" Dagger "‡" dagger "†" darr "↓" dArr "⇓" deg "°" Delta "Δ" delta "δ" diams "♦" divide "÷" eacute "é" Eacute "É" ecirc "ê" Ecirc "Ê" egrave "è" Egrave "È" empty "∅" emsp " " ensp " " Epsilon "Ε" epsilon "ε" equiv "≡" Eta "Η" eta "η" eth "ð" ETH "Ð" euml "ë" Euml "Ë" euro "€" exist "∃" fnof "ƒ" forall "∀" frac12 "½" frac14 "¼" frac34 "¾" frasl "⁄" Gamma "Γ" gamma "γ" ge "≥" gt ">" harr "↔" hArr "⇔" hearts "♥" hellip "…" iacute "í" Iacute "Í" icirc "î" Icirc "Î" iexcl "¡" igrave "ì" Igrave "Ì" image "ℑ" infin "∞" int "∫" Iota "Ι" iota "ι" iquest "¿" isin "∈" iuml "ï" Iuml "Ï" Kappa "Κ" kappa "κ" Lambda "Λ" lambda "λ" lang "〈" laquo "«" larr "←" lArr "⇐" lceil "⌈" ldquo "“" le "≤" lfloor "⌊" lowast "∗" loz "◊" lrm "" lsaquo "‹" lsquo "‘" lt "<" macr "¯" mdash "—" micro "µ" middot "·" minus "−" Mu "Μ" mu "μ" nabla "∇" nbsp "" ndash "–" ne "≠" ni "∋" not "¬" notin "∉" nsub "⊄" ntilde "ñ" Ntilde "Ñ" Nu "Ν" nu "ν" oacute "ó" Oacute "Ó" ocirc "ô" Ocirc "Ô" OElig "Œ" oelig "œ" ograve "ò" Ograve "Ò" oline "‾" omega "ω" Omega "Ω" Omicron "Ο" omicron "ο" oplus "⊕" or "∨" ordf "ª" ordm "º" oslash "ø" Oslash "Ø" otilde "õ" Otilde "Õ" otimes "⊗" ouml "ö" Ouml "Ö" para "¶" part "∂" permil "‰" perp "⊥" Phi "Φ" phi "φ" Pi "Π" pi "π" piv "ϖ" plusmn "±" pound "£" Prime "″" prime "′" prod "∏" prop "∝" Psi "Ψ" psi "ψ" quot "\"" radic "√" rang "〉" raquo "»" rarr "→" rArr "⇒" rceil "⌉" rdquo "”" real "ℜ" reg "®" rfloor "⌋" Rho "Ρ" rho "ρ" rlm "" rsaquo "›" rsquo "’" sbquo "‚" scaron "š" Scaron "Š" sdot "⋅" sect "§" shy "" Sigma "Σ" sigma "σ" sigmaf "ς" sim "∼" spades "♠" sub "⊂" sube "⊆" sum "∑" sup "⊃" sup1 "¹" sup2 "²" sup3 "³" supe "⊇" szlig "ß" Tau "Τ" tau "τ" there4 "∴" Theta "Θ" theta "θ" thetasym "ϑ" thinsp " " thorn "þ" THORN "Þ" tilde "˜" times "×" trade "™" uacute "ú" Uacute "Ú" uarr "↑" uArr "⇑" ucirc "û" Ucirc "Û" ugrave "ù" Ugrave "Ù" uml "¨" upsih "ϒ" Upsilon "Υ" upsilon "υ" uuml "ü" Uuml "Ü" weierp "℘" Xi "Ξ" xi "ξ" yacute "ý" Yacute "Ý" yen "¥" yuml "ÿ" Yuml "Ÿ" Zeta "Ζ" zeta "ζ" zwj "" zwnj ""))
	 (get-numeric-function (lambda (s)
				 (char-to-string (string-to-number (cadr (s-match "&#\\([0-9]+\\);" s))))))
         (get-function (lambda (s) (or (plist-get plist (intern (substring s 1 -1))) s))))
    (--> string
	 (replace-regexp-in-string "&#\\([0-9]+\\);" get-numeric-function it)
	 (replace-regexp-in-string "&[^; ]*;" get-function it))))

(defun www-get-page-title (url)
  "Modified from https://lists.gnu.org/archive/html/help-gnu-emacs/2010-07/msg00291.html"
  (html-entities-to-unicode
   (let ((title))
    (with-current-buffer (url-retrieve-synchronously url)
      (let* ((title (progn (goto-char (point-min))
			   (when (re-search-forward "<title>\\([^<]*\\)</title>" nil t 1)
			     (match-string 1))))
	     (coding (progn (goto-char (point-min))
			    (when (re-search-forward "charset=\"?\\([-0-9a-zA-Z]*\\)\"?" nil t 1)
			      (match-string 1)))))
	(if (and coding (not (string= "" coding)))
	    (decode-coding-string title (intern (downcase coding)))
	  title))))))
#+END_SRC
* Org agenda listings
#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        (quote
         (("w" todo "WAITING")
          ("W" todo-tree "WAITING")
          ("H" "Office and Home Lists"
           ((agenda)
            (tags-todo "OFFICE")
            (tags-todo "HOME")
            (tags-todo "COMPUTER")
            (tags-todo "DVD")
            (tags-todo "READING")))
          ("b" "Things to do if bored"
           tags "IFBORED"
           ((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done)))
           ("~/org/blockreddit/ifbored.html"))
          ("D" "Daily Action List"
           ((agenda "" ((org-agenda-ndays 1)
                        (org-agenda-sorting-strategy
                         (quote ((agenda time-up priority-down tag-up) )))
                        (org-deadline-warning-days 0)))))
          ("z" "ZPM (hipster PDA)"
           ((agenda "" ((org-agenda-span 33)
                        (org-habit-show-habits nil)
                        (org-agenda-show-log nil)
                        (org-agenda-start-with-clockreport-mode nil)
                        (org-agenda-sorting-strategy
                         (quote ((agenda time-up priority-down tag-up) )))
                        ))))
          ("U" "Unscheduled NoDeadline" alltodo ""
           ((org-agenda-skip-function
             '(org-agenda-skip-entry-if 'scheduled 'deadline))))
          ("d" agenda "" ((org-agenda-span 1)) ("~/agendas-org/day-agenda.html"))
          ("k" agenda "" ((org-agenda-span 7)) ("~/agendas-org/week-agenda.html"))
          ("X" agenda "" ((org-agenda-span 3)
                          ;; (org-agenda-start-with-log-mode t)
                          (org-agenda-start-with-clockreport-mode t)) ("~/org/newtab/agenda.html"))
          )))
#+end_src

Agenda of tasks that are labeled "TODO" but don't have any schedule or deadline.
#+BEGIN_SRC emacs-lisp
  (require 'org-agenda)
  (org-add-agenda-custom-command
   '("u" "Unscheduled" todo "TODO"
     ((org-agenda-skip-function (lambda () (or (zin/org-agenda-skip-tag "task" t)
                                               (org-agenda-skip-entry-if 'scheduled 'deadline))))
      (org-agenda-overriding-header "Unscheduled tasks: "))))
#+END_SRC

An agenda which shows which papers I should read.
#+BEGIN_SRC emacs-lisp
;; Note: josh/plist-get is defined elsewhere in this file
(defun jmm/org-get-raw-scheduled ()
  "Raw scheduled date for element at point."
  (concat				;If it's nil, don't display anything
   (josh/plist-get (org-element-at-point) 'headline :scheduled 'timestamp :raw-value)))

(defun jmm/org-get-raw-created ()
  "Raw created date for element at point."
  (concat				;If it's nil, don't display anything
   (org-entry-get (point) org-expiry-created-property-name)))

(defun jmm/org-get-created-set-property (agendastr)
  "Takes in a line AGENDASTR.
   If it has \"created-time\" set, return it.
   Otherwise looks for the `org-expiry-created-property-name' and sets \"created-time\""
  (let* ((has-ct-prop (plist-member (text-properties-at 0 agendastr) 'created-time))
	 (createdtime (cadr has-ct-prop)))
    (if has-ct-prop
	createdtime
      (let* ((createdprop (org-entry-get (get-text-property 0 'org-hd-marker agendastr) org-expiry-created-property-name))
	     (createts (if createdprop (org-time-string-to-absolute createdprop))))
	(org-add-props agendastr nil
	  'created-time createts)
	createts))))

(defun jmm/org-agenda-sort-created-time (a b)
  "To be set as `org-agenda-cmp-user-defined'.
   Very similar to `org-cmp-ts'"
  (let* ((def (if org-sort-agenda-notime-is-late most-positive-fixnum -1))
	 (ta (or (jmm/org-get-created-set-property a) def))
	 (tb (or (jmm/org-get-created-set-property b) def)))
    (cond ((< ta tb) -1)
	  ((< tb ta) +1))))

(org-add-agenda-custom-command
 '("j" "Journal articles"
   ((tags-todo "+paper"
	      ((org-agenda-overriding-header "Scheduled articles")
	       (org-agenda-skip-function '(lambda () (or (org-agenda-skip-entry-if 'todo 'done) (org-agenda-skip-entry-if 'notscheduled))))
	       (org-agenda-prefix-format " %i %-5:c %-17(jmm/org-get-raw-scheduled) ")
	       (org-agenda-sorting-strategy '(scheduled-up))))
    (tags-todo "+paper"
	      ((org-agenda-overriding-header "Unscheduled articles")
	       (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled 'todo 'done))
	       (org-agenda-prefix-format " %i %-5:c %-22(jmm/org-get-raw-created) ")
	       (org-agenda-cmp-user-defined 'jmm/org-agenda-sort-created-time)
	       (org-sort-agenda-notime-is-late nil)
	       (org-agenda-sorting-strategy '(priority-down user-defined-down))))
    )
   ((org-agenda-hide-tags-regexp "paper"))))
#+END_SRC

A projects-related agenda. View next tasks, waiting, and stuck projects.
#+BEGIN_SRC emacs-lisp
  (org-add-agenda-custom-command
   '("P" "Projects and Next Tasks"
     ((tags-todo "-CANCELLED/!NEXT"
                 ((org-agenda-overriding-header "Next tasks")
                  (org-agenda-skip-function 'bh/skip-projects-and-habits-and-single-tasks)))
      (tags-todo "-CANCELLED+WAITING|HOLD/!"
                 ((org-agenda-overriding-header "Waiting tasks")
                  (org-agenda-skip-function 'bh/skip-non-tasks)))
      (tags-todo "-CANCELLED/!"
                 ((org-agenda-overriding-header "Stuck Projects")
                  (org-agenda-skip-function 'bh/skip-non-stuck-projects))))))
#+END_SRC

Same thing as above, but also include the next three days agenda.
#+BEGIN_SRC emacs-lisp
(org-add-agenda-custom-command
 '(" " "Default agenda"
   ((agenda "" ((org-agenda-prefix-format " %i %-12:c%?-12t% s%(josh/org-show-effort-and-clocked) ")
                (org-agenda-skip-scheduled-if-done t)
                (org-agenda-span 2)))
    (tags-todo "-CANCELLED-HOLD/!NEXT"
          ((org-agenda-overriding-header "Unscheduled next tasks")
           (org-agenda-prefix-format " %i %-12:c%?-12t% s%(josh/org-format-next-time) ")
	   (org-agenda-cmp-user-defined 'jmm/org-agenda-sort-next-time)
    	   (org-sort-agenda-notime-is-late nil)
    	   (org-agenda-sorting-strategy '(priority-down user-defined-down))
           (org-agenda-skip-function
            (lambda () (or (org-agenda-skip-entry-if 'scheduled 'deadline)
                           (bh/skip-projects-and-habits-and-single-tasks))))))
    (tags-todo "-CANCELLED+WAITING/!"
               ((org-agenda-overriding-header "Unscheduled waiting tasks")
                (org-agenda-skip-function
                 (lambda () (org-agenda-skip-entry-if 'scheduled 'deadline)))
                (org-agenda-prefix-format " %i %-12:c%?-12t% s%(josh/org-format-waiting-time) ")))
    (tags-todo "-CANCELLED-HOLD/!"
               ((org-agenda-overriding-header "Stuck Projects")
                (org-agenda-skip-function 'bh/skip-non-stuck-projects)
                (org-agenda-prefix-format " %i %-12:c%?-12t% s%(josh/org-format-max-clock-time) ")))
    (tags "REFILE"
          ((org-agenda-hide-tags-regexp "REFILE")
	   (org-agenda-overriding-header "Refile:")))
    (todo "TODO"
          ((org-agenda-skip-function (lambda () (or (zin/org-agenda-skip-tag "task" t)
                                                    ;; (bh/skip-projects-and-habits)
                                                    (josh/skip-project-to-next-heading)
                                                    (org-agenda-skip-entry-if 'scheduled 'deadline))))
           (org-agenda-overriding-header "Unscheduled tasks: ")
	   (org-agenda-cmp-user-defined 'jmm/org-agenda-sort-created-time)
	   (org-sort-agenda-notime-is-late nil)
	   (org-agenda-sorting-strategy '(priority-down user-defined-down))
           (org-agenda-prefix-format " %i %-12:c%?-12t% s%(josh/org-format-age-from-added) "))))))
(defun jmm/org-default-agenda ()
  "Display my default org agenda"
  (interactive)
  (org-agenda nil " "))

(bind-key "<f12>" 'jmm/org-default-agenda)
#+END_SRC

Other agendas. Like movies to see, things I need to buy, and so on.
#+BEGIN_SRC emacs-lisp
(org-add-agenda-custom-command
   '("1" "Shopping" tags "+SHOPPING-TODO=\"DONE\"-TODO=\"CANCELLED\""
     ((org-agenda-hide-tags-regexp "SHOPPING")
      (org-agenda-overriding-header "Shopping stuff: "))))

(org-add-agenda-custom-command
   '("v" "Movies" tags "+movie-TODO=\"DONE\"-TODO=\"CANCELLED\""
     ((org-agenda-hide-tags-regexp "movie")
      (org-agenda-overriding-header "Movies to see: "))))
#+END_SRC

An agenda for unscheduled tasks where we've set a deadline, but never scheduled it.
Show earlier due entries first.

#+BEGIN_SRC emacs-lisp
(defun josh/plist-get (plist prop &rest rest-props)
  "Recursively apply `plist-get' to plist"
  (let ((got (plist-get plist prop)))
    (if (and got rest-props)
	(apply 'josh/plist-get got rest-props)
      got)))

(defun josh/org-get-raw-deadline ()
  "Raw raw deadline for element at point."
  (josh/plist-get (org-element-at-point) 'headline :deadline 'timestamp :raw-value))

(org-add-agenda-custom-command
   '("u" "Unscheduled Deadline" alltodo ""
     ((org-agenda-overriding-header "Unscheduled TODOs with deadlines")
      (org-agenda-prefix-format " %i %-12:c%?-12t% s%-22(josh/org-get-raw-deadline) ")
      (org-agenda-sorting-strategy '(deadline-up))
      (org-agenda-skip-function
       '(or (org-agenda-skip-entry-if 'scheduled 'notdeadline)
	    (and (bh/is-project-p) (bh/skip-non-stuck-projects)))))))
#+END_SRC

A basic agenda for goals.
In the future I should make this more nuanced.
- Which goals have I started?
- Which goals are deferred?
- What are the different categories of goals, and in what time range
  do I plan to have them done?
  - Do they have deadlines, or are they just lofty ideas?
- Some of these can have ~org-agenda-overriding-columns-format~ set to view it automatically
- Sort by deadlines or importance?

#+BEGIN_SRC emacs-lisp
;; TODO: Eventually just make this more like Sacha Chua's evil plans
(org-add-agenda-custom-command
   `("g" "Goals"
     ((tags "goal"
	    ((org-agenda-overriding-header "Goals")
	     (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))))
      (tags "lifegoal"
	    ((org-agenda-overriding-header "Life Goals")
	     )))
     ((org-agenda-overriding-columns-format "%50ITEM(Goal) %5Effort(Time){:} %6CLOCKSUM{Total}")
      (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
      ;; (org-agenda-view-columns-initially t)
      (org-agenda-hide-tags-regexp ,(rx (or "lifegoal" "goal"))))))
#+END_SRC
** A better way of viewing tags in the agenda

   Tags in the agenda can get pretty messy. [[https://lists.gnu.org/archive/html/emacs-orgmode/2010-12/msg00410.html][This page]] from the
   org-mode mailing list provides a nice function to align tags in the
   agenda to the right margin.
#+BEGIN_SRC emacs-lisp
(defun place-agenda-tags ()
  "Put the agenda tags by the right border of the agenda window."
  (setq org-agenda-tags-column (- 4 (window-width)))
  (org-agenda-align-tags))
(add-hook 'org-finalize-agenda-hook 'place-agenda-tags)
#+END_SRC
** Sorting timestamps in the agenda

   I'd like to sort my ~NEXT~ actions by their age. This lets me know
   which ~NEXT~ actions have been sitting around and not getting done,
   which is a sign that the action needs to be either better specified
   or further broken down.

   Sorting in the agenda is pretty slow. Here are some macros and
   functions that try to use memoization to speed up sorting.

#+BEGIN_SRC emacs-lisp
(defmacro jmm/org-agenda-memoize (funcname key ifnotmemoized)
  "Make a function that memoizes some stuff in org-agenda properties. Use symbol KEY as the text property"
  (let ((hasprop (gensym))
	(newval (gensym)))
    `(defun ,funcname (agendastr)
       (let* ((,hasprop (plist-member (text-properties-at 0 agendastr) ,key)))
	 (if ,hasprop
	     (cadr ,hasprop)		;get the actual value
	   (let* ((,newval (,ifnotmemoized (get-text-property 0 'org-hd-marker agendastr))))
	     (org-add-props agendastr nil
	       ,key ,newval)
	     ,newval))))))

;; FIXME. Needs to be some other number when neither defined
(jmm/org-agenda-memoize
 jmm/org-agenda-get-next-time 'nexttime
 (lambda (orgmarker)
   (with-current-buffer (marker-buffer orgmarker)
     (save-excursion
       (goto-char (marker-position orgmarker))
       (max (josh/absolute-time-or-0 (josh/org-get-next-time))
	    (josh/absolute-time-or-0 (josh/org-get-added-time)))))))

(defun jmm/org-agenda-sort-next-time (a b)
  "To be set as `org-agenda-cmp-user-defined'.
   Very similar to `org-cmp-ts'"
  (let* ((def (if org-sort-agenda-notime-is-late most-positive-fixnum -1))
	 (ta (or (jmm/org-agenda-get-next-time a) def))
	 (tb (or (jmm/org-agenda-get-next-time b) def)))
    (cond ((< ta tb) -1)
	  ((< tb ta) +1))))
#+END_SRC

* Org persistent tags
   Some tags that I might use a lot. (Or maybe I don't, but I just
   don't want to have the hotkeys for each of these tags repeatedly in
   each file.)
#+BEGIN_SRC emacs-lisp
(setq org-tag-persistent-alist '(("task" . ?t) ("drill" . ?d)
				 ("IGNORE" . ?i)
                                 ("IFBORED" . ?b)
				 ("CANCELLED" . ?C)
                                 ("work" . ?w) ("home" . ?h)
                                 ("REWARD" . ?R) ("SHOPPING" . ?s)
                                 ("PESARAN" . ?p) ("erlich" . ?e) ("NEURO" . ?n) ("nyu" . ?y)
                                 ("vague" . ?v) ("lookup" . ?l)
                                 ("CODING" . ?c)
                                 ("SHORTTERM" . ?S) ("LONGTERM" . ?L) ("goal" . ?g) ("lifegoal" . ?G)))

(add-to-list 'org-tags-exclude-from-inheritance "IGNORE")
#+END_SRC
* Define a stuck project
   Stuck projects are projects that don't have a next action or a TODO.
   Also, make sure the "PROJECT" tag isn't inherited.
#+begin_src emacs-lisp
  (setq org-stuck-projects
             '("+PROJECT/-MAYBE-DONE" ("NEXT" "TODO") ("@SHOP")
               "\\<IGNORE\\>"))

  (add-to-list 'org-tags-exclude-from-inheritance "PROJECT")
#+end_src
* If I didn't want it to interfere with windmove
#+begin_src emacs-lisp
  ;; (setq org-replace-disputed-keys t)
#+end_src

* Writing my current task to a file
   I have a conky script that displays my current task. That way, even
   when I'm not in Emacs, I can see what task I'm supposed to be
   working on, and how long I've been clocked into it.
#+begin_src emacs-lisp
  (setq josh/clock-current-task-file "~/.currenttask")

  (defun josh/org-clock-in-conky ()
    (interactive)
    "Creates a file `josh/clock-current-task-file' with the current task and the time started.
  To be used with a script in conky to display what I'm working on."
    (if org-clock-current-task
        (with-temp-file josh/clock-current-task-file
            (progn
              (insert org-clock-current-task)
              (newline)
              (insert (format-time-string "%s" org-clock-start-time))
              (newline)))))

  (defun josh/org-clock-out-conky ()
    (interactive)
    "When I clock out, remove `josh/clock-current-task-file'"
    (if (file-exists-p josh/clock-current-task-file)
            (delete-file josh/clock-current-task-file)))

  ;; (add-hook 'org-clock-in-hook 'josh/org-clock-in-conky)
  ;; (add-hook 'org-clock-out-hook 'josh/org-clock-out-conky)
#+end_src

   Here's another hook that works with my "ceftoolbar" in sawfish.

   The ceftoolbar is a Chromium embedded framework toolbar that
   displays CPU usage, network usage, as well as my current task

#+begin_src emacs-lisp
  (defun josh/org-clock-2 ()
    (interactive)
    "When I clock in or out, call a script that updates the ceftoolbar"
    (start-process "LogTime"
                   (get-buffer-create " *josh-clock-buffer*")
                   "~/.sawfish/scripts/clock-in.sh"))

  (defun josh/org-clock-in-conky2 ()
    (josh/org-clock-in-conky)
    (josh/org-clock-2))

  (defun josh/org-clock-out-conky2 ()
    (josh/org-clock-out-conky)
    (josh/org-clock-2))

  (add-hook 'org-clock-in-hook 'josh/org-clock-in-conky2)
  (add-hook 'org-clock-out-hook 'josh/org-clock-out-conky2)

#+end_src

* Org-drill
Require org-drill.
Add random noise to the due dates of cards, so they're not always clumped together.
Also, change the default cloze delimiters, as the defaults weren't working well for me.
#+begin_src emacs-lisp
(add-to-list 'load-path "~/elisp/org-mode/contrib/lisp/")
(use-package org-drill
  :after org
  :config (progn
	    (add-to-list 'org-modules 'org-drill)
	    (setq org-drill-add-random-noise-to-intervals-p t)
	    (setq org-drill-hint-separator "||")
	    (setq org-drill-left-cloze-delimiter "<[")
	    (setq org-drill-right-cloze-delimiter "]>")
	    (setq org-drill-learn-fraction 0.25)))
#+end_src

** org-preview-latex-fragment
    The function "org-preview-latex-fragment" was deprecated a while
    back, but org-drill still depends on it. So here's a quick hack
    that will display the LaTeX in org-drill.
#+BEGIN_SRC emacs-lisp
(defun org-preview-latex-fragment ()
  (interactive)
  (org-remove-latex-fragment-image-overlays)
  (org-toggle-latex-fragment '(4)))
#+END_SRC

** Chinese word definition library
   Require the library that gets Chinese word definitions. I use this
   to make ~org-drill~ flashcards fairly quickly with a capture template.
#+BEGIN_SRC emacs-lisp
  (require 'josh-chinese)
#+END_SRC
* Org-habit
#+begin_src emacs-lisp
  (add-to-list 'org-modules 'org-habit)
  (require 'org-habit)
#+end_src

* Exporting
  Org-mode has a bunch of great tools for exporting into HTML, pdf,
  icalendar, and so forth.
** Twitter bootstrap HTML
    The base HTML can look a little plain. This package uses bootstrap to theme HTML exports.
#+BEGIN_SRC emacs-lisp
(use-package ox-twbs
  :defer t)
#+END_SRC

** For exporting latex
http://blog.karssen.org/2013/08/22/using-bibtex-from-org-mode/
#+begin_src emacs-lisp
  (setq org-latex-pdf-process '("latexmk -pdf -bibtex %f"))
#+end_src
** Exporting calendar files

Instead of always using org-agenda, I like viewing my events and
to-dos in a calendar format. Org-mode has a pretty decent icalendar
exporter, but I find I frequently need to export updated ~.ics~ files.

To not block emacs, I'd like a function to export my calendar files
asynchronously. And so we don't constantly perform redundant exports,
let's only export org-mode agenda files that are newer than their
~.ics~ counterparts.

#+BEGIN_SRC emacs-lisp

(defun jmm/org-should-export-new-ics ()
  "Should we export a new icalendar .ics file for the current buffer?
We do this if either
- The export file doesn't exist
- The export file is older than the current buffer file.

This function needs to be run in the context of the org file
we're considering exporting."
  (let ((file (buffer-file-name (buffer-base-buffer)))
	(export-file (org-export-output-file-name ".ics")))
    (or (not (file-exists-p export-file))
	(file-newer-than-file-p file export-file))))

(defun jmm/org-export-ical-stuff ()
  "Export icalendar stuff asynchronously. Only export newly modified files."
  (interactive)
  (let ((files (cl-remove-if-not #'file-exists-p (org-agenda-files t)))
	files-to-export)
    (dolist (file files files-to-export)
      (with-current-buffer (org-get-agenda-file-buffer file)
	(when (jmm/org-should-export-new-ics)
	  (push file files-to-export))))
    (setq the-files-to-export files-to-export)
    ;; TODO: Export all files, not just files that were changed?
    (if files-to-export
	(org-export-async-start
	    (lambda (results)
	      (message "Updated %d calendar files" (seq-length results))
	      (setq blah2 results)
	      (apply 'start-process "upload-ics-process" " *upload-ics-process*" "~/code/sh/upload-ical.sh" results)
	      (dolist (f results) (org-export-add-to-stack f 'icalendar)))
	  `(let (output-files)
	     (dolist (file ',files-to-export output-files)
	       (with-current-buffer (org-get-agenda-file-buffer file)
		 (push (expand-file-name (org-icalendar-export-to-ics))
		       output-files)))))
      (message "All icalendar files are already up to date"))))

(bind-key "<f9> i" 'jmm/org-export-ical-stuff)
#+END_SRC

* Clocking
** Easier method to clock into some frequent habits
Some habits occur quite frequently, and it's kind of a pain to have to
find them in my GTD org file before clocking in. This simplifies
clocking into frequent tasks. (Mostly helps me track bad habits.)
#+begin_src emacs-lisp
  (require 'helm-adaptive)
  (defun josh/org-helm-candidates ()
    (interactive)
    (org-map-entries
     (lambda () (let* ((title (nth 4 (org-heading-components))))
                  (cons title (cons title (current-buffer)))))
     nil
     'agenda))

  (setq josh/helm-source-org-clock
    '((name . "Clock in to what")
      (candidates . josh/org-helm-candidates)
      (case-fold-search . t)
      (filtered-candidate-transformer
       helm-adaptive-sort)
      (action . (("Clock in"
                  . josh/org-clock-in)))))

  (defun josh/org-clock-in (candidate)
    "Clock into taskname in gtd-test"
    (interactive)
    (save-excursion
      (let* ((taskname (car candidate))
             (taskbuffer (cdr candidate))
             (place (org-find-exact-headline-in-buffer taskname taskbuffer)))
        (with-current-buffer (marker-buffer place)
          (goto-char place)
          (org-clock-in)))))

  (defun josh/helm-org-clock-in ()
    "Use helm to clock into a task"
    (interactive)
    (helm-other-buffer 'josh/helm-source-org-clock
                       "*Helm Clock-in*"))

  (defun josh/helm-org-jump-candidate (candidate)
    "Jump to a candidate with org"
    (interactive)
    (let* ((taskname (car candidate))
           (taskbuffer (cdr candidate))
           (place (org-find-exact-headline-in-buffer taskname taskbuffer)))
      (switch-to-buffer (marker-buffer place))
      (goto-char place)
      (org-show-context)))

  (setq josh/helm-jump-org
    '((name . "Jump to org")
      (candidates . josh/org-helm-candidates)
      (case-fold-search . t)
      (filtered-candidate-transformer
       helm-adaptive-sort)
      (action . (("Jump to"
                  . josh/helm-org-jump-candidate)))))

  (defun josh/helm-org-jump ()
    "Use helm to clock into a task"
    (interactive)
    (helm-other-buffer 'josh/helm-jump-org
                       "*Org Jump*"))

  (bind-key "<f9> j" 'josh/helm-org-jump)
#+end_src

These functions clock into a task if it exists and creates it using
~org-capture~ if it doesn't.
#+BEGIN_SRC emacs-lisp
  (defun josh/org-clock-in2 (candidate)
    "Clock into taskname, creating it if it doesn't exist."
    (interactive)
    (if (stringp candidate)
        (progn
          (kill-new candidate)
          (org-capture nil "ji"))         ;Creates a task in datetree from kill ring
      (save-excursion
        (let* ((taskname (car candidate))
               (taskbuffer (cdr candidate))
               (place (org-find-exact-headline-in-buffer taskname taskbuffer)))
          (with-current-buffer (marker-buffer place)
            (goto-char place)
            (org-clock-in))))))

  (defun josh/helm-org-clock-in2 ()
    "Use helm to clock into a task, creating it if it doesn't exist."
    (interactive)
    (josh/org-clock-in2 (helm-comp-read "Clock in to: " (josh/org-helm-candidates))))

  (bind-key "<f9> z" 'josh/helm-org-clock-in2)
#+END_SRC

** Setting a timer on the current task
   I use =<f9> z= to set the current task. When I want to set a timer,
   for instance in a pomodoro-type fashion, I'll use this function
   which I have bound to =<f9> p=. It's the same thing as
   =org-timer-set-timer=, but I don't have to switch buffers to find
   the task I'm already clocked into.
#+begin_src emacs-lisp
  (defun josh/org-current-task-timer (&optional opt)
    "Find the current clocking task and set a timer on it."
    (interactive "P")
    (when (org-clocking-p)
      (save-excursion
        (org-no-warnings (set-buffer (org-clocking-buffer)))
        (save-restriction
          (widen)
          (goto-char org-clock-marker)
          (beginning-of-line 1)
          (org-timer-set-timer opt)))))

  (bind-key "<f9> p" 'josh/org-current-task-timer)
#+end_src
** Quick key for clocking into current task

    As well as clocking into previous tasks.

#+begin_src emacs-lisp
  (bind-key "<f11>" 'org-clock-jump-to-current-clock)
  (bind-key "C-<f11>" 'org-clock-in-last)
#+end_src
** Inserting a link to the currently clocked task
    When I'm capturing tasks or other ~org~ headlines, many times it's
    related to the task I'm currently clocking.

    I like to have contexts for why I captured certain items, so it's
    nice to have a function that inserts a link to the currently
    clocked task.
#+BEGIN_SRC emacs-lisp
(defun jmm/org-current-clock-link ()
  "Get the link of the currently clocked item."
  (save-window-excursion
    (let ((org-id-link-to-org-use-id t)	;Make a global ID
	  (clock (cons org-clock-marker
		       org-clock-start-time)))
    (unless (marker-buffer (car clock))
      (error "No clock is currently running"))
    (org-with-clock clock (org-clock-goto))
    (with-current-buffer (marker-buffer (car clock))
      (save-excursion
	(goto-char (car clock))
	(org-back-to-heading t)
	(org-store-link t))))))

(defun jmm/insert-org-current-clock-link ()
  "Insert a link of the currently clocked item"
  (interactive)
  (insert (jmm/org-current-clock-link)))

(bind-key "<S-f11>" 'jmm/insert-org-current-clock-link)
#+END_SRC
* Navigating
** Jump to an org project with helm

   I like using ~helm-org-rifle~ for a lot of jumping stuff. But
   sometimes I want to jump to something that I know is a project, and
   I don't want to see a bunch of extra headlines. These functions
   show org projects in helm and let me (relatively) quickly jump to
   them.

#+BEGIN_SRC emacs-lisp
(defun jmm/skip-non-projects ()
  "Same as `bh/skip-non-projects', but doesn't skip stuck projects"
  (if (or (save-excursion (bh/skip-non-stuck-projects))
	  (save-excursion (bh/skip-stuck-projects)))
      (save-restriction
        (widen)
        (let ((subtree-end (save-excursion (org-end-of-subtree t))))
          (cond
           ((bh/is-project-p)
            nil)
           ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
            nil)
           (t
            subtree-end))))
    (save-excursion (org-end-of-subtree t))))

(defun jmm/org-helm-project-candidates ()
    (interactive)
    (org-map-entries
     (lambda ()
       (cons (format "%s: %s"
		     (s-left 13 (s-pad-left 13 " " (buffer-name)))
		     (buffer-substring (line-beginning-position) (line-end-position)))
	     (point-marker)))
     "/TODO"
     'agenda
     'jmm/skip-non-projects))

(defun jmm/org-jump-to-marker (place)
  (switch-to-buffer (marker-buffer place))
  (goto-char place)
  (org-show-context))

(setq jmm/helm-jump-org-project
    '((name . "Jump to Org project")
      (candidates . jmm/org-helm-project-candidates)
      (case-fold-search . t)
      (filtered-candidate-transformer
       helm-adaptive-sort)
      (action . (("Jump to"
                  . jmm/org-jump-to-marker)))))

(defun jmm/helm-org-jump-project ()
  "Use helm to clock into a task"
  (interactive)
  (helm-other-buffer 'jmm/helm-jump-org-project
		     "*Org Jump*"))

(bind-key "<f9> J" 'jmm/helm-org-jump-project)
#+END_SRC

* Refiling to other places
   This is so we're able to refile to other files
#+begin_src emacs-lisp
  (setq org-refile-targets (quote ((nil :maxlevel . 9)
                                   (org-agenda-files :maxlevel . 9)
                                   (("~/org/lookup.org") :maxlevel . 1))))
#+end_src
* Better task states
   From http://doc.norang.ca/org-mode.html
#+begin_src emacs-lisp
  (setq org-todo-keywords
         (quote ((sequence "TODO(t)" "NEXT(n!)" "|" "DONE(d)")
                 (sequence "WAITING(w@/!)" "HOLD(h!)" "MAYBE(m!)" "|" "CANCELLED(c@/!)" "DEFERRED(f@/!)"))))

  (setq org-todo-keyword-faces
        (quote (("TODO" :foreground "red" :weight bold)
                ("NEXT" :foreground "blue" :weight bold)
                ("DONE" :foreground "forest green" :weight bold)
                ("WAITING" :foreground "orange" :weight bold)
                ("HOLD" :foreground "magenta" :weight bold)
		("MAYBE" :foreground "yellow" :weight bold)
                ("CANCELLED" :foreground "forest green" :weight bold)
                ("DEFERRED" :foreground "tomato" :weight bold))))

  (setq org-todo-state-tags-triggers
        (quote (("CANCELLED" ("CANCELLED" . t))
                ("WAITING" ("WAITING" . t))
                ("HOLD" ("WAITING") ("HOLD" . t))
                (done ("WAITING") ("HOLD"))
                ("TODO" ("WAITING") ("CANCELLED") ("HOLD"))
                ("NEXT" ("WAITING") ("CANCELLED") ("HOLD"))
                ("DONE" ("WAITING") ("CANCELLED") ("HOLD") ("IFBORED")))))
#+end_src
* Babel
** Babel languages and settings
#+begin_src emacs-lisp
(org-babel-do-load-languages
 (quote org-babel-load-languages)
 (quote ((emacs-lisp . t)
	 (ditaa . t)
	 (R . t)
	 (python . t)
	 (ipython .t)
	 (ledger . t)
	 (org . t)
	 (latex . t)
	 (sh . t)
	 (dot . t)
	 (sql . t))))

(setq org-edit-src-content-indentation 0
      org-src-tab-acts-natively t
      org-src-window-setup 'current-window)
#+end_src
** Ditaa
#+begin_src emacs-lisp
  (setq org-ditaa-jar-path "/usr/bin/ditaa")
#+end_src
* Org Mobile Setup
   In order to sync to MobileOrg, you need to set org-mobile-directory
#+begin_src emacs-lisp
  (setq org-mobile-directory "~/org-mobile/")
#+end_src
* Tracking reading
   I'm trying to use a CSV file to track how much I read on a
   day-to-day basis. I add entries with a capture template, and these
   functions make it easier for me to enter in the book name without
   having to type it all out every time.
#+BEGIN_SRC emacs-lisp
(defun josh/prompt-book ()
  "Prompt for a book when tracking pages."
  (let ((book-out (helm-comp-read "Book: "
                                  josh/prompt-book-list
                                  :nomark t)))
    (add-to-list 'josh/prompt-book-list book-out)
    book-out))

(require 'cl)
(defun josh/prompt-book-build-list ()
  "Build a list of books I'm reading for completion in `josh/prompt-book'."
  (with-temp-buffer
    (insert-file-contents "~/org/data/reading.csv")
    (remove-duplicates
     (mapcar
      (lambda (x)
        (replace-regexp-in-string "\"" "" (nth 2 (split-string x "," t))))
      (cdr (split-string (buffer-string) "\n" t)))
     :test 'string=)))

(defvar josh/book-csv "~/org/data/reading.csv")
(defvar josh/prompt-book-list
  (if (file-exists-p josh/book-csv)
      (josh/prompt-book-build-list)))
#+END_SRC
* Org agenda filtering functions
   Here are a few org-agenda filtering functions for creating custom agendas. These do things like skip entries by tag, etc.
#+BEGIN_SRC emacs-lisp
  (defun zin/org-agenda-skip-tag (tag &optional others)
    "Skip all entries that correspond to TAG.

  If OTHERS is true, skip all entries that do not correspond to TAG."
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max))))
          (current-headline (or (and (org-at-heading-p)
                                     (point))
                                (save-excursion (org-back-to-heading)))))
      (if others
          (if (not (member tag (org-get-tags-at current-headline)))
              next-headline
            nil)
        (if (member tag (org-get-tags-at current-headline))
            next-headline
          nil))))
#+END_SRC
** Bernt Hansen's org functions
    [[http://doc.norang.ca/org-mode.html][This page]] has a really great org mode setup. Here I steal a few of his functions for filtering agenda views.
#+BEGIN_SRC emacs-lisp
  (defun bh/is-project-p ()
    "Any task with a todo keyword subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task has-subtask))))

  (defun bh/is-project-subtree-p ()
    "Any task with a todo keyword that is in a project subtree.
  Callers of this function already widen the buffer view."
    (let ((task (save-excursion (org-back-to-heading 'invisible-ok)
                                (point))))
      (save-excursion
        (bh/find-project-task)
        (if (equal (point) task)
            nil
          t))))

  (defun bh/is-task-p ()
    "Any task with a todo keyword and no subtask"
    (save-restriction
      (widen)
      (let ((has-subtask)
            (subtree-end (save-excursion (org-end-of-subtree t)))
            (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
        (save-excursion
          (forward-line 1)
          (while (and (not has-subtask)
                      (< (point) subtree-end)
                      (re-search-forward "^\*+ " subtree-end t))
            (when (member (org-get-todo-state) org-todo-keywords-1)
              (setq has-subtask t))))
        (and is-a-task (not has-subtask)))))

  (defun bh/is-subproject-p ()
    "Any task which is a subtask of another project"
    (let ((is-subproject)
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (while (and (not is-subproject) (org-up-heading-safe))
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq is-subproject t))))
      (and is-a-task is-subproject)))

  (defun bh/list-sublevels-for-projects-indented ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
    This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels 'indented)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defun bh/list-sublevels-for-projects ()
    "Set org-tags-match-list-sublevels so when restricted to a subtree we list all subtasks.
    This is normally used by skipping functions where this variable is already local to the agenda."
    (if (marker-buffer org-agenda-restrict-begin)
        (setq org-tags-match-list-sublevels t)
      (setq org-tags-match-list-sublevels nil))
    nil)

  (defvar bh/hide-scheduled-and-waiting-next-tasks t)

  (defun bh/toggle-next-task-display ()
    (interactive)
    (setq bh/hide-scheduled-and-waiting-next-tasks (not bh/hide-scheduled-and-waiting-next-tasks))
    (when  (equal major-mode 'org-agenda-mode)
      (org-agenda-redo))
    (message "%s WAITING and SCHEDULED NEXT Tasks" (if bh/hide-scheduled-and-waiting-next-tasks "Hide" "Show")))

  (defun bh/skip-stuck-projects ()
    "Skip trees that are not stuck projects"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (bh/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  nil
                next-headline)) ; a stuck project, has subtasks but no next task
          nil))))

  (defun bh/skip-non-stuck-projects ()
    "Skip trees that are not stuck projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (if (bh/is-project-p)
            (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
                   (has-next ))
              (save-excursion
                (forward-line 1)
                (while (and (not has-next) (< (point) subtree-end) (re-search-forward "^\\*+ NEXT " subtree-end t))
                  (unless (member "WAITING" (org-get-tags-at))
                    (setq has-next t))))
              (if has-next
                  next-headline
                nil)) ; a stuck project, has subtasks but no next task
          next-headline))))

  (defun bh/skip-non-projects ()
    "Skip trees that are not projects"
    ;; (bh/list-sublevels-for-projects-indented)
    (if (save-excursion (bh/skip-non-stuck-projects))
        (save-restriction
          (widen)
          (let ((subtree-end (save-excursion (org-end-of-subtree t))))
            (cond
             ((bh/is-project-p)
              nil)
             ((and (bh/is-project-subtree-p) (not (bh/is-task-p)))
              nil)
             (t
              subtree-end))))
      (save-excursion (org-end-of-subtree t))))

  (defun bh/skip-project-trees-and-habits ()
    "Skip trees that are projects"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-projects-and-habits-and-single-tasks ()
    "Skip trees that are projects, tasks that are habits, single non-project tasks"
    (save-restriction
      (widen)
      (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((org-is-habit-p)
          next-headline)
         ((and bh/hide-scheduled-and-waiting-next-tasks
               (member "WAITING" (org-get-tags-at)))
          next-headline)
         ((bh/is-project-p)
          next-headline)
         ((and (bh/is-task-p) (not (bh/is-project-subtree-p)))
          next-headline)
         (t
          nil)))))

  (defun bh/skip-project-tasks-maybe ()
    "Show tasks related to the current restriction.
  When restricted to a project, skip project and sub project tasks, habits, NEXT tasks, and loose tasks.
  When not restricted, skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max))))
             (limit-to-project (marker-buffer org-agenda-restrict-begin)))
        (cond
         ((bh/is-project-p)
          next-headline)
         ((org-is-habit-p)
          subtree-end)
         ((and (not limit-to-project)
               (bh/is-project-subtree-p))
          subtree-end)
         ((and limit-to-project
               (bh/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-project-tasks ()
    "Show non-project tasks.
  Skip project and sub-project tasks, habits, and project related tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         ((bh/is-project-subtree-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-non-project-tasks ()
    "Show project tasks.
  Skip project and sub-project tasks, habits, and loose non-project tasks."
    (save-restriction
      (widen)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((bh/is-project-p)
          next-headline)
         ((org-is-habit-p)
          subtree-end)
         ((and (bh/is-project-subtree-p)
               (member (org-get-todo-state) (list "NEXT")))
          subtree-end)
         ((not (bh/is-project-subtree-p))
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-projects-and-habits ()
    "Skip trees that are projects and tasks that are habits"
    (save-restriction
      (widen)
      (let ((subtree-end (save-excursion (org-end-of-subtree t))))
        (cond
         ((bh/is-project-p)
          subtree-end)
         ((org-is-habit-p)
          subtree-end)
         (t
          nil)))))

  (defun bh/skip-non-subprojects ()
    "Skip trees that are not projects"
    (let ((next-headline (save-excursion (outline-next-heading))))
      (if (bh/is-subproject-p)
          nil
        next-headline)))

  (defun bh/find-project-task ()
    "Move point to the parent (project) task if any"
    (save-restriction
      (widen)
      (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
        (while (org-up-heading-safe)
          (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
            (setq parent-task (point))))
        (goto-char parent-task)
        parent-task)))

  (defun josh/skip-project-to-next-heading ()
    "Skip project tasks, but instead of going to the end of the
  subtree, just go to the next headline"
    (save-restriction
      (widen)
      (let* ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
        (cond
         ((bh/is-project-p)
          next-headline)
         (t
          nil)))))
#+END_SRC
* Find old closed entries
   My org files seem to now be accumulating a bunch of "DONE" entries
   that have been closed a long time ago. These functions and agenda
   help me find these old entries so I can archive them
#+BEGIN_SRC emacs-lisp
  (defun josh/org-closed-days-old ()
    "Get how many days ago this entry was closed."
    (josh/org-timestamp-days-old
     (org-element-property :closed (org-element-at-point))))

  (defun josh/org-timestamp-days-old (timestamp)
    (- (calendar-absolute-from-gregorian (calendar-current-date))
       (josh/org-timestamp-to-absolute-date timestamp)))

  (defun josh/org-timestamp-to-absolute-date (timestamp)
    "Get an integer date from timestamp. Used for date differences"
    (calendar-absolute-from-gregorian
     (if timestamp
         (mapcar (lambda (x) (plist-get (cadr timestamp) x)) '(:month-start :day-start :year-start))
       (calendar-current-date))))

  (defun josh/org-skip-old (age)
    "Skip all entries that were closed more than AGE days ago."
    (let ((next-headline (save-excursion (or (outline-next-heading) (point-max)))))
      (if (> (josh/org-closed-days-old) age)
          nil
        next-headline)))

  (org-add-agenda-custom-command
   '("o" "Old done tasks" todo "DONE|CANCELLED"
     ((org-agenda-skip-function (lambda () (josh/org-skip-old 14)))
      (org-agenda-overriding-header "Old DONE tasks: "))))
#+END_SRC
* Show effort and clocked time
   If you modify ~org-agenda-prefix-format~, you can get some extra
   details in your agenda view. Here's how I view effort and clocked time.
#+BEGIN_SRC emacs-lisp
  (require 'org-clock)
  (defun josh/minutes-to-hhmm (min)
      (let* ((h (floor (/ min 60)))
             (m (- min (* 60 h))))
        (format "%01d:%02d" h m)))

  (defun josh/org-show-effort-and-clocked (&optional noparens)
    "Show how much effort or clocked time there is.
    If no effort is set, show \"+\" clocked
    If there's no effort and no clocked time, show nothing
    If there's effort but no clocked time, show effort
    If there effort and clocked time, show \"-\" remaining effort
    If done, show clocked time.

    With optional parameter NOPARENS, don't include square brackets in output"
    (if (not (outline-on-heading-p t))
        ""
      (format (if noparens "%s" "[%s]")
              (let ((effort (org-get-at-eol 'effort-minutes 1))
                    (clocked (org-clock-sum-current-item (org-clock-get-sum-start))))
                (if (org-entry-is-todo-p)
                    (if effort
                        (if (> clocked 0)
                            (format "-% 3d" (- effort clocked))
                          (josh/minutes-to-hhmm effort))
                      (if (> clocked 0)
                          (format "+% 3d" clocked)
                        "    "))
                  (format "+% 3d" clocked))))))
#+END_SRC
* Helm Org Buffer
   This command makes it easy to quickly switch to an org-mode buffer.
#+BEGIN_SRC emacs-lisp
(require 'helm-types)
(require 'helm-buffers)
(defvar helm-org-buffers-list-cache nil)

(defclass helm-source-org-buffer (helm-source-sync helm-type-buffer)
  ((init :initform (lambda ()
                     (setq helm-org-buffers-list-cache
                           (mapcar (lambda (b)
                                     (with-current-buffer b (buffer-name)))
                                   (-filter (lambda (b)
                                              (with-current-buffer b
                                                (and (eq major-mode 'org-mode)
                                                     (buffer-name))))
                                            (buffer-list))))
                     (let ((result (cl-loop for b in helm-org-buffers-list-cache
                                            maximize (length b) into len-buf
                                            maximize (length (with-current-buffer b
                                                               (symbol-name major-mode)))
                                            into len-mode
                                            finally return (cons len-buf len-mode))))
                       (unless helm-buffer-max-length
                         (setq helm-buffer-max-length (car result)))
                       (unless helm-buffer-max-len-mode
                         (setq helm-buffer-max-len-mode (cdr result))))))
   (candidates :initform helm-org-buffers-list-cache)
   (matchplugin :initform nil)
   (match :initform 'helm-buffers-match-function)
   (persistent-action :initform 'helm-buffers-list-persistent-action)
   (keymap :initform helm-buffer-map)
   (volatile :initform t)
   (persistent-help
    :initform
    "Show this buffer / C-u \\[helm-execute-persistent-action]: Kill this buffer")))

(defvar helm-source-org-buffers-list (helm-make-source "Org-mode buffers" 'helm-source-org-buffer))

(defun helm-org-buffer ()
  (interactive)
  (helm :sources helm-source-org-buffers-list
        :buffer "*helm projectile*"
        :prompt "Switch to Org buffer:"))

;; (bind-key "C-c o" 'helm-org-buffer)
;; This is also a good key just for swooping
(bind-key "C-c O" 'helm-multi-swoop-org)
#+END_SRC
* Show how old an entry is
   I usually have "Added: [inactive timestamp]" added to most of my
   entries when captured with org-capture. Sometimes, I have
   unscheduled tasks around for a while, so these functions let me see
   how old they are. You could also use something like ~org-expiry~
   for something this.

   (Lately I've moved to using the "CREATED" property from ~org-expiry~)
#+BEGIN_SRC emacs-lisp
(defun josh/org-get-added-time ()
  "Get the time an entry was added"
  (or
   (org-entry-get (point) org-expiry-created-property-name)
   (save-excursion
     (org-back-to-heading t)
     (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
       (if (re-search-forward "Added: \\(\\[.*\\]\\)" subtree-end t)
	   (match-string 1))))))


(defun josh/org-format-age-from-added ()
  "Get age from the added date"
  (format "[%s|%s]"
          (let ((josh-added-time (josh/org-get-added-time)))
            (if josh-added-time
                (format "%3dd" (- (calendar-absolute-from-gregorian (calendar-current-date))
                                  (org-time-string-to-absolute josh-added-time)))
              "????"))
          (josh/org-show-effort-and-clocked t)))
#+END_SRC
* Show how long I've been waiting for something
   I have a section for "Waiting" tasks in my org agenda. I'd also
   like to see how long I've been waiting for them, to remind me if I
   should follow up.
#+BEGIN_SRC emacs-lisp
  (defun josh/org-get-waiting-time ()
    "Get the time we started waiting for a task"
    (save-excursion
      (org-back-to-heading t)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
        (if (re-search-forward "State \"WAITING\".*\\(\\[.*\\]\\)" subtree-end t)
            (match-string 1)))))

  (defun josh/org-format-waiting-time ()
    "Get age from the added date"
    (format "[%s]"
            (let ((josh-waiting-time (josh/org-get-waiting-time)))
              (if josh-waiting-time
                  (format "%3dd" (- (calendar-absolute-from-gregorian (calendar-current-date))
                                    (org-time-string-to-absolute josh-waiting-time)))
                "??"))))
#+END_SRC
* Show how long a task has been in the "Next" state
   How old is this task from when it was changed to a "next" task? Or
   when was it added? Take the more recent of the two.
#+BEGIN_SRC emacs-lisp
  (defun josh/org-get-next-time ()
    "Get the time we turned this task into a 'next' task"
    (save-excursion
      (org-back-to-heading t)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
        (if (re-search-forward "State \"NEXT\".*\\(\\[.*\\]\\)" subtree-end t)
            (match-string 1)))))

  (defun josh/absolute-time-or-0 (x)
    (if x (org-time-string-to-absolute x) 0))

  (defun josh/org-format-next-time ()
    "How long has an unscheduled 'next' task been waiting? Take the more recent of the added or changed-to-next date."
    (format "[%s]"
            (let* ((josh-added-time (josh/org-get-added-time))
                   (josh-next-time  (josh/org-get-next-time))
                   (josh-waiting-time (when (or josh-added-time josh-next-time)
                                        (max (josh/absolute-time-or-0 josh-added-time)
                                             (josh/absolute-time-or-0 josh-next-time)))))
              (if josh-waiting-time
                  (format "%3dd" (- (calendar-absolute-from-gregorian (calendar-current-date))
                                    josh-waiting-time))
                "??"))))

#+END_SRC

* Show when the last time I've made progress on a project
   I've got a list of stuck projects on my agenda. I'd like to know
   how long they've been stuck for. These functions show how many days
   it's been since I've clocked into a task in the project.
#+BEGIN_SRC emacs-lisp
  (defun josh/org-get-end-clock-times ()
    "Get the last times we clocked out of a task. Return as a list."
    (save-excursion
      (org-back-to-heading t)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (matches nil))
        (while (re-search-forward "CLOCK: .*--\\(\\[.*\\]\\)" subtree-end t)
          (setq matches (cons (match-string-no-properties 1) matches)))
        matches)))

  (defun josh/org-get-closed-times ()
    "Get the times we closed a task. Return as a list."
    (save-excursion
      (org-back-to-heading t)
      (let* ((subtree-end (save-excursion (org-end-of-subtree t)))
             (matches nil))
        (while (re-search-forward "CLOSED: \\(\\[.*\\]\\)" subtree-end t)
          (setq matches (cons (match-string-no-properties 1) matches)))
        matches)))

  (defun josh/org-get-max-time (mytimes)
    "Get the largest day of a list of times.."
    (let ((times (mapcar #'org-time-string-to-absolute mytimes)))
      (when times
        (apply 'max times))))

  (defun josh/org-format-max-clock-time ()
    "Format how many days ago we clocked out of a task. Used for projects."
    (format "[%s/%s]"
            (let ((josh-last-clock-time (josh/org-get-max-time (josh/org-get-end-clock-times))))
              (if josh-last-clock-time
                  (format "%3dd" (- (calendar-absolute-from-gregorian (calendar-current-date))
                                    josh-last-clock-time))
                "  ??"))
            (let ((josh-last-closed-time (josh/org-get-max-time (josh/org-get-closed-times))))
              (if josh-last-closed-time
                  (format "%3dd" (- (calendar-absolute-from-gregorian (calendar-current-date))
                                    josh-last-closed-time))
                "  ??"))))
#+END_SRC
* Use speed keys
   [[http://orgmode.org/manual/Speed-keys.html][Speed keys]] make it really quick to do things like sorting headlines.
#+BEGIN_SRC emacs-lisp
  (setq org-use-speed-commands t)
#+END_SRC
* Org expiry
   Use org-expiry to make a "created" property.
#+BEGIN_SRC emacs-lisp
(setq org-expiry-created-property-name "CREATED")
(setq org-expiry-inactive-timestamps t)
;; (use-package org
;;   :bind (:map org-mode-map
;; 	      ("M-N" . org-expiry-insert-created)))
#+END_SRC

  Actually I'm gonna shadow that with a function that will either
  convert the "Added: " field I usually have, or insert a timestamp
#+BEGIN_SRC emacs-lisp
(defun josh/org-convert-added-to-created-property ()
  "Convert the \"Added: [timestamp]\" I've used in the past to using
  the CREATED property set by org-expiry.

  Return t if we found and deleted it."
  (interactive)
  (save-excursion
    (org-back-to-heading t)
    (let* ((subtree-end (save-excursion (org-end-of-subtree t))))
      (when (re-search-forward "Added: \\(\\[.*\\]\\)" subtree-end t)
	(org-entry-put (point) org-expiry-created-property-name (match-string 1))
	(delete-region (progn (forward-line 0) (point)) ;Delete the line
		       (progn (forward-line 1) (point)))
	t))))

(defun josh/org-convert-added-or-add-created ()
  "Convert the \"Added:\" style lines I have in capture
  templates, otherwise add the CREATED property (or whichever
  property is defined by `org-expiry-created-property-name') to
  the heading using `org-expiry-insert-created'"
  (interactive)
  (unless (josh/org-convert-added-to-created-property)
    (org-expiry-insert-created)))
#+END_SRC
** Add ~CREATED~ property to captured headlines
    I'd like to know when I captured headlines. Here I'll add a hook
    to ~org-capture-mode~ that adds the ~CREATED~ property if we're
    capturing an org-mode heading.
#+BEGIN_SRC emacs-lisp
(defun jmm/org-capture-add-created-time ()
  "Add the CREATED property among when capturing a headline"
  (when (and (eq major-mode 'org-mode)
	     (eq (org-capture-get :type) 'entry))
    (josh/org-convert-added-or-add-created)))

(add-hook 'org-capture-mode-hook 'jmm/org-capture-add-created-time)
#+END_SRC
* Marking headings with a tag
   Sometimes I want to perform an action in bulk on a bunch of
   entries. For example, I might want to refile a bunch of headings or
   add a lot of tags for similar headings. This can be pretty tedious
   to do manually, especially since there's a ~org-agenda-bulk-action~
   command (usually bound to ~B~ in ~org-agenda~) that helps us out.

   In order to get a bunch of "marked" entries in an agenda, though,
   we want a quick way to add something like a "MARKED" tag. The code
   below does that.

   (Note, I probably moved it above in the ~use-package~ for org)

#+BEGIN_SRC emacs-lisp
(defun josh/org-toggle-marked-tag ()
  "Add a \"MARKED\" tag to a headline"
  (interactive)
  (org-toggle-tag "MARKED"))
#+END_SRC

* Org-ref
   I'm starting to learn to use [[https://github.com/jkitchin/org-ref][org-ref]].
#+BEGIN_SRC emacs-lisp
(use-package org-ref
  :defer t
  :init
  (setq org-ref-bibtex-hydra-key-binding (kbd "C-c C-j"))
  (setq reftex-default-bibliography '("~/org-ref/references.bib"))
  ;; see org-ref for use of these variables
  (setq org-ref-bibliography-notes "~/org-ref/notes.org"
	org-ref-default-bibliography (file-expand-wildcards "~/org-ref/*.bib")
	org-ref-pdf-directory "~/org-ref/bibtex-pdfs/")
  (setq bibtex-completion-bibliography org-ref-default-bibliography
	bibtex-completion-library-path '("~/org-ref/bibtex-pdfs" "~/org-ref/zotfile")
	bibtex-completion-pdf-field "file"
	bibtex-completion-additional-search-fields '(keywords journal)
	bibtex-completion-notes-path "~/org-ref/helm-bibtex-notes")
  (setq bibtex-completion-display-formats
	'((t . "${author:36} ${title:*} ${year:4} ${journal:7} ${=has-pdf=:1}${=has-note=:1} ${keywords:12}")))
  (bind-key "C-c z" 'helm-bibtex)
  ;; Use helm-bibtex-notes file for notes
  (setq org-ref-notes-function
	(lambda (thekey)
	  (let ((bibtex-completion-bibliography (org-ref-find-bibliography)))
	    (bibtex-completion-edit-notes
	     (list (car (org-ref-get-bibtex-key-and-file thekey))))))))

(use-package org-ref-bibtex
  :defer t
  :init
  (setq org-ref-bibtex-hydra-key-binding (kbd "C-c C-j")))
#+END_SRC
** Associate most recent PDF with bibtex entry

Here's a function for associating the most recently downloaded PDF with a bibtex entry
#+BEGIN_SRC emacs-lisp
(defun josh/org-ref-bibtex-assoc-most-recent-pdf-with-entry (&optional prefix)
  "Associate the most recent PDF file in ~/Downloads with the current bibtex entry.
This is basically a copy of `org-ref-bibtex-assoc-pdf-with-entry'. Optional PREFIX argument
toggles between `rename-file' and `copy-file'"
  (interactive "P")
  (save-excursion
    (bibtex-beginning-of-entry)
    (let* ((file (josh/latest-file "~/Downloads" ".*\.[pP][dD][fF]$"))
	   (bibtex-expand-strings t)
           (entry (bibtex-parse-entry t))
           (key (reftex-get-bib-field "=key=" entry))
           (pdf (concat org-ref-pdf-directory (concat key ".pdf")))
	   (file-move-func (org-ref-bibtex-get-file-move-func prefix)))
      (if (file-exists-p pdf)
	  (message (format "A file named %s already exists" pdf))
	(progn
	  (funcall file-move-func file pdf)
	  (message (format "Created file %s from %s" pdf file)))))))
#+END_SRC
** Find zotero files

I use [[http://zotfile.com/][Zotfile]] to move PDFs from a bunch of disparate folders in Zotero
to one shared folder. Zotfile moves PDFs and stores them as links in
entries. When [[https://github.com/retorquere/zotero-better-bibtex][Better BibTeX]] exports ~.bib~ files, these files show up
as being a ~/zotfile/~ folder. Helm-bibtex interprets this as an
absolute path (which it kind of should), and isn't able to find my PDF
files. This tries to fix that.

I assume that files are stored in a "zotfile" directory.

Also, this advice removes HTML snapshots, since I generally don't want
to look at them anyway.

#+BEGIN_SRC emacs-lisp
(defun jmm/helm-bibtex-replace-zotfile-with-relative-path (orig-fun &rest args)
  "Replace \"/zotfile/\" with \"zotfile\". Also remove any snapshots."
  (let ((res (apply orig-fun args)))
    (if (stringp res)
	(replace-regexp-in-string "\\(;[a-zA-Z0-9 ]*?Snapshot:.*?text/html\\|/zotfile/\\)" "" res)
      res)))

(advice-add 'bibtex-completion-get-value :around #'jmm/helm-bibtex-replace-zotfile-with-relative-path)
#+END_SRC
* Org Edna

  [[http://www.nongnu.org/org-edna-el/][Org Edna]] looks like a cool package for managing dependencies and
  actions in org-mode. It basically builds off of [[http://orgmode.org/worg/org-contrib/org-depend.html][org-depend.el]], which
  was made as a proof-of-concept for dependencies. Org Edna adds more
  sophisticated ways of finding dependencies and triggering actions,
  but one of the coolest things is that it's extensible. You can add
  your own functions for dependencies and actions.

#+BEGIN_SRC emacs-lisp
(use-package org-edna
  :after org
  :ensure t
  :config
  (org-edna-load))
#+END_SRC
** Use links instead of bare UUIDs

   One of the great features of Org Edna compared to org-depend is the
   ability to use global dependencies. This means you can depend on
   headlines in different files. One way to depend on external
   headlines is to use the "~ids~" keyword with a UUID. The problem is
   that UUIDs don't give you an idea of what you're depending on (or
   triggering).

   This function gives you the finder ~link-ids~, which works like
   ~ids~ but instead takes quoted org mode links to headlines (using
   the ~id:~ form). This lets you quickly add dependencies with
   ~org-store-link~ / ~org-insert-link~, and allows you to see
   dependencies' headlines.

#+BEGIN_SRC emacs-lisp
(defun org-edna-finder/link-ids (&rest ids)
  "Find a list of headlines with given IDs.

Unlike `org-edna-finder/ids', IDS here can be links of the form \"[[id:UUID][Headline]]\" (in quotes).
This allows for easier readability of targets."
  (mapcar (lambda (id) (save-window-excursion
			 (org-open-link-from-string id)
			 (point-marker)))
	  ids))
#+END_SRC
** A hydra for setting some common triggers

   It's a bit of a pain to set Org Edna triggers with
   ~org-set-property~. I have a few common triggers I use that I'd
   like to be able to set quickly. They are:
   - Trigger the last stored link
   - Set the next sibling to "NEXT"
   - Mark the parent as "DONE"


   Here I make a function for setting the ~TRIGGER~ property and
   moving the point to it, so we can easily change the trigger after
   setting it. Then, I make a hydra for setting some of the triggers I
   mentioned earlier
#+BEGIN_SRC emacs-lisp
(defun jmm/org-edna-set-trigger-and-point (triggervalue)
  "Set the TRIGGER property to TRIGGERVALUE. Move the point to
the newly set value. Open the PROPERTIES drawer."
  (let ((property "TRIGGER"))
    (org-entry-put (point) property triggervalue)
    (org-back-to-heading t)
    (let* ((beg (point))
	   (range (org-get-property-block beg 'force))
	   (end (cdr range))
	   (case-fold-search t))
      (goto-char (1- (car range)))	;Need to go one character back to get property-drawer element
      (let ((element (org-element-at-point)))
	(when (eq (org-element-type element) 'property-drawer)
	  (org-flag-drawer nil element)))
      (goto-char (car range))
      (re-search-forward (org-re-property property nil t) end t))))

(defun jmm/org-edna-chain-next ()
  "Set TRIGGER to chain next"
  (interactive)
  (jmm/org-edna-set-trigger-and-point "next-sibling todo!(NEXT) chain!(\"TRIGGER\")"))

(defun jmm/org-pop-stored-link ()
  "Get the string for the previously stored link, then remove it from `org-stored-links'"
  (let* ((firstlink (car org-stored-links))
       (link (car firstlink))
       (desc (cadr firstlink)))
    (setq org-stored-links (delq (assoc link org-stored-links)
				   org-stored-links))
    (org-make-link-string link desc)))

(defun jmm/org-edna-link (&optional rest)
  "Set TRIGGER to chain next. With option"
  (interactive)
  (jmm/org-edna-set-trigger-and-point
   (format "link-ids(\"%s\")%s" (jmm/org-pop-stored-link) (if rest (concat " " rest) ""))))

(defhydra jmm/org-edna-hydra (:color blue)
  "Org Edna"
  ("l" jmm/org-edna-link "Link")
  ("L" (jmm/org-edna-link "todo!(NEXT)") "Link NEXT")
  ("n" (jmm/org-edna-set-trigger-and-point "next-sibling todo!(NEXT)") "Next sibling NEXT")
  ("N" (jmm/org-edna-set-trigger-and-point "next-sibling todo!(NEXT) chain!(\"TRIGGER\")") "Chain next-sibling NEXT")
  ("p" (jmm/org-edna-set-trigger-and-point "parent todo!(DONE)") "Parent DONE")
  ("q" nil "cancel"))

(bind-key "<f9> d" 'jmm/org-edna-hydra/body)
#+END_SRC
* Other useful functions
** Org agenda current subtree or region

alphapapa [[https://disqus.com/home/discussion/mollermara/fast_refiling_in_org_mode_with_hydras/#comment-3297304571][has a good function]] for creating an agenda for just the
current subtree or region

#+BEGIN_SRC emacs-lisp
(defun ap/org-agenda-current-subtree-or-region (prefix)
  "Display an agenda view for the current subtree or region.
With prefix, display only TODO-keyword items."
  ;; BUG: This doesn't work properly in indirect or narrowed (both?)
  ;; buffers: it acts upon the whole buffer instead. It works in
  ;; direct buffers.
  (interactive "p")
  (let (header)
    (if (use-region-p)
	(progn
	  (setq header "Region")
	  (put 'org-agenda-files 'org-restrict (list (buffer-file-name (current-buffer))))
	  (setq org-agenda-restrict (current-buffer))
	  (move-marker org-agenda-restrict-begin (region-beginning))
	  (move-marker org-agenda-restrict-end
		       (save-excursion
			 ;; If point is at beginning of line, include heading on that line by moving point forward 1 char
			 (goto-char (1+ (region-end)))
			 (org-end-of-subtree))))
      (progn
	;; No region; restrict to subtree
	(setq header "Subtree")
	(org-agenda-set-restriction-lock 'subtree)))

    ;; Sorting doesn't seem to be working, but the header is
    (let ((org-agenda-sorting-strategy '(priority-down timestamp-up))
	  (org-agenda-sticky nil)		;Force regeneration
	  (org-agenda-overriding-header header))
      (org-search-view (if (>= prefix 4) t nil) "*"))
    (org-agenda-remove-restriction-lock t)
    (message nil)))

(bind-key "<f9> o r" 'ap/org-agenda-current-subtree-or-region)
#+END_SRC
** Hide planning information

   Most of my headings in org-mode have a ~PROPERTIES~ drawer. Many of
   them also have ~LOGBOOK~ drawers and scheduling
   information. Sometimes, when I want an overview of an org-mode
   file, all these planning, properties, and logbook lines visually
   clutter my screen. These functions are my first attempt at hiding
   them when using global cycling.

#+BEGIN_SRC emacs-lisp
(defun jmm/org-end-planning-stuff ()
  "Return the point where planning, properties, and drawers end."
  (save-excursion
    (let (already-jumped-heading)
      (while (let* ((element (org-element-at-point))
		    (type (car element))
		    (jumpto (case type
			      (headline (unless already-jumped-heading
					  (progn (setq already-jumped-heading t)
						 (or (org-element-property :contents-begin element)
						     (org-element-property :end element)))))
			      (planning (org-element-property :end element))
			      (property-drawer (org-element-property :end element))
			      (drawer (org-element-property :end element))
			      (t nil))))
	       (when jumpto
		 (goto-char jumpto)))
	t)
      (point))))

(defun jmm/org-hide-planning-stuff ()
  "When at a heading, hide planning info"
  (when (org-at-heading-p)
      (outline-flag-region (line-end-position) (- (jmm/org-end-planning-stuff) 1) t)))

(defun jmm/org-cycle-hide-scheduled-properties-logbook (state)
  "Re-hide all drawers after a visibility state change.
STATE should be one of the symbols listed in the docstring of
`org-cycle-hook'.  When non-nil, optional argument EXCEPTIONS is
a list of strings specifying which drawers should not be hidden."
  (when (and (derived-mode-p 'org-mode)
	     (memq state '(all)))
    (org-map-tree 'jmm/org-hide-planning-stuff)))

(add-hook 'org-cycle-hook 'jmm/org-cycle-hide-scheduled-properties-logbook)
#+END_SRC
* Links
** PDFView links

   This adds ways to store and jump to links for PDF files viewed with
   [[https://github.com/politza/pdf-tools][PDF tools]].

   By default when using `C-c l` to store links, we'll just save the
   file and page number. If the region is active in the PDF view,
   we'll store that instead. If it's a text region, store the text as
   a description. If it's a rectangle region, don't.

   We can also store links to annotations (See [[./jmm-emacs.org][jmm-emacs.org]]), but
   they're not as stable right now. Especially if you delete
   annotations, it may affect other links.

#+BEGIN_SRC emacs-lisp
(org-link-set-parameters "pdfview"
			 :follow #'jmm/org-pdfview-follow-link
			 :store #'jmm/org-pdfview-store-link)

(defun jmm/org-pdfview-store-link ()
  "Store a link to a pdfview page"
  (when (eq major-mode 'pdf-view-mode)
    (let* ((page (pdf-view-current-page))
	   (file (bookmark-buffer-file-name))
	   desc link)
      (if (pdf-view-active-region-p)
	  ;; Store the region
	  (let ((region (pdf-view-active-region))
		(regiontext (jmm/pdf-view-unfill-text))
		(isrect pdf-view--have-rectangle-region))
	    (org-store-link-props :type "pdfview" :page page :region region :file file)
	    (setq desc (if isrect
			   (format "%s rectangle on page %s" (s-chop-suffix ".pdf" (buffer-name)) page)
			 regiontext))
	    (setq link (format "pdfview:%s::%s" file (if isrect
							 (list :page page :region region :rect t)
							 (list :page page :region region)))))

	;; Store the page
	  (progn
	    (org-store-link-props :type "pdfview" :page page :file file)
	    (setq desc (format "%s page %s" (s-chop-suffix ".pdf" (buffer-name)) page))
	    (setq link (format "pdfview:%s::%s" file page))))
      (org-add-link-props :link link :description desc)
      link)))

(defun jmm/org-pdfview-follow-link (link)
  "Follow a pdfview link."
  (-let* (((file rawloc) (s-split "::" link))
	  (loc (car (read-from-string rawloc))))
    (find-file-other-window file)
    (unless (derived-mode-p 'pdf-view-mode)
      (pdf-view-mode))
    (cond
     ((numberp loc) (pdf-view-goto-page loc))
     ((plist-get loc :region) (progn (pdf-view-goto-page (plist-get loc :page))
				     (setq pdf-view-active-region (plist-get loc :region))
				     (pdf-view-display-region pdf-view-active-region (plist-get loc :rect))
				     (pdf-util-scroll-to-edges (pdf-util-scale-relative-to-pixel (car pdf-view-active-region)))))
     ((plist-get loc :annot) (pdf-annot-show-annotation (pdf-info-getannot (plist-get loc :annot)) t)))))
#+END_SRC
** Opening links with other browsers

   Occasionally I want to open org-mode links in incognito/private
   mode or my non-default browser. Here I add advice to
   ~org-open-at-point~, which allows me to set specific browser
   programs and arguments for opening a link.

   For example, using ~C-u C-c C-o~, I can open a link in Chromium's
   incognito mode. With ~C-u 2 C-c C-o~ I can open with Firefox's
   normal mode. And with ~C-u 3 C-c C-o~ I can open with Firefox's
   private mode.

#+BEGIN_SRC emacs-lisp
(defvar jmm/browse-url-generic-alternate '(("chromium" "--incognito")
					   ("firefox")
					   ("firefox" "--private-window"))
  "A list of programs and arguments to set
  `browse-url-generic-program' and
  `browse-url-generic-args'.")

(defun jmm/org-open-link-alternate-browser (orig-fun &rest args)
  "With a prefix arg, set `browse-url-generic-program' and
`browse-url-generic-args' to use different settings in `jmm/browse-url-generic-alternate'.

With universal prefix, use first option in
`jmm/browse-url-generic-alternate'. With a number argument, use
the nth option in `jmm/browse-url-generic-alternate'.

Handy for opening in other browsers or incognito/private mode."
  (if (car args)
      (let* ((jmm/browse-url-alt (if (listp (car args)) (car jmm/browse-url-generic-alternate)
				   (elt jmm/browse-url-generic-alternate (- (car args) 1))))
	     (browse-url-generic-program (car jmm/browse-url-alt))
	     (browse-url-generic-args (cdr jmm/browse-url-alt)))
	(apply orig-fun args))
    (apply orig-fun args)))

(advice-add 'org-open-at-point :around #'jmm/org-open-link-alternate-browser)
#+END_SRC
